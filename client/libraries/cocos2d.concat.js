/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
/* Simple JavaScript Inheritance
 * By John Resig http://ejohn.org/
 * MIT Licensed.
 */
// Inspired by base2 and Prototype

/**
 * @namespace
 */
var cc = cc = cc || {};

(function () {
    var initializing = false, fnTest = /\b_super\b/;

    /**
     * The base Class implementation (does nothing)
     * @class
     */
    cc.Class = function () {
    };

    /**
     * Create a new Class that inherits from this Class
     * @param {object} prop
     * @return {function}
     */
    cc.Class.extend = function (prop) {
        var _super = this.prototype;

        // Instantiate a base Class (but only create the instance,
        // don't run the init constructor)
        initializing = true;
        var prototype = new this();
        initializing = false;

        // Copy the properties over onto the new prototype
        for (var name in prop) {
            // Check if we're overwriting an existing function
            prototype[name] = typeof prop[name] == "function" &&
                typeof _super[name] == "function" && fnTest.test(prop[name]) ?
                (function (name, fn) {
                    return function () {
                        var tmp = this._super;

                        // Add a new ._super() method that is the same method
                        // but on the super-Class
                        this._super = _super[name];

                        // The method only need to be bound temporarily, so we
                        // remove it when we're done executing
                        var ret = fn.apply(this, arguments);
                        this._super = tmp;

                        return ret;
                    };
                })(name, prop[name]) :
                prop[name];
        }

        // The dummy Class constructor
        function Class() {
            // All construction is actually done in the init method
            if (!initializing && this.ctor)
                this.ctor.apply(this, arguments);
        }

        // Populate our constructed prototype object
        Class.prototype = prototype;

        // Enforce the constructor to be what we expect
        Class.prototype.constructor = Class;

        // And make this Class extendable
        Class.extend = arguments.callee;

        //add implementation method
        Class.implement = function (prop) {
            for (var name in prop) {
                prototype[name] = prop[name];
            }
        };
        return Class;
    };
})();


/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
/**
 * Browser detection, based on mootools<br/>
 * platform will print out win32, mac, etc<br/>
 * type is the browser type, chrome, firefox etc
 * @type {Object}
 */
cc.Browser = {};
(function () {
    cc.Browser.ua = navigator.userAgent.toLowerCase();
    cc.Browser.platform = navigator.platform.toLowerCase();
    cc.Browser.UA = cc.Browser.ua.match(/(opera|ie|firefox|chrome|version)[\s\/:]([\w\d\.]+)?.*?(safari|version[\s\/:]([\w\d\.]+)|$)/) || [null, 'unknown', 0];
    cc.Browser.mode = cc.Browser.UA[1] == 'ie' && document.documentMode;
    cc.Browser.type = (cc.Browser.UA[1] == 'version') ? cc.Browser.UA[3] : cc.Browser.UA[1];
    cc.Browser.isMobile = (cc.Browser.ua.indexOf('mobile') != -1 || cc.Browser.ua.indexOf('android') != -1);
})();


/**
 * the dollar sign, classic like jquery, this selector add extra methods to HTMLElement without touching its prototype</br>
 * it is also chainable like jquery
 * @param {HTMLElement|String} x pass in a css selector in string or the whole HTMLElement
 * @class
 * @return {cc.$}
 */
cc.$ = function (x) {
    /** @lends cc.$# */
    var parent = (this == cc) ? document : this;

    /**
     * @type {HTMLElement}
     */
    var el = (x instanceof HTMLElement) ? x : parent.querySelector(x);

    if (el) {
        /**
         * find and return the child wth css selector (same as jquery.find)
         * @param {HTMLElement|String} x pass in a css selector in string or the whole HTMLElement
         * @return {cc.$}
         */
        el.find = el.find || cc.$;
        /**
         * check if a DOMNode has a specific class
         * @param {String} cls
         * @return {Boolean}
         */
        el.hasClass = el.hasClass || function (cls) {
            return this.className.match(new RegExp('(\\s|^)' + cls + '(\\s|$)'));
        };
        /**
         * add a class to a DOMNode, returns self to allow chaining
         * @param {String} cls
         * @return {cc.$}
         */
        el.addClass = el.addClass || function (cls) {
            if (!this.hasClass(cls)) this.className += " " + cls;
            return this;
        };
        /**
         * remove a specific class from a DOMNode, returns self to allow chaining
         * @param {String} cls
         * @return {cc.$}
         */
        el.removeClass = el.removeClass || function (cls) {
            if (this.hasClass(cls)) {
                this.className = this.className.replace(cls, '');
            }
            return this;
        };
        /**
         * detach it self from parent
         * @function
         */
        el.remove = el.remove || function () {
            if (this.parentNode)
                this.parentNode.removeChild(this);
            return this;
        };

        /**
         * add to another element as a child
         * @param {HTMLElement|cc.$} x
         * @return {cc.$}
         */
        el.appendTo = el.appendTo || function (x) {
            x.appendChild(this);
            return this;
        };

        /**
         * add to another element as a child and place on the top of the children list
         * @param {HTMLElement|cc.$} x
         * @return {cc.$}
         */
        el.prependTo = el.prependTo || function (x) {
            ( x.childNodes[0]) ? x.insertBefore(this, x.childNodes[0]) : x.appendChild(this);
            return this;
        };

        /**
         * helper function for updating the css transform
         * @return {cc.$}
         */
        el.transforms = el.transforms || function () {
            this.style[cc.$.trans] = cc.$.translate(this.position) + cc.$.rotate(this.rotation) + cc.$.scale(this.scale) + cc.$.skew(this.skew);
            return this;
        };

        el.position = el.position || {x:0, y:0};
        el.rotation = el.rotation || 0;
        el.scale = el.scale || {x:1, y:1};
        el.skew = el.skew || {x:0, y:0};

        /**
         * move the element
         * @param {Number} x in pixel
         * @param {Number} y in pixel
         * @return {cc.$}
         */
        el.translates = function (x, y) {
            this.position.x = x;
            this.position.y = y;
            this.transforms();
            return this
        };

        /**
         * rotate the element
         * @param {Number} x in degrees
         * @return {cc.$}
         */
        el.rotate = function (x) {
            this.rotation = x;
            this.transforms();
            return this
        };

        /**
         * resize the element
         * @param {Number} x
         * @param {Number} y
         * @return {cc.$}
         */
        el.resize = function (x, y) {
            this.scale.x = x;
            this.scale.y = y;
            this.transforms();
            return this
        };

        /**
         * skews the element
         * @param {Number} x in degrees
         * @param {Number} y
         * @return {cc.$}
         */
        el.setSkew = function (x, y) {
            this.skew.x = x;
            this.skew.y = y;
            this.transforms();
            return this
        };
    }
    return el;
};
//getting the prefix and css3 3d support
switch (cc.Browser.type) {
    case "firefox":
        cc.$.pfx = "Moz";
        cc.$.hd = true;
        break;
    case "chrome":
    case "safari":
        cc.$.pfx = "webkit";
        cc.$.hd = true;
        break;
    case "opera":
        cc.$.pfx = "O";
        cc.$.hd = false;
        break;
    case "ie":
        cc.$.pfx = "ms";
        cc.$.hd = false;
}
//cache for prefixed transform
cc.$.trans = cc.$.pfx + "Transform";
//helper function for constructing transform strings
cc.$.translate = (cc.$.hd) ? function (a) {
    return "translate3d(" + a.x + "px, " + a.y + "px, 0) "
} : function (a) {
    return "translate(" + a.x + "px, " + a.y + "px) "
};
cc.$.rotate = (cc.$.hd) ? function (a) {
    return "rotateZ(" + a + "deg) ";
} : function (a) {
    return "rotate(" + a + "deg) ";
};
cc.$.scale = function (a) {
    return "scale(" + a.x + ", " + a.y + ") "
};
cc.$.skew = function (a) {
    return "skewX(" + -a.x + "deg) skewY(" + a.y + "deg)";
};


/**
 * Creates a new element, and adds cc.$ methods
 * @param {String} x name of the element tag to create
 * @return {cc.$}
 */
cc.$new = function (x) {
    return cc.$(document.createElement(x))
};
cc.$.findpos = function (obj) {
    var curleft = 0;
    var curtop = 0;
    do {
        curleft += obj.offsetLeft;
        curtop += obj.offsetTop;
    } while (obj = obj.offsetParent);
    return {x:curleft, y:curtop};
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * copy an new object
 * @function
 * @param {object|Array} obj source object
 * @return {Array|object}
 */
cc.clone = function (obj) {
    var newObj = (obj instanceof Array) ? [] : {};
    for (var key in obj) {
        var copy = obj[key];
        if (copy instanceof Array) {
            newObj[key] = cc.clone(copy);
        } else if (((typeof copy) == "object") && !(copy instanceof cc.Node)
            && !(copy instanceof HTMLElement)) {
            newObj[key] = cc.clone(copy);
        } else {
            newObj[key] = copy;
        }
    }
    return newObj;
};

/**
 * Function added for JS bindings compatibility. Not needed in cocos2d-html5.
 * @function
 * @param {object} jsobj subclass
 * @param {object} klass superclass
 */
cc.associateWithNative = function( jsobj, superclass ) {
};

/**
 * Is show bebug info on web page
 * @constant
 * @type {Boolean}
 */
cc.IS_SHOW_DEBUG_ON_PAGE = cc.IS_SHOW_DEBUG_ON_PAGE || false;

cc._logToWebPage = function (message) {
    var logList = document.getElementById("logInfoList");
    if (!logList) {
        var logDiv = document.createElement("Div");
        logDiv.setAttribute("id", "logInfoDiv");
        cc.canvas.parentNode.appendChild(logDiv);
        logDiv.setAttribute("width", "300");
        logDiv.setAttribute("height", cc.canvas.height);
        logDiv.style.zIndex = "99999";
        logDiv.style.position = "absolute";
        logDiv.style.top = "0";
        logDiv.style.left = "0";

        logList = document.createElement("ul");
        logDiv.appendChild(logList);
        logList.setAttribute("id", "logInfoList");
        logList.style.height = "450px";
        logList.style.color = "#fff";
        logList.style.textAlign = "left";
        logList.style.listStyle = "disc outside";
        logList.style.fontSize = "12px";
        logList.style.fontFamily = "arial";
        logList.style.padding = "0 0 0 20px";
        logList.style.margin = "0";
        logList.style.textShadow = "0 0 3px #000";
        logList.style.zIndex = "99998";
        logList.style.position = "absolute";
        logList.style.top = "0";
        logList.style.left = "0";
        logList.style.overflowY = "hidden";

        var tempDiv = document.createElement("Div");
        logDiv.appendChild(tempDiv);
        tempDiv.style.width = "300px";
        tempDiv.style.height = cc.canvas.height + "px";
        tempDiv.style.opacity = "0.1";
        tempDiv.style.background = "#fff";
        tempDiv.style.border = "1px solid #dfdfdf";
        tempDiv.style.borderRadius = "8px";
    }
    var addMessage = document.createElement("li");
    //var now = new Date();
    //addMessage.innerHTML = now.getHours() + ":" + now.getMinutes() + ":" + now.getSeconds() + " " + now.getMilliseconds() + " " + message;
    addMessage.innerHTML = message;
    if (logList.childNodes.length == 0) {
        logList.appendChild(addMessage);
    } else {
        logList.insertBefore(addMessage, logList.childNodes[0]);
    }
};

/**
 * Output Debug message.
 * @function
 * @param {String} message
 */
cc.log = function (message) {
    if (!cc.IS_SHOW_DEBUG_ON_PAGE) {
        console.log(message);
    } else {
        cc._logToWebPage(message);
    }
};

/**
 * Pop out a message box
 * @param {String} message
 * @function
 */
cc.MessageBox = function (message) {
    console.log(message);
};

// cocos2d debug
if (cc.COCOS2D_DEBUG == 0) {
    cc.log = function () {
    };
    cc.logINFO = function () {
    };
    cc.logERROR = function () {
    };
}
else if (cc.COCOS2D_DEBUG == 1) {
    cc.logINFO = cc.log;
    cc.logERROR = function () {
    };
}
else if (cc.COCOS2D_DEBUG > 1) {
    cc.logINFO = cc.log;
    cc.logERROR = cc.log;
}// COCOS2D_DEBUG

if (cc.COCOS2D_DEBUG) {
    cc.Assert = function (cond, message) {
        if ((typeof console.assert) == "function") {
            console.assert(cond, message);
        } else {
            if (!cond) {
                if (message) {
                    alert(message);
                }
            }
        }
    }
} else {
    cc.Assert = function () {
    };
}

// Enum the language type supportted now
/**
 * English language code
 * @constant
 * @type Number
 */
cc.LANGUAGE_ENGLISH = 0;

/**
 * Chinese language code
 * @constant
 * @type Number
 */
cc.LANGUAGE_CHINESE = 1;

/**
 * French language code
 * @constant
 * @type Number
 */
cc.LANGUAGE_FRENCH = 2;

/**
 * Italian language code
 * @constant
 * @type Number
 */
cc.LANGUAGE_ITALIAN = 3;

/**
 * German language code
 * @constant
 * @type Number
 */
cc.LANGUAGE_GERMAN = 4;

/**
 * Spanish language code
 * @constant
 * @type Number
 */
cc.LANGUAGE_SPANISH = 5;

/**
 * Russian language code
 * @constant
 * @type Number
 */
cc.LANGUAGE_RUSSIAN = 6;
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * time value
 * @Class
 * @extends cc.Class
 */
cc.timeval = cc.Class.extend(/** @lends cc.timeval# */{
    /**
     * seconds
     * @type Number
     */
    tv_sec:0,
    /**
     * microseconds
     * @type Number
     */
    tv_usec:0//
});

/**
 * @namespace
 */
cc.Time = {};

/**
 * get time of day
 * @return {cc.timeval}
 */
cc.Time.gettimeofdayCocos2d = function () {
    var timeval = new cc.timeval();
    var tmp = Date.now();
    timeval.tv_usec = (tmp % 1000) * 1000;
    timeval.tv_sec = Math.floor(tmp / 1000);
    return timeval;
};

/**
 * get system date (alias to Date.now())
 * @return {Date}
 */
cc.Time.now = function (){
    return Date.now();
};

/**
 * timer sub
 * @param {cc.timeval | Number} start start value
 * @param {cc.timeval | Number} end end value
 * @return {cc.timeval | Number}
 */
cc.Time.timersubCocos2d = function (start, end) {
    if (!out || !start || !end) {
        return -1;
    }
    if (start instanceof cc.timeval && end instanceof cc.timeval) {
        var out = new cc.timeval();
        out.tv_sec = end.tv_sec - start.tv_sec;
        out.tv_usec = end.tv_usec - start.tv_usec;
        if (end.tv_usec < start.tv_usec) {
            out.tv_usec += 1000000;
            out.tv_sec--;
        }
        return out;
    }
    else if (!isNaN(start) && !isNaN(end)) {
        return end - start;
    }
};
/*--
 Copyright 2009-2010 by Stefan Rusterholz.
 All rights reserved.
 You can choose between MIT and BSD-3-Clause license. License file will be added later.
 --*/

/**
 * mixin cc.Codec
 */
cc.Codec = {name:'Jacob__Codec'};

/**
 * Unpack a gzipped byte array
 * @param {Array} input Byte array
 * @returns {String} Unpacked byte string
 */
cc.unzip = function () {
    return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, arguments);
};

/**
 * Unpack a gzipped byte string encoded as base64
 * @param {String} input Byte string encoded as base64
 * @returns {String} Unpacked byte string
 */
cc.unzipBase64 = function () {
    var tmpInput = cc.Codec.Base64.decode.apply(cc.Codec.Base64, arguments);
    return   cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, [tmpInput]);
};

/**
 * Unpack a gzipped byte string encoded as base64
 * @param {String} input Byte string encoded as base64
 * @param {Number} bytes Bytes per array item
 * @returns {Array} Unpacked byte array
 */
cc.unzipBase64AsArray = function (input, bytes) {
    bytes = bytes || 1;

    var dec = this.unzipBase64(input),
        ar = [], i, j, len;
    for (i = 0, len = dec.length / bytes; i < len; i++) {
        ar[i] = 0;
        for (j = bytes - 1; j >= 0; --j) {
            ar[i] += dec.charCodeAt((i * bytes) + j) << (j * 8);
        }
    }
    return ar;
};

/**
 * Unpack a gzipped byte array
 * @param {Array} input Byte array
 * @param {Number} bytes Bytes per array item
 * @returns {Array} Unpacked byte array
 */
cc.unzipAsArray = function (input, bytes) {
    bytes = bytes || 1;

    var dec = this.unzip(input),
        ar = [], i, j, len;
    for (i = 0, len = dec.length / bytes; i < len; i++) {
        ar[i] = 0;
        for (j = bytes - 1; j >= 0; --j) {
            ar[i] += dec.charCodeAt((i * bytes) + j) << (j * 8);
        }
    }
    return ar;
};

/**
 * string to array
 * @param {String} input
 * @returns {Array} array
 */
cc.StringToArray = function (input) {
    var tmp = input.split(","), ar = [], i;
    for (i = 0; i < tmp.length; i++) {
        ar.push(parseInt(tmp[i]));
    }
    return ar;
};
/*--
 Copyright 2009-2010 by Stefan Rusterholz.
 All rights reserved.
 You can choose between MIT and BSD-3-Clause license. License file will be added later.
 --*/

/**
 * mixin cc.Codec.Base64
 */
cc.Codec.Base64 = {name:'Jacob__Codec__Base64'};

cc.Codec.Base64._keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

/**
 * <p>
 *    cc.Codec.Base64.decode(input[, unicode=false]) -> String (http://en.wikipedia.org/wiki/Base64).
 * </p>
 * @function
 * @param {String} input The base64 encoded string to decode
 * @return {String} Decodes a base64 encoded String
 * @example
 * //decode string
 * cc.Codec.Base64.decode("U29tZSBTdHJpbmc="); // => "Some String"
 */
cc.Codec.Base64.decode = function Jacob__Codec__Base64__decode(input) {
    var output = [],
        chr1, chr2, chr3,
        enc1, enc2, enc3, enc4,
        i = 0;

    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

    while (i < input.length) {
        enc1 = this._keyStr.indexOf(input.charAt(i++));
        enc2 = this._keyStr.indexOf(input.charAt(i++));
        enc3 = this._keyStr.indexOf(input.charAt(i++));
        enc4 = this._keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        output.push(String.fromCharCode(chr1));

        if (enc3 != 64) {
            output.push(String.fromCharCode(chr2));
        }
        if (enc4 != 64) {
            output.push(String.fromCharCode(chr3));
        }
    }

    output = output.join('');

    return output;
};

/**
 * <p>
 *    Converts an input string encoded in base64 to an array of integers whose<br/>
 *    values represent the decoded string's characters' bytes.
 * </p>
 * @function
 * @param {String} input The String to convert to an array of Integers
 * @param {Number} bytes
 * @return {Array}
 * @example
 * //decode string to array
 * var decodeArr = cc.Codec.Base64.decodeAsArray("U29tZSBTdHJpbmc=");
 */
cc.Codec.Base64.decodeAsArray = function Jacob__Codec__Base64___decodeAsArray(input, bytes) {
    var dec = this.decode(input),
        ar = [], i, j, len;
    for (i = 0, len = dec.length / bytes; i < len; i++) {
        ar[i] = 0;
        for (j = bytes - 1; j >= 0; --j) {
            ar[i] += dec.charCodeAt((i * bytes) + j) << (j * 8);
        }
    }

    return ar;
};
/*--
 Copyright 2009-2010 by Stefan Rusterholz.
 All rights reserved.
 You can choose between MIT and BSD-3-Clause license. License file will be added later.
 --*/

/**
 * See cc.Codec.GZip.gunzip.
 * @param {Array | String} data The bytestream to decompress
 * Constructor
 */
cc.Codec.GZip = function Jacob__GZip(data) {
    this.data = data;

    this.debug = false;
    this.gpflags = undefined;
    this.files = 0;
    this.unzipped = [];
    this.buf32k = new Array(32768);
    this.bIdx = 0;
    this.modeZIP = false;
    this.bytepos = 0;
    this.bb = 1;
    this.bits = 0;
    this.nameBuf = [];
    this.fileout = undefined;
    this.literalTree = new Array(cc.Codec.GZip.LITERALS);
    this.distanceTree = new Array(32);
    this.treepos = 0;
    this.Places = null;
    this.len = 0;
    this.fpos = new Array(17);
    this.fpos[0] = 0;
    this.flens = undefined;
    this.fmax = undefined;
};

/**
 * Unzips the gzipped data of the 'data' argument.
 * @param string  The bytestream to decompress. Either an array of Integers between 0 and 255, or a String.
 * @return {String}
 */
cc.Codec.GZip.gunzip = function (string) {
    if (string.constructor === Array) {
    } else if (string.constructor === String) {
    }
    var gzip = new cc.Codec.GZip(string);
    return gzip.gunzip()[0][0];
};

cc.Codec.GZip.HufNode = function () {
    this.b0 = 0;
    this.b1 = 0;
    this.jump = null;
    this.jumppos = -1;
};

/**
 * @constant
 * @type Number
 */
cc.Codec.GZip.LITERALS = 288;
/**
 * @constant
 * @type Number
 */
cc.Codec.GZip.NAMEMAX = 256;

cc.Codec.GZip.bitReverse = [
    0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
    0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
    0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
    0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
    0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
    0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
    0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
    0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
    0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
    0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
    0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
    0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
    0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
    0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
    0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
    0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff
];
cc.Codec.GZip.cplens = [
    3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
    35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];
cc.Codec.GZip.cplext = [
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
    3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99
];
/* 99==invalid */
cc.Codec.GZip.cpdist = [
    0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d,
    0x0011, 0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1,
    0x0101, 0x0181, 0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01,
    0x1001, 0x1801, 0x2001, 0x3001, 0x4001, 0x6001
];
cc.Codec.GZip.cpdext = [
    0, 0, 0, 0, 1, 1, 2, 2,
    3, 3, 4, 4, 5, 5, 6, 6,
    7, 7, 8, 8, 9, 9, 10, 10,
    11, 11, 12, 12, 13, 13
];
cc.Codec.GZip.border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];


/**
 * gunzip
 * @return {Array}
 */
cc.Codec.GZip.prototype.gunzip = function () {
    this.outputArr = [];

    //convertToByteArray(input);
    //if (this.debug) alert(this.data);

    this.nextFile();
    return this.unzipped;
};

cc.Codec.GZip.prototype.readByte = function () {
    this.bits += 8;
    if (this.bytepos < this.data.length) {
        //return this.data[this.bytepos++]; // Array
        return this.data.charCodeAt(this.bytepos++);
    } else {
        return -1;
    }
};

cc.Codec.GZip.prototype.byteAlign = function () {
    this.bb = 1;
};

cc.Codec.GZip.prototype.readBit = function () {
    var carry;
    this.bits++;
    carry = (this.bb & 1);
    this.bb >>= 1;
    if (this.bb == 0) {
        this.bb = this.readByte();
        carry = (this.bb & 1);
        this.bb = (this.bb >> 1) | 0x80;
    }
    return carry;
};

cc.Codec.GZip.prototype.readBits = function (a) {
    var res = 0,
        i = a;

    while (i--) res = (res << 1) | this.readBit();
    if (a) res = cc.Codec.GZip.bitReverse[res] >> (8 - a);

    return res;
};

cc.Codec.GZip.prototype.flushBuffer = function () {
    this.bIdx = 0;
};

cc.Codec.GZip.prototype.addBuffer = function (a) {
    this.buf32k[this.bIdx++] = a;
    this.outputArr.push(String.fromCharCode(a));
    if (this.bIdx == 0x8000) this.bIdx = 0;
};

cc.Codec.GZip.prototype.IsPat = function () {
    while (1) {
        if (this.fpos[this.len] >= this.fmax)       return -1;
        if (this.flens[this.fpos[this.len]] == this.len) return this.fpos[this.len]++;
        this.fpos[this.len]++;
    }
};

cc.Codec.GZip.prototype.Rec = function () {
    var curplace = this.Places[this.treepos];
    var tmp;
    //if (this.debug) document.write("<br>len:"+this.len+" treepos:"+this.treepos);
    if (this.len == 17) { //war 17
        return -1;
    }
    this.treepos++;
    this.len++;

    tmp = this.IsPat();
    //if (this.debug) document.write("<br>IsPat "+tmp);
    if (tmp >= 0) {
        curplace.b0 = tmp;
        /* leaf cell for 0-bit */
        //if (this.debug) document.write("<br>b0 "+curplace.b0);
    } else {
        /* Not a Leaf cell */
        curplace.b0 = 0x8000;
        //if (this.debug) document.write("<br>b0 "+curplace.b0);
        if (this.Rec()) return -1;
    }
    tmp = this.IsPat();
    if (tmp >= 0) {
        curplace.b1 = tmp;
        /* leaf cell for 1-bit */
        //if (this.debug) document.write("<br>b1 "+curplace.b1);
        curplace.jump = null;
        /* Just for the display routine */
    } else {
        /* Not a Leaf cell */
        curplace.b1 = 0x8000;
        //if (this.debug) document.write("<br>b1 "+curplace.b1);
        curplace.jump = this.Places[this.treepos];
        curplace.jumppos = this.treepos;
        if (this.Rec()) return -1;
    }
    this.len--;
    return 0;
};

cc.Codec.GZip.prototype.CreateTree = function (currentTree, numval, lengths, show) {
    var i;
    /* Create the Huffman decode tree/table */
    //if (this.debug) document.write("currentTree "+currentTree+" numval "+numval+" lengths "+lengths+" show "+show);
    this.Places = currentTree;
    this.treepos = 0;
    this.flens = lengths;
    this.fmax = numval;
    for (i = 0; i < 17; i++) this.fpos[i] = 0;
    this.len = 0;
    if (this.Rec()) {
        //if (this.debug) alert("invalid huffman tree\n");
        return -1;
    }
    // if (this.debug) {
    //   document.write('<br>Tree: '+this.Places.length);
    //   for (var a=0;a<32;a++){
    //     document.write("Places["+a+"].b0="+this.Places[a].b0+"<br>");
    //     document.write("Places["+a+"].b1="+this.Places[a].b1+"<br>");
    //   }
    // }

    return 0;
};

cc.Codec.GZip.prototype.DecodeValue = function (currentTree) {
    var len, i,
        xtreepos = 0,
        X = currentTree[xtreepos],
        b;

    /* decode one symbol of the data */
    while (1) {
        b = this.readBit();
        // if (this.debug) document.write("b="+b);
        if (b) {
            if (!(X.b1 & 0x8000)) {
                // if (this.debug) document.write("ret1");
                return X.b1;
                /* If leaf node, return data */
            }
            X = X.jump;
            len = currentTree.length;
            for (i = 0; i < len; i++) {
                if (currentTree[i] === X) {
                    xtreepos = i;
                    break;
                }
            }
        } else {
            if (!(X.b0 & 0x8000)) {
                // if (this.debug) document.write("ret2");
                return X.b0;
                /* If leaf node, return data */
            }
            xtreepos++;
            X = currentTree[xtreepos];
        }
    }
    // if (this.debug) document.write("ret3");

    return -1;
};

cc.Codec.GZip.prototype.DeflateLoop = function () {
    var last, c, type, i, len;

    do {
        last = this.readBit();
        type = this.readBits(2);

        if (type == 0) {
            var blockLen, cSum;

            // Stored
            this.byteAlign();
            blockLen = this.readByte();
            blockLen |= (this.readByte() << 8);

            cSum = this.readByte();
            cSum |= (this.readByte() << 8);

            if (((blockLen ^ ~cSum) & 0xffff)) {
                document.write("BlockLen checksum mismatch\n"); // FIXME: use throw
            }
            while (blockLen--) {
                c = this.readByte();
                this.addBuffer(c);
            }
        } else if (type == 1) {
            var j;

            /* Fixed Huffman tables -- fixed decode routine */
            while (1) {
                /*
                 256    0000000        0
                 :   :     :
                 279    0010111        23
                 0   00110000    48
                 :    :      :
                 143    10111111    191
                 280 11000000    192
                 :    :      :
                 287 11000111    199
                 144    110010000    400
                 :    :       :
                 255    111111111    511

                 Note the bit order!
                 */
                j = (cc.Codec.GZip.bitReverse[this.readBits(7)] >> 1);
                if (j > 23) {
                    j = (j << 1) | this.readBit();
                    /* 48..255 */

                    if (j > 199) {              /* 200..255 */
                        j -= 128;
                        /*  72..127 */
                        j = (j << 1) | this.readBit();
                        /* 144..255 << */
                    } else {                    /*  48..199 */
                        j -= 48;
                        /*   0..151 */
                        if (j > 143) {
                            j = j + 136;
                            /* 280..287 << */
                            /*   0..143 << */
                        }
                    }
                } else {                      /*   0..23 */
                    j += 256;
                    /* 256..279 << */
                }
                if (j < 256) {
                    this.addBuffer(j);
                } else if (j == 256) {
                    /* EOF */
                    break; // FIXME: make this the loop-condition
                } else {
                    var len, dist;

                    j -= 256 + 1;
                    /* bytes + EOF */
                    len = this.readBits(cc.Codec.GZip.cplext[j]) + cc.Codec.GZip.cplens[j];

                    j = cc.Codec.GZip.bitReverse[this.readBits(5)] >> 3;
                    if (cc.Codec.GZip.cpdext[j] > 8) {
                        dist = this.readBits(8);
                        dist |= (this.readBits(cc.Codec.GZip.cpdext[j] - 8) << 8);
                    } else {
                        dist = this.readBits(cc.Codec.GZip.cpdext[j]);
                    }
                    dist += cc.Codec.GZip.cpdist[j];

                    for (j = 0; j < len; j++) {
                        var c = this.buf32k[(this.bIdx - dist) & 0x7fff];
                        this.addBuffer(c);
                    }
                }
            } // while

        } else if (type == 2) {
            var j, n, literalCodes, distCodes, lenCodes;
            var ll = new Array(288 + 32);    // "static" just to preserve stack

            // Dynamic Huffman tables

            literalCodes = 257 + this.readBits(5);
            distCodes = 1 + this.readBits(5);
            lenCodes = 4 + this.readBits(4);
            for (j = 0; j < 19; j++) {
                ll[j] = 0;
            }

            // Get the decode tree code lengths

            for (j = 0; j < lenCodes; j++) {
                ll[cc.Codec.GZip.border[j]] = this.readBits(3);
            }
            len = this.distanceTree.length;
            for (i = 0; i < len; i++) this.distanceTree[i] = new cc.Codec.GZip.HufNode();
            if (this.CreateTree(this.distanceTree, 19, ll, 0)) {
                this.flushBuffer();
                return 1;
            }
            // if (this.debug) {
            //   document.write("<br>distanceTree");
            //   for(var a=0;a<this.distanceTree.length;a++){
            //     document.write("<br>"+this.distanceTree[a].b0+" "+this.distanceTree[a].b1+" "+this.distanceTree[a].jump+" "+this.distanceTree[a].jumppos);
            //   }
            // }

            //read in literal and distance code lengths
            n = literalCodes + distCodes;
            i = 0;
            var z = -1;
            // if (this.debug) document.write("<br>n="+n+" bits: "+this.bits+"<br>");
            while (i < n) {
                z++;
                j = this.DecodeValue(this.distanceTree);
                // if (this.debug) document.write("<br>"+z+" i:"+i+" decode: "+j+"    bits "+this.bits+"<br>");
                if (j < 16) {    // length of code in bits (0..15)
                    ll[i++] = j;
                } else if (j == 16) {    // repeat last length 3 to 6 times
                    var l;
                    j = 3 + this.readBits(2);
                    if (i + j > n) {
                        this.flushBuffer();
                        return 1;
                    }
                    l = i ? ll[i - 1] : 0;
                    while (j--) {
                        ll[i++] = l;
                    }
                } else {
                    if (j == 17) {        // 3 to 10 zero length codes
                        j = 3 + this.readBits(3);
                    } else {        // j == 18: 11 to 138 zero length codes
                        j = 11 + this.readBits(7);
                    }
                    if (i + j > n) {
                        this.flushBuffer();
                        return 1;
                    }
                    while (j--) {
                        ll[i++] = 0;
                    }
                }
            } // while

            // Can overwrite tree decode tree as it is not used anymore
            len = this.literalTree.length;
            for (i = 0; i < len; i++)
                this.literalTree[i] = new cc.Codec.GZip.HufNode();
            if (this.CreateTree(this.literalTree, literalCodes, ll, 0)) {
                this.flushBuffer();
                return 1;
            }
            len = this.literalTree.length;
            for (i = 0; i < len; i++) this.distanceTree[i] = new cc.Codec.GZip.HufNode();
            var ll2 = new Array();
            for (i = literalCodes; i < ll.length; i++) ll2[i - literalCodes] = ll[i];
            if (this.CreateTree(this.distanceTree, distCodes, ll2, 0)) {
                this.flushBuffer();
                return 1;
            }
            // if (this.debug) document.write("<br>literalTree");
            while (1) {
                j = this.DecodeValue(this.literalTree);
                if (j >= 256) {        // In C64: if carry set
                    var len, dist;
                    j -= 256;
                    if (j == 0) {
                        // EOF
                        break;
                    }
                    j--;
                    len = this.readBits(cc.Codec.GZip.cplext[j]) + cc.Codec.GZip.cplens[j];

                    j = this.DecodeValue(this.distanceTree);
                    if (cc.Codec.GZip.cpdext[j] > 8) {
                        dist = this.readBits(8);
                        dist |= (this.readBits(cc.Codec.GZip.cpdext[j] - 8) << 8);
                    } else {
                        dist = this.readBits(cc.Codec.GZip.cpdext[j]);
                    }
                    dist += cc.Codec.GZip.cpdist[j];
                    while (len--) {
                        var c = this.buf32k[(this.bIdx - dist) & 0x7fff];
                        this.addBuffer(c);
                    }
                } else {
                    this.addBuffer(j);
                }
            } // while
        }
    } while (!last);
    this.flushBuffer();

    this.byteAlign();
    return 0;
};

cc.Codec.GZip.prototype.unzipFile = function (name) {
    var i;
    this.gunzip();
    for (i = 0; i < this.unzipped.length; i++) {
        if (this.unzipped[i][1] == name) {
            return this.unzipped[i][0];
        }
    }
};

cc.Codec.GZip.prototype.nextFile = function () {
    // if (this.debug) alert("NEXTFILE");

    this.outputArr = [];
    this.modeZIP = false;

    var tmp = [];
    tmp[0] = this.readByte();
    tmp[1] = this.readByte();
    // if (this.debug) alert("type: "+tmp[0]+" "+tmp[1]);

    if (tmp[0] == 0x78 && tmp[1] == 0xda) { //GZIP
        // if (this.debug) alert("GEONExT-GZIP");
        this.DeflateLoop();
        // if (this.debug) alert(this.outputArr.join(''));
        this.unzipped[this.files] = [this.outputArr.join(''), "geonext.gxt"];
        this.files++;
    }
    if (tmp[0] == 0x1f && tmp[1] == 0x8b) { //GZIP
        // if (this.debug) alert("GZIP");
        this.skipdir();
        // if (this.debug) alert(this.outputArr.join(''));
        this.unzipped[this.files] = [this.outputArr.join(''), "file"];
        this.files++;
    }
    if (tmp[0] == 0x50 && tmp[1] == 0x4b) { //ZIP
        this.modeZIP = true;
        tmp[2] = this.readByte();
        tmp[3] = this.readByte();
        if (tmp[2] == 0x03 && tmp[3] == 0x04) {
            //MODE_ZIP
            tmp[0] = this.readByte();
            tmp[1] = this.readByte();
            // if (this.debug) alert("ZIP-Version: "+tmp[1]+" "+tmp[0]/10+"."+tmp[0]%10);

            this.gpflags = this.readByte();
            this.gpflags |= (this.readByte() << 8);
            // if (this.debug) alert("gpflags: "+this.gpflags);

            var method = this.readByte();
            method |= (this.readByte() << 8);
            // if (this.debug) alert("method: "+method);

            this.readByte();
            this.readByte();
            this.readByte();
            this.readByte();

//       var crc = this.readByte();
//       crc |= (this.readByte()<<8);
//       crc |= (this.readByte()<<16);
//       crc |= (this.readByte()<<24);

            var compSize = this.readByte();
            compSize |= (this.readByte() << 8);
            compSize |= (this.readByte() << 16);
            compSize |= (this.readByte() << 24);

            var size = this.readByte();
            size |= (this.readByte() << 8);
            size |= (this.readByte() << 16);
            size |= (this.readByte() << 24);

            // if (this.debug) alert("local CRC: "+crc+"\nlocal Size: "+size+"\nlocal CompSize: "+compSize);

            var filelen = this.readByte();
            filelen |= (this.readByte() << 8);

            var extralen = this.readByte();
            extralen |= (this.readByte() << 8);

            // if (this.debug) alert("filelen "+filelen);
            i = 0;
            this.nameBuf = [];
            while (filelen--) {
                var c = this.readByte();
                if (c == "/" | c == ":") {
                    i = 0;
                } else if (i < cc.Codec.GZip.NAMEMAX - 1) {
                    this.nameBuf[i++] = String.fromCharCode(c);
                }
            }
            // if (this.debug) alert("nameBuf: "+this.nameBuf);

            if (!this.fileout) this.fileout = this.nameBuf;

            var i = 0;
            while (i < extralen) {
                c = this.readByte();
                i++;
            }

            // if (size = 0 && this.fileOut.charAt(this.fileout.length-1)=="/"){
            //   //skipdir
            //   // if (this.debug) alert("skipdir");
            // }
            if (method == 8) {
                this.DeflateLoop();
                // if (this.debug) alert(this.outputArr.join(''));
                this.unzipped[this.files] = [this.outputArr.join(''), this.nameBuf.join('')];
                this.files++;
            }
            this.skipdir();
        }
    }
};

cc.Codec.GZip.prototype.skipdir = function () {
    var tmp = [];
    var compSize, size, os, i, c;

    if ((this.gpflags & 8)) {
        tmp[0] = this.readByte();
        tmp[1] = this.readByte();
        tmp[2] = this.readByte();
        tmp[3] = this.readByte();

//     if (tmp[0] == 0x50 && tmp[1] == 0x4b && tmp[2] == 0x07 && tmp[3] == 0x08) {
//       crc = this.readByte();
//       crc |= (this.readByte()<<8);
//       crc |= (this.readByte()<<16);
//       crc |= (this.readByte()<<24);
//     } else {
//       crc = tmp[0] | (tmp[1]<<8) | (tmp[2]<<16) | (tmp[3]<<24);
//     }

        compSize = this.readByte();
        compSize |= (this.readByte() << 8);
        compSize |= (this.readByte() << 16);
        compSize |= (this.readByte() << 24);

        size = this.readByte();
        size |= (this.readByte() << 8);
        size |= (this.readByte() << 16);
        size |= (this.readByte() << 24);
    }

    if (this.modeZIP) this.nextFile();

    tmp[0] = this.readByte();
    if (tmp[0] != 8) {
        // if (this.debug) alert("Unknown compression method!");
        return 0;
    }

    this.gpflags = this.readByte();
    // if (this.debug && (this.gpflags & ~(0x1f))) alert("Unknown flags set!");

    this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();

    this.readByte();
    os = this.readByte();

    if ((this.gpflags & 4)) {
        tmp[0] = this.readByte();
        tmp[2] = this.readByte();
        this.len = tmp[0] + 256 * tmp[1];
        // if (this.debug) alert("Extra field size: "+this.len);
        for (i = 0; i < this.len; i++)
            this.readByte();
    }

    if ((this.gpflags & 8)) {
        i = 0;
        this.nameBuf = [];
        while (c = this.readByte()) {
            if (c == "7" || c == ":")
                i = 0;
            if (i < cc.Codec.GZip.NAMEMAX - 1)
                this.nameBuf[i++] = c;
        }
        //this.nameBuf[i] = "\0";
        // if (this.debug) alert("original file name: "+this.nameBuf);
    }

    if ((this.gpflags & 16)) {
        while (c = this.readByte()) { // FIXME: looks like they read to the end of the stream, should be doable more efficiently
            //FILE COMMENT
        }
    }

    if ((this.gpflags & 2)) {
        this.readByte();
        this.readByte();
    }

    this.DeflateLoop();

//   crc = this.readByte();
//   crc |= (this.readByte()<<8);
//   crc |= (this.readByte()<<16);
//   crc |= (this.readByte()<<24);

    size = this.readByte();
    size |= (this.readByte() << 8);
    size |= (this.readByte() << 16);
    size |= (this.readByte() << 24);

    if (this.modeZIP) this.nextFile();
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * PI is the ratio of a circle's circumference to its diameter.
 * @constant
 * @type Number
 */
cc.PI = Math.PI;

/**
 * @constant
 * @type Number
 */
cc.FLT_MAX = parseFloat('3.402823466e+38F');

/**
 * @constant
 * @type Number
 */
cc.RAD = cc.PI / 180;

/**
 * @constant
 * @type Number
 */
cc.DEG = 180 / cc.PI;

/**
 * maximum unsigned int value
 * @constant
 * @type Number
 */
cc.UINT_MAX = 0xffffffff;

/**
 * <p>
 * simple macro that swaps 2 variables<br/>
 *  modified from c++ macro, you need to pass in the x and y variables names in string, <br/>
 *  and then a reference to the whole object as third variable
 * </p>
 * @param x
 * @param y
 * @param ref
 * @function
 * @deprecated
 */
cc.SWAP = function (x, y, ref) {
    if ((typeof ref) == 'object' && (typeof ref.x) != 'undefined' && (typeof ref.y) != 'undefined') {
        var tmp = ref[x];
        ref[x] = ref[y];
        ref[y] = tmp;
    } else {
        cc.Assert(false, "CC_SWAP is being modified from original macro, please check usage");
    }
};

/**
 * returns a random float between -1 and 1
 * @return {Number}
 * @function
 */
cc.RANDOM_MINUS1_1 = function () {
    return (Math.random() - 0.5) * 2;
};

/**
 * returns a random float between 0 and 1
 * @return {Number}
 * @function
 */
cc.RANDOM_0_1 = function () {
    return Math.random();
};

/**
 * converts degrees to radians
 * @param {Number} angle
 * @return {Number}
 * @function
 */
cc.DEGREES_TO_RADIANS = function (angle) {
    return angle * cc.RAD;
};

/**
 * converts radians to degrees
 * @param {Number} angle
 * @return {Number}
 * @function
 */
cc.RADIANS_TO_DEGREES = function (angle) {
    return angle * cc.DEG;
};

/**
 * @constant
 * @type Number
 */
cc.REPEAT_FOREVER = Number.MAX_VALUE - 1;

/**
 * default gl blend src function. Compatible with premultiplied alpha images.
 * @constant
 * @type Number
 */
cc.BLEND_SRC = cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA ? 1 : 0x0302;

/**
 * default gl blend dst function. Compatible with premultiplied alpha images.
 * @constant
 * @type Number
 */
cc.BLEND_DST = 0x0303;

/**
 * Helpful macro that setups the GL server state, the correct GL program and sets the Model View Projection matrix
 * @param {cc.Node} node setup node
 * @function
 */
cc.NODE_DRAW_SETUP = function (node) {
    ccGLEnable(node._glServerState);
    cc.Assert(node.getShaderProgram(), "No shader program set for this node");
    {
        node.getShaderProgram().use();
        node.getShaderProgram().setUniformForModelViewProjectionMatrix();
    }
};

/**
 * <p>
 *     GL states that are enabled:<br/>
 *       - GL_TEXTURE_2D<br/>
 *       - GL_VERTEX_ARRAY<br/>
 *       - GL_TEXTURE_COORD_ARRAY<br/>
 *       - GL_COLOR_ARRAY<br/>
 * </p>
 * @function
 */
cc.ENABLE_DEFAULT_GL_STATES = function () {
    //TODO OPENGL STUFF
    /*
     glEnableClientState(GL_VERTEX_ARRAY);
     glEnableClientState(GL_COLOR_ARRAY);
     glEnableClientState(GL_TEXTURE_COORD_ARRAY);
     glEnable(GL_TEXTURE_2D);*/
};

/**
 * <p>
 *   Disable default GL states:<br/>
 *     - GL_TEXTURE_2D<br/>
 *     - GL_TEXTURE_COORD_ARRAY<br/>
 *     - GL_COLOR_ARRAY<br/>
 * </p>
 * @function
 */
cc.DISABLE_DEFAULT_GL_STATES = function () {
    //TODO OPENGL
    /*
     glDisable(GL_TEXTURE_2D);
     glDisableClientState(GL_COLOR_ARRAY);
     glDisableClientState(GL_TEXTURE_COORD_ARRAY);
     glDisableClientState(GL_VERTEX_ARRAY);
     */
};

/**
 * <p>
 *  Increments the GL Draws counts by one.<br/>
 *  The number of calls per frame are displayed on the screen when the CCDirector's stats are enabled.<br/>
 * </p>
 * @param {Number} addNumber
 * @function
 */
cc.INCREMENT_GL_DRAWS = function (addNumber) {
    cc.g_NumberOfDraws += addNumber;
};

/**
 * @constant
 * @type Number
 */
cc.FLT_EPSILON = 0.0000001192092896;

/**
 * <p>
 *     On Mac it returns 1;<br/>
 *     On iPhone it returns 2 if RetinaDisplay is On. Otherwise it returns 1
 * </p>
 * @function
 */
cc.CONTENT_SCALE_FACTOR = cc.IS_RETINA_DISPLAY_SUPPORTED ? function () {
    return cc.Director.getInstance().getContentScaleFactor();
} : function () {
    return 1;
};

/**
 * Converts a rect in points to pixels
 * @param {cc.Point} points
 * @return {cc.Point}
 * @function
 */
cc.POINT_POINTS_TO_PIXELS = function (points) {
    return cc.p(points.x * cc.CONTENT_SCALE_FACTOR(), points.y * cc.CONTENT_SCALE_FACTOR())
};

/**
 * Converts a rect in points to pixels
 * @param {cc.Size} sizeInPoints
 * @return {cc.Size}
 * @function
 */
cc.SIZE_POINTS_TO_PIXELS = function (sizeInPoints) {
    return cc.size(sizeInPoints.width * cc.CONTENT_SCALE_FACTOR(), sizeInPoints.height * cc.CONTENT_SCALE_FACTOR());
};

/**
 * Converts a rect in pixels to points
 * @param {cc.Size} sizeInPixels
 * @return {cc.Size}
 * @function
 */
cc.SIZE_PIXELS_TO_POINTS = function (sizeInPixels) {
    return cc.size(sizeInPixels.width / cc.CONTENT_SCALE_FACTOR(), sizeInPixels.height / cc.CONTENT_SCALE_FACTOR());
};

/**
 * Converts a rect in pixels to points
 * @param pixels
 * @function
 */
cc.POINT_PIXELS_TO_POINTS = function (pixels) {
    return cc.p(pixels.x / cc.CONTENT_SCALE_FACTOR(), pixels.y / cc.CONTENT_SCALE_FACTOR());
};


/**
 * Converts a rect in pixels to points
 * @param {cc.Rect} pixel
 * @function
 */
cc.RECT_PIXELS_TO_POINTS = cc.IS_RETINA_DISPLAY_SUPPORTED ? function (pixel) {
    return cc.rect(pixel.origin.x / cc.CONTENT_SCALE_FACTOR(), pixel.origin.y / cc.CONTENT_SCALE_FACTOR(),
        pixel.size.width / cc.CONTENT_SCALE_FACTOR(), pixel.size.height / cc.CONTENT_SCALE_FACTOR());
} : function (p) {
    return p;
};

/**
 * Converts a rect in points to pixels
 * @param {cc.Rect} point
 * @function
 */
cc.RECT_POINTS_TO_PIXELS = cc.IS_RETINA_DISPLAY_SUPPORTED ? function (point) {
    return cc.rect(point.origin.x * cc.CONTENT_SCALE_FACTOR(), point.origin.y * cc.CONTENT_SCALE_FACTOR(),
        point.size.width * cc.CONTENT_SCALE_FACTOR(), point.size.height * cc.CONTENT_SCALE_FACTOR());
} : function (p) {
    return p;
};



/**
 * WebGL constants
 * @type {object}
 */
var gl = gl || {};

/**
 * @constant
 * @type Number
 */
gl.NEAREST                      = 0x2600;

/**
 * @constant
 * @type Number
 */
gl.LINEAR                       = 0x2601;
/**
 * @constant
 * @type Number
 */
gl.REPEAT                       = 0x2901;
/**
 * @constant
 * @type Number
 */
gl.CLAMP_TO_EDGE                = 0x812F;
/**
 * @constant
 * @type Number
 */
gl.CLAMP_TO_BORDER              = 0x812D;
/**
 * @constant
 * @type Number
 */
gl.LINEAR_MIPMAP_NEAREST        = 0x2701;
/**
 * @constant
 * @type Number
 */
gl.NEAREST_MIPMAP_NEAREST       = 0x2700;
/**
 * @constant
 * @type Number
 */
gl.ZERO                         = 0;
/**
 * @constant
 * @type Number
 */
gl.ONE                          = 1;
/**
 * @constant
 * @type Number
 */
gl.SRC_COLOR                    = 0x0300;
/**
 * @constant
 * @type Number
 */
gl.ONE_MINUS_SRC_COLOR          = 0x0301;
/**
 * @constant
 * @type Number
 */
gl.SRC_ALPHA                    = 0x0302;
/**
 * @constant
 * @type Number
 */
gl.ONE_MINUS_SRC_ALPHA          = 0x0303;
/**
 * @constant
 * @type Number
 */
gl.DST_ALPHA                    = 0x0304;
/**
 * @constant
 * @type Number
 */
gl.ONE_MINUS_DST_ALPHA          = 0x0305;
/**
 * @constant
 * @type Number
 */
gl.DST_COLOR                    = 0x0306;
/**
 * @constant
 * @type Number
 */
gl.ONE_MINUS_DST_COLOR          = 0x0307;
/**
 * @constant
 * @type Number
 */
gl.SRC_ALPHA_SATURATE           = 0x0308;

/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * @constant
 * @type Number
 */
cc.SAX_NONE = 0;

/**
 * @constant
 * @type Number
 */
cc.SAX_KEY = 1;

/**
 * @constant
 * @type Number
 */
cc.SAX_DICT = 2;

/**
 * @constant
 * @type Number
 */
cc.SAX_INT = 3;

/**
 * @constant
 * @type Number
 */
cc.SAX_REAL = 4;

/**
 * @constant
 * @type Number
 */
cc.SAX_STRING = 5;

/**
 * @constant
 * @type Number
 */
cc.SAX_ARRAY = 6;

/**
 * @namespace
 */
cc.FileUtils = cc.Class.extend({
    /**
     * Get resource file data
     * @function
     * @param {String} fileName The resource file name which contain the path
     * @param {Number} mode mode The read mode of the file
     * @param {Number} size If get the file data succeed the it will be the data size,or it will be 0
     * @warning If you get the file data succeed,you must delete it after used.
     * @deprecated
     */

    getFileData:function (fileName, mode, size) {
    },

    /**
     * Get resource file data from zip file
     * @function
     * @param {String} pszZipFilePath
     * @param {String} fileName fileName The resource file name which contain the relative path of zip file
     * @param {Number} size size If get the file data succeed the it will be the data size,or it will be 0
     * @warning If you get the file data succeed,you must delete it after used.
     * @deprecated
     */
    getFileDataFromZip:function (pszZipFilePath, fileName, size) {
    },

    /**
     * removes the HD suffix from a path
     * @function
     * @param {String} path
     * @deprecated
     */
    removeSuffixFromFile:function (path) {
    },

//////////////////////////////////////////////////////////////////////////
// Notification support when getFileData from invalid file path.
//////////////////////////////////////////////////////////////////////////
    /**
     * Notification support when getFileData from invalid file path.
     * @function
     * @type {Boolean}
     */
    popupNotify:true,

    /**
     * Generate the absolute path of the file.
     * @function
     * @param {String} pszRelativePath
     * @return {String} The absolute path of the file.
     * @warning We only add the ResourcePath before the relative path of the file. <br/>
     * If you have not set the ResourcePath,the function add "/NEWPLUS/TDA_DATA/UserData/" as default.<br/>
     * You can set ResourcePath by function void setResourcePath(const char *resourcePath);
     */
    fullPathFromRelativePath:function (pszRelativePath) {
        return pszRelativePath;
    },

    /**
     * Generate the relative path of the file.
     * @function
     * @param {String} filename
     * @param {String} relativeFile
     * @return {String}
     */
    fullPathFromRelativeFile:function (filename, relativeFile) {
        var tmpPath;
        if (filename) {
            tmpPath = relativeFile.substring(0, relativeFile.lastIndexOf("/") + 1);
            return tmpPath + filename;
        }
        else {
            tmpPath = relativeFile.substring(0, relativeFile.lastIndexOf("."));
            tmpPath = tmpPath + ".png";
            return tmpPath;
        }
    },

    /**
     * Set the ResourcePath,we will find resource in this path
     * @function
     * @param {String} resourcePath The absolute resource path
     * @warning Don't call this function in android and iOS, it has not effect.<br/>
     * In android, if you want to read file other than apk, you shoud use invoke getFileData(), and pass the<br/>
     * absolute path.
     * @deprecated
     */
    setResourcePath:function (resourcePath) {
    },

    /**
     * Generate an Dictionary of object by file
     * @function
     * @param fileName The file name of *.plist file
     * @return {object} The Dictionary of object generated from the file
     */
    dictionaryWithContentsOfFile:function (fileName) {
        var parser = cc.SAXParser.shareParser();
        this.rootDict = parser.parse(fileName);
        return this.rootDict;
    },

    /**
     * The same meaning as dictionaryWithContentsOfFile(), but it doesn't call autorelease, so the invoker should call release().
     * @function
     * @param {String} fileName
     * @return {object} The Dictionary of object generated from the file
     */
    dictionaryWithContentsOfFileThreadSafe:function (fileName) {
        var tMaker = new cc.DictMaker();
        return tMaker.dictionaryWithContentsOfFile(fileName);
    },

    /**
     * Get the writeable path
     * @function
     * @return  The path that can write/read file
     * @deprecated
     */
    getWriteablePath:function () {
    },

    /**
     * Set whether pop-up a message box when the image load failed
     * @function
     * @param {Boolean} notify
     */
    setPopupNotify:function (notify) {
        cc.popupNotify = notify;
    },

    /**
     * Get whether pop-up a message box when the image load failed
     * @function
     * @return {Boolean}
     */
    isPopupNotify:function () {
        return cc.popupNotify;
    }
});

cc.s_SharedFileUtils = null;
cc.FileUtils.getInstance =  function(){
    if(cc.s_SharedFileUtils == null){
        cc.s_SharedFileUtils =  new cc.FileUtils();

    }
    return cc.s_SharedFileUtils;
};

/**
 * plist Dictionary Maker
 * @class
 * @extends cc.Class
 * @example
 * //create a DictMaker
 * var tMaker = new cc.DictMaker();
 * tMaker.dictionaryWithContentsOfFile(fileName);
 */
cc.DictMaker = cc.Class.extend(/** @lends cc.DictMaker# */{
    rootDict:[],
    /**
     * Generate dictionary with contents of file
     * @param {String} fileName
     * @return {Array}
     */
    dictionaryWithContentsOfFile:function (fileName) {
        var parser = cc.SAXParser.shareParser();
        this.rootDict = parser.parse(fileName);
        return this.rootDict;
    }
});
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * RGB color composed of bytes 3 bytes
 * @Class
 * @Construct
 * @param {Number | cc.Color3B} r1 red value (0 to 255) or destination color of new color
 * @param {Number} g1 green value (0 to 255)
 * @param {Number} b1 blue value (0 to 255)
 * @example
 * //create an empty color
 * var color1 = new cc.Color3B();
 *
 * //create a red color
 * var redColor = new cc.Color3B(255,0,0);
 *
 * //create a new color with color
 * var newColor = new cc.Color3B(redColor);
 */
cc.Color3B = function (r1, g1, b1) {
    switch (arguments.length) {
        case 0:
            this.r = 0;
            this.g = 0;
            this.b = 0;
        case 1:
            if (r1 && r1 instanceof cc.Color3B) {
                this.r = r1.r || 0;
                this.g = r1.g || 0;
                this.b = r1.b || 0;
            } else {
                this.r = 0;
                this.g = 0;
                this.b = 0;
            }
            break;
        case 3:
            this.r = r1 || 0;
            this.g = g1 || 0;
            this.b = b1 || 0;
            break;
        default:
            throw "unknown argument type";
            break;
    }
};

/**
 * helper macro that creates an ccColor3B type
 * @function
 * @param {Number} r red value (0 to 255)
 * @param {Number} g green value (0 to 255)
 * @param {Number} b blue value (0 to 255)
 * @return {Number,Number,Number}
 */
cc.c3b = function (r, g, b) {
    return new cc.Color3B(r, g, b);
};

// compatibility
cc.c3 = cc.c3b;


//ccColor3B predefined colors
/**
 *  White color (255,255,255)
 * @constant
 * @type {Number,Number,Number}
 */
cc.white = function () {
    return new cc.Color3B(255, 255, 255);
};

/**
 *  Yellow color (255,255,0)
 * @constant
 * @type {Number,Number,Number}
 */
cc.yellow = function () {
    return new cc.Color3B(255, 255, 0);
};

/**
 *  Blue color (0,0,255)
 * @constant
 * @type {Number,Number,Number}
 */
cc.blue = function () {
    return new cc.Color3B(0, 0, 255);
};

/**
 *  Green Color (0,255,0)
 * @constant
 * @type {Number,Number,Number}
 */
cc.green = function () {
    return new cc.Color3B(0, 255, 0);
};

/**
 *  Red Color (255,0,0,)
 * @constant
 * @type {Number,Number,Number}
 */
cc.red = function () {
    return new cc.Color3B(255, 0, 0);
};

/**
 *  Magenta Color (255,0,255)
 * @constant
 * @type {Number,Number,Number}
 */
cc.magenta = function () {
    return new cc.Color3B(255, 0, 255);
};

/**
 *  Black Color (0,0,0)
 * @constant
 * @type {Number,Number,Number}
 */
cc.black = function () {
    return new cc.Color3B(0, 0, 0);
};

/**
 *  Orange Color (255,127,0)
 * @constant
 * @type {Number,Number,Number}
 */
cc.orange = function () {
    return new cc.Color3B(255, 127, 0);
};

/**
 *  Gray Color (166,166,166)
 * @constant
 * @type {Number,Number,Number}
 */
cc.gray = function () {
    return new cc.Color3B(166, 166, 166);
}

/**
 * RGBA color composed of 4 bytes
 * @Class
 * @Construct
 * @param {Number} r1 red value (0 to 255)
 * @param {Number} g1 green value (0 to 255)
 * @param {Number} b1 blue value (0 to 255)
 * @param {Number} a1 Alpha value (0 to 255)
 * @example
 * //create a red color
 * var redColor = new cc.Color4B(255,0,0,255);
 */
cc.Color4B = function (r1, g1, b1, a1) {
    this.r = r1;
    this.g = g1;
    this.b = b1;
    this.a = a1;
};

/**
 * helper macro that creates an ccColor4B type
 * @function
 * @param {Number} r red value (0 to 255)
 * @param {Number} g green value (0 to 255)
 * @param {Number} b blue value (0 to 255)
 * @param {Number} a Alpha value (0 to 255)
 * @return {Number,Number,Number,Number}
 */
cc.c4b = function (r, g, b, a) {
    return new cc.Color4B(r, g, b, a);
};

// backwards compatibility
cc.c4 = cc.c4b;

/**
 * RGBA color composed of 4 floats
 * @Class
 * @Construct
 * @param {Number} r1 red value (0 to 1)
 * @param {Number} g1 green value (0 to 1)
 * @param {Number} b1 blue value (0 to 1)
 * @param {Number} a1 Alpha value (0 to 1)
 * @example
 * //create a red color
 * var redColor = new cc.Color4F(1,0,0,1);
 */
cc.Color4F = function (r1, g1, b1, a1) {
    this.r = r1;
    this.g = g1;
    this.b = b1;
    this.a = a1;
};


/**
 * helper macro that creates an ccColor4F type
 * @Class
 * @Construct
 * @param {Number} r red value (0 to 1)
 * @param {Number} g green value (0 to 1)
 * @param {Number} b blue value (0 to 1)
 * @param {Number} a Alpha value (0 to 1)
 * @example
 * //create a red color
 * var redColor = cc.c4f(1,0,0,1);
 */
cc.c4f = function (r, g, b, a) {
    return new cc.Color4F(r, g, b, a);
};

/**
 * Returns a cc.Color4F from a cc.Color3B. Alpha will be 1.
 * @function
 * @param {cc.Color3B} c color
 * @return {cc.Color4F}
 */
cc.c4FFromccc3B = function (c) {
    return new cc.Color4F(c.r / 255.0, c.g / 255.0, c.b / 255.0, 1.0);
};

/**
 * Returns a cc.Color4F from a cc.Color4B.
 * @function
 * @param {cc.Color4B} c Color
 * @return {cc.Color4F}
 */
cc.c4FFromccc4B = function (c) {
    return new cc.Color4F(c.r / 255.0, c.g / 255.0, c.b / 255.0, c.a / 255.0);
};

/**
 * returns YES if both cc.Color4F are equal. Otherwise it returns NO.
 * @param {cc.Color4F} a color1
 * @param {cc.Color4F} b color2
 * @return {Boolean}
 */
cc.c4FEqual = function (a, b) {
    return a.r == b.r && a.g == b.g && a.b == b.b && a.a == b.a;
};

/**
 * A vertex composed of 2 floats: x, y
 * @Class
 * @Construct
 * @param {Number} x1
 * @param {Number} y1
 */
cc.Vertex2F = function (x1, y1) {
    this.x = x1 || 0;
    this.y = y1 || 0;
};

/**
 * helper macro that creates an Vertex2F type
 * @function
 * @param {Number} x
 * @param {Number} y
 * @return {cc.Vertex2F}
 */
cc.Vertex2 = function (x, y) {
    return new cc.Vertex2F(x, y);
};

/**
 * A vertex composed of 3 floats: x, y, z
 * @Class
 * @Construct
 * @param {Number} x1
 * @param {Number} y1
 * @param {Number} z1
 */
cc.Vertex3F = function (x1, y1, z1) {
    this.x = x1 || 0;
    this.y = y1 || 0;
    this.z = z1 || 0;
};

/**
 * helper macro that creates an Vertex3F type
 * @function
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @return {cc.Vertex3F}
 */
cc.vertex3 = function (x, y, z) {
    return new cc.Vertex3F(x, y, z);
};

/**
 * A texcoord composed of 2 floats: u, y
 * @Class
 * @Construct
 * @param {Number} u1
 * @param {Number} v1
 */
cc.Tex2F = function (u1, v1) {
    this.u = u1 || 0;
    this.v = v1 || 0;
};

/**
 * helper macro that creates an Tex2F type
 * @function
 * @param {Number} u
 * @param {Number} v
 * @return {cc.Tex2F}
 */
cc.tex2 = function (u, v) {
    return new cc.Tex2F(u, v);
};

/**
 * Point Sprite component
 * @Class
 * @Construct
 * @param {cc.Vertex2F} pos1
 * @param {cc.Color4B} color1
 * @param {Number} size1
 */
cc.PointSprite = function (pos1, color1, size1) {
    this.pos = pos1 || new cc.Vertex2F(0, 0);
    this.color = color1 || new cc.Color4B(0, 0, 0, 0);
    this.size = size1 || 0;
};

/**
 * A 2D Quad. 4 * 2 floats
 * @Class
 * @Construct
 * @param {cc.Vertex2F} tl1
 * @param {cc.Vertex2F} tr1
 * @param {cc.Vertex2F} bl1
 * @param {cc.Vertex2F} br1
 */
cc.Quad2 = function (tl1, tr1, bl1, br1) {
    this.tl = tl1 || new cc.Vertex2F(0, 0);
    this.tr = tr1 || new cc.Vertex2F(0, 0);
    this.bl = bl1 || new cc.Vertex2F(0, 0);
    this.br = br1 || new cc.Vertex2F(0, 0);
};

/**
 * A 3D Quad. 4 * 3 floats
 * @Class
 * @Construct
 * @param {cc.Vertex3F} bl1
 * @param {cc.Vertex3F} br1
 * @param {cc.Vertex3F} tl1
 * @param {cc.Vertex3F} tr1
 */
cc.Quad3 = function (bl1, br1, tl1, tr1) {
    this.bl = bl1 || new cc.Vertex3F(0, 0, 0);
    this.br = br1 || new cc.Vertex3F(0, 0, 0);
    this.tl = tl1 || new cc.Vertex3F(0, 0, 0);
    this.tr = tr1 || new cc.Vertex3F(0, 0, 0);
};

/**
 * A 2D grid size
 * @Class
 * @Construct
 * @param {Number} x1
 * @param {Number} y1
 */
cc.GridSize = function (x1, y1) {
    this.x = x1;
    this.y = y1;
};

/**
 * helper function to create a cc.GridSize
 * @function
 * @param {Number} x
 * @param {Number} y
 * @return {cc.GridSize}
 */
cc.g = function (x, y) {
    return new cc.GridSize(x, y);
};

/**
 * a Point with a vertex point, a tex coord point and a color 4B
 * @Class
 * @Construct
 * @param {cc.Vertex2F} vertices1
 * @param {cc.Color4B} colors1
 * @param {cc.Tex2F} texCoords1
 */
cc.V2F_C4B_T2F = function (vertices1, colors1, texCoords1) {
    this.vertices = vertices1 || new cc.Vertex2F(0, 0);
    this.colors = colors1 || new cc.Color4B(0, 0, 0, 0);
    this.texCoords = texCoords1 || new cc.Tex2F(0, 0);
};

/**
 * a Point with a vertex point, a tex coord point and a color 4F
 * @Class
 * @Construct
 * @param {cc.Vertex2F} vertices1
 * @param {cc.Color4F} colors1
 * @param {cc.Tex2F} texCoords1
 */
cc.V2F_C4F_T2F = function (vertices1, colors1, texCoords1) {
    this.vertices = vertices1 || new cc.Vertex2F(0, 0);
    this.colors = colors1 || new cc.Color4F(0, 0, 0, 0);
    this.texCoords = texCoords1 || new cc.Tex2F(0, 0);
};

/**
 * a Point with a vertex point, a tex coord point and a color 4B
 * @Class
 * @Construct
 * @param {cc.Vertex3F} vertices1
 * @param {cc.Color4B} colors1
 * @param {cc.Tex2F} texCoords1
 */
cc.V3F_C4B_T2F = function (vertices1, colors1, texCoords1) {
    this.vertices = vertices1 || new cc.Vertex3F(0, 0, 0);
    this.colors = colors1 || new cc.Color4B(0, 0, 0, 0);
    this.texCoords = texCoords1 || new cc.Tex2F(0, 0);
};

/**
 * 4 ccVertex2FTex2FColor4B Quad
 * @Class
 * @Construct
 * @param {cc.V2F_C4B_T2F} bl1 bottom left
 * @param {cc.V2F_C4B_T2F} br1 bottom right
 * @param {cc.V2F_C4B_T2F} tl1 top left
 * @param {cc.V2F_C4B_T2F} tr1 top right
 */
cc.V2F_C4B_T2F_Quad = function (bl1, br1, tl1, tr1) {
    this.bl = bl1 || new cc.V2F_C4B_T2F();
    this.br = br1 || new cc.V2F_C4B_T2F();
    this.tl = tl1 || new cc.V2F_C4B_T2F();
    this.tr = tr1 || new cc.V2F_C4B_T2F();
};

/**
 * helper function to create a cc.V2F_C4B_T2F_Quad
 * @function
 * @return {cc.V2F_C4B_T2F_Quad}
 */
cc.V2F_C4B_T2F_QuadZero = function () {
    return new cc.V2F_C4B_T2F_Quad(
        new cc.V2F_C4B_T2F(new cc.Vertex2F(0, 0), new cc.Color4B(0, 0, 0, 255), new cc.Tex2F(0, 0)),
        new cc.V2F_C4B_T2F(new cc.Vertex2F(0, 0), new cc.Color4B(0, 0, 0, 255), new cc.Tex2F(0, 0)),
        new cc.V2F_C4B_T2F(new cc.Vertex2F(0, 0), new cc.Color4B(0, 0, 0, 255), new cc.Tex2F(0, 0)),
        new cc.V2F_C4B_T2F(new cc.Vertex2F(0, 0), new cc.Color4B(0, 0, 0, 255), new cc.Tex2F(0, 0))
    );
};

/**
 * 4 ccVertex3FTex2FColor4B
 * @Class
 * @Construct
 * @param {cc.V3F_C4B_T2F} tl1 top left
 * @param {cc.V3F_C4B_T2F} bl1 bottom left
 * @param {cc.V3F_C4B_T2F} tr1 top right
 * @param {cc.V3F_C4B_T2F} br1 bottom right
 */
cc.V3F_C4B_T2F_Quad = function (tl1, bl1, tr1, br1) {
    this.tl = tl1 || new cc.V3F_C4B_T2F();
    this.bl = bl1 || new cc.V3F_C4B_T2F();
    this.tr = tr1 || new cc.V3F_C4B_T2F();
    this.br = br1 || new cc.V3F_C4B_T2F();
};

/**
 * helper function to create a cc.V3F_C4B_T2F_Quad
 * @function
 * @return {cc.V3F_C4B_T2F_Quad}
 */
cc.V3F_C4B_T2F_QuadZero = function () {
    return new cc.V3F_C4B_T2F_Quad(
        new cc.V3F_C4B_T2F(new cc.Vertex3F(0, 0, 0), new cc.Color4B(0, 0, 0, 255), new cc.Tex2F(0, 0)),
        new cc.V3F_C4B_T2F(new cc.Vertex3F(0, 0, 0), new cc.Color4B(0, 0, 0, 255), new cc.Tex2F(0, 0)),
        new cc.V3F_C4B_T2F(new cc.Vertex3F(0, 0, 0), new cc.Color4B(0, 0, 0, 255), new cc.Tex2F(0, 0)),
        new cc.V3F_C4B_T2F(new cc.Vertex3F(0, 0, 0), new cc.Color4B(0, 0, 0, 255), new cc.Tex2F(0, 0)));
};

/**
 * 4 ccVertex2FTex2FColor4F Quad
 * @Class
 * @Construct
 * @param {cc.V2F_C4F_T2F} bl1 bottom left
 * @param {cc.V2F_C4F_T2F} br1 bottom right
 * @param {cc.V2F_C4F_T2F} tl1 top left
 * @param {cc.V2F_C4F_T2F} tr1 top right
 * Constructor
 */
cc.V2F_C4F_T2F_Quad = function (bl1, br1, tl1, tr1) {
    this.bl = bl1 || new cc.V2F_C4F_T2F();
    this.br = br1 || new cc.V2F_C4F_T2F();
    this.tl = tl1 || new cc.V2F_C4F_T2F();
    this.tr = tr1 || new cc.V2F_C4F_T2F();
};

/**
 * Blend Function used for textures
 * @Class
 * @Construct
 * @param {Number} src1 source blend function
 * @param {Number} dst1 destination blend function
 */
cc.BlendFunc = function (src1, dst1) {
    this.src = src1;
    this.dst = dst1;
};

/**
 * text alignment : left
 * @constant
 * @type Number
 */
cc.TEXT_ALIGNMENT_LEFT = 0;

/**
 * text alignment : center
 * @constant
 * @type Number
 */
cc.TEXT_ALIGNMENT_CENTER = 1;

/**
 * text alignment : right
 * @constant
 * @type Number
 */
cc.TEXT_ALIGNMENT_RIGHT = 2;

/**
 * text alignment : top
 * @constant
 * @type Number
 */
cc.VERTICAL_TEXT_ALIGNMENT_TOP = 0;

/**
 * text alignment : center
 * @constant
 * @type Number
 */
cc.VERTICAL_TEXT_ALIGNMENT_CENTER = 1;

/**
 * text alignment : bottom
 * @constant
 * @type Number
 */
cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM = 2;
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * @class
 * @param {Number} _x
 * @param {Number} _y
 * Constructor
 */
cc.Point = function (_x, _y) {
    this.x = _x || 0;
    this.y = _y || 0;
};

/**
 * Helper macro that creates a cc.Point.
 * @param {Number} x
 * @param {Number} y
 * @return {}
 */
cc.p = function (x, y) {
    // optimization
    return {x:x, y:y};
//    return new cc.Point(x,y);
};

/**
 * @function
 * @param {cc.Point} point1
 * @param {cc.Point} point2
 * @return {Boolean}
 * Constructor
 */
cc.Point.CCPointEqualToPoint = function (point1, point2) {
    return ((point1.x == point2.x) && (point1.y == point2.y));
};

/**
 * @class
 * @param {Number} _width
 * @param {Number} _height
 * Constructor
 */
cc.Size = function (_width, _height) {
    this.width = _width || 0;
    this.height = _height || 0;
};

/**
 * @function
 * @param {cc.Size} size1
 * @param {cc.Size} size2
 * @return {Boolean}
 * Constructor
 */
cc.Size.CCSizeEqualToSize = function (size1, size2) {
    return ((size1.width == size2.width) && (size1.height == size2.height));

};

/**
 * @class
 * @param {Number} x1
 * @param {Number} y1
 * @param {Number} width1
 * @param {Number} height1
 * Constructor
 */
cc.Rect = function (x1, y1, width1, height1) {
    switch (arguments.length) {
        case 0:
            this.origin = cc.p(0, 0);
            this.size = cc.size(0, 0);
            break;
        case 1:
            var oldRect = x1;
            if (!oldRect) {
                this.origin = cc.p(0, 0);
                this.size = cc.size(0, 0);
            } else {
                if (oldRect instanceof cc.Rect) {
                    this.origin = cc.p(oldRect.origin.x, oldRect.origin.y);
                    this.size = cc.size(oldRect.size.width, oldRect.size.height);
                } else {
                    throw "unknown argument type";
                }
            }
            break;
        case 2:
            this.origin = x1 ? cc.p(x1.x, x1.y) : cc.p(0, 0);
            this.size = y1 ? cc.size(y1.width, y1.height) : cc.size(0, 0);
            break;
        case 4:
            this.origin = cc.p(x1 || 0, y1 || 0);
            this.size = cc.size(width1 || 0, height1 || 0);
            break;
        default:
            throw "unknown argument type";
            break;
    }
};

/**
 * @function
 * @param {cc.Rect} rect1
 * @param {cc.Rect} rect2
 * @return {Boolean}
 * Constructor
 */
cc.Rect.CCRectEqualToRect = function (rect1, rect2) {
    return ((cc.Point.CCPointEqualToPoint(rect1.origin, rect2.origin)) &&
        (cc.Size.CCSizeEqualToSize(rect1.size, rect2.size)));
};

/**
 * return the rightmost x-value of 'rect'
 * @function
 * @param {cc.Rect} rect
 * @return {Number}
 * Constructor
 */
cc.Rect.CCRectGetMaxX = function (rect) {
    return (rect.origin.x + rect.size.width);
};

/**
 * return the midpoint x-value of 'rect'
 * @function
 * @param {cc.Rect} rect
 * @return {Number}
 * Constructor
 */
cc.Rect.CCRectGetMidX = function (rect) {
    return ((rect.origin.x + rect.size.width) / 2.0);
};
/**
 * return the leftmost x-value of 'rect'
 * @function
 * @param {cc.Rect} rect
 * @return {Number}
 * Constructor
 */
cc.Rect.CCRectGetMinX = function (rect) {
    return rect.origin.x;
};

/**
 * Return the topmost y-value of `rect'
 * @function
 * @param {cc.Rect} rect
 * @return {Number}
 * Constructor
 */
cc.Rect.CCRectGetMaxY = function (rect) {
    return(rect.origin.y + rect.size.height);
};

/**
 * Return the midpoint y-value of `rect'
 * @function
 * @param {cc.Rect} rect
 * @return {Number}
 * Constructor
 */
cc.Rect.CCRectGetMidY = function (rect) {
    return rect.origin.y + rect.size.height / 2.0;
};

/**
 * Return the bottommost y-value of `rect'
 * @function
 * @param {cc.Rect} rect
 * @return {Number}
 * Constructor
 */
cc.Rect.CCRectGetMinY = function (rect) {
    return rect.origin.y;
};

/**
 * @function
 * @param {cc.Rect} rect
 * @param {cc.Point} point
 * @return {Boolean}
 * Constructor
 */
cc.Rect.CCRectContainsPoint = function (rect, point) {
    var ret = false;
    if (point.x >= cc.Rect.CCRectGetMinX(rect) && point.x <= cc.Rect.CCRectGetMaxX(rect)
        && point.y >= cc.Rect.CCRectGetMinY(rect) && point.y <= cc.Rect.CCRectGetMaxY(rect)) {
        ret = true;
    }
    return ret;
};

/**
 * @function
 * @param {cc.Rect} rectA
 * @param {cc.Rect} rectB
 * @return {Boolean}
 * Constructor
 */
cc.Rect.CCRectIntersectsRect = function (rectA, rectB) {
    return !(cc.Rect.CCRectGetMaxX(rectA) < cc.Rect.CCRectGetMinX(rectB) ||
        cc.Rect.CCRectGetMaxX(rectB) < cc.Rect.CCRectGetMinX(rectA) ||
        cc.Rect.CCRectGetMaxY(rectA) < cc.Rect.CCRectGetMinY(rectB) ||
        cc.Rect.CCRectGetMaxY(rectB) < cc.Rect.CCRectGetMinY(rectA));
};

/**
 * @function
 * @param {cc.Rect} rectA
 * @param {cc.Rect} rectB
 * @return {Boolean}
 * Constructor
 */
cc.rectIntersectsRect = cc.Rect.CCRectIntersectsRect;

/**
 * @function
 * @param {cc.Rect} rectA
 * @param {cc.Rect} rectB
 * @return {Boolean}
 * Constructor
 */
cc.Rect.CCRectOverlapsRect = function (rectA, rectB) {
    if (rectA.origin.x + rectA.size.width < rectB.origin.x) {
        return false;
    }
    if (rectB.origin.x + rectB.size.width < rectA.origin.x) {
        return false;
    }
    if (rectA.origin.y + rectA.size.height < rectB.origin.y) {
        return false;
    }
    if (rectB.origin.y + rectB.size.height < rectA.origin.y) {
        return false;
    }
    return true;
};

/**
 * Returns the smallest rectangle that contains the two source rectangles.
 * @function
 * @param {cc.Rect}　rectA
 * @param {cc.Rect}　rectB
 * @return {cc.Rect}
 * Constructor
 */
cc.Rect.CCRectUnion = function (rectA, rectB) {
    var rect = cc.rect(0, 0, 0, 0);
    rect.origin.x = Math.min(rectA.origin.x, rectB.origin.x);
    rect.origin.y = Math.min(rectA.origin.y, rectB.origin.y);
    rect.size.width = Math.max(rectA.origin.x + rectA.size.width, rectB.origin.x + rectB.size.width) - rect.origin.x;
    rect.size.height = Math.max(rectA.origin.y + rectA.size.height, rectB.origin.y + rectB.size.height) - rect.origin.y;
    return rect
};

/**
 * Returns the overlapping portion of 2 rectangles
 * @function
 * @param {cc.Rect} rectA
 * @param {cc.Rect} rectB
 * @return {cc.Rect}
 * Constructor
 */
cc.Rect.CCRectIntersection = function (rectA, rectB) {
    var intersection = cc.rect(
        Math.max(cc.Rect.CCRectGetMinX(rectA), cc.Rect.CCRectGetMinX(rectB)),
        Math.max(cc.Rect.CCRectGetMinY(rectA), cc.Rect.CCRectGetMinY(rectB)),
        0, 0);

    intersection.size.width = Math.min(cc.Rect.CCRectGetMaxX(rectA), cc.Rect.CCRectGetMaxX(rectB)) - cc.Rect.CCRectGetMinX(intersection);
    intersection.size.height = Math.min(cc.Rect.CCRectGetMaxY(rectA), cc.Rect.CCRectGetMaxY(rectB)) - cc.Rect.CCRectGetMinY(intersection);
    return intersection
};

/**
 * @function
 * @param {Number} x
 * @param {Number} y
 * @return {cc.Point}
 * Constructor
 */
cc.PointMake = function (x, y) {
    return new cc.Point(x, y);
};

/**
 * @function
 * @param {Number} width
 * @param {Number} height
 * @return {cc.Size}
 * Constructor
 */
cc.SizeMake = function (width, height) {
    return cc.size(width, height);
};

/**
 * @function
 * @param {Number} width
 * @param {Number} height
 * @return {Number, Number}
 * Constructor
 */
cc.size = function (w, h) {
    // optimization
    return {width:w, height:h};

//    return cc.size(w,h);
};

/**
 * @function
 * @param {Number} x
 * @param {Number} y
 * @param {Number} width
 * @param {Number} height
 * @return {cc.Rect}
 * Constructor
 */
cc.RectMake = function (x, y, width, height) {
    return cc.rect(x, y, width, height);
};

// backward compatible
cc.rect = function (x, y, w, h) {
    // optimization
    return { origin:{x:x, y:y}, size:{width:w, height:h} };
//    return cc.rect(x, y, width, height);
};

/**
 * The "left bottom" point -- equivalent to cc.p(0, 0).
 * @function
 * @return {cc.Point}
 * Constructor
 */
cc.PointZero = function () {
    return cc.p(0, 0)
};

/**
 * Point Zero Constant
 * @return {cc.Point}
 */
cc.POINT_ZERO = cc.p(0, 0);

/**
 * The "zero" size -- equivalent to cc.size(0, 0).
 * @function
 * @return {cc.Size}
 * Constructor
 */
cc.SizeZero = function () {
    return cc.size(0, 0)
};

/**
 * Size Zero constant
 * @return {cc.Size}
 */
cc.SIZE_ZERO = cc.size(0, 0);

/**
 * The "zero" rectangle -- equivalent to cc.rect(0, 0, 0, 0).
 * @function
 * @return {cc.Rect}
 * Constructor
 */
cc.RectZero = function () {
    return cc.rect(0, 0, 0, 0)
};

/**
 * Rect Zero Constant
 * @return {cc.Rect}
 */
cc.RECT_ZERO = cc.rect(0, 0, 0, 0);
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * <p>
 * The current version of Cocos2d-html5 being used.<br/>
 * Please DO NOT remove this String, it is an important flag for bug tracking.<br/>
 * If you post a bug to forum, please attach this flag.
 * </p>
 * @constant
 * @type String
 */
cc.ENGINE_VERSION = "Cocos2d-html5-v2.0.0";

/**
 * <p>
 *   If enabled, the texture coordinates will be calculated by using this formula: <br/>
 *      - texCoord.left = (rect.origin.x*2+1) / (texture.wide*2);                  <br/>
 *      - texCoord.right = texCoord.left + (rect.size.width*2-2)/(texture.wide*2); <br/>
 *                                                                                 <br/>
 *  The same for bottom and top.                                                   <br/>
 *                                                                                 <br/>
 *  This formula prevents artifacts by using 99% of the texture.                   <br/>
 *  The "correct" way to prevent artifacts is by using the spritesheet-artifact-fixer.py or a similar tool.<br/>
 *                                                                                  <br/>
 *  Affected nodes:                                                                 <br/>
 *      - cc.Sprite / cc.SpriteBatchNode and subclasses: cc.LabelBMFont, cc.TMXTiledMap <br/>
 *      - cc.LabelAtlas                                                              <br/>
 *      - cc.QuadParticleSystem                                                      <br/>
 *      - cc.TileMap                                                                 <br/>
 *                                                                                  <br/>
 *  To enabled set it to 1. Disabled by default.
 * </p>
 * @constant
 * @type Number
 */
cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL = 0;

/**
 * Position of the FPS (Default: 0,0 (bottom-left corner))
 * @constant
 * @type cc.Point
 */
cc.DIRECTOR_STATS_POSITION = cc.p(0, 0);

/**
 * <p>
 *   Senconds between FPS updates.<br/>
 *   0.5 seconds, means that the FPS number will be updated every 0.5 seconds.<br/>
 *   Having a bigger number means a more reliable FPS<br/>
 *   <br/>
 *   Default value: 0.1f<br/>
 * </p>
 * @constant
 * @type Number
 */
cc.DIRECTOR_FPS_INTERVAL = 0.5;

/**
 * <p>
 *    If enabled, the cc.Node objects (cc.Sprite, cc.Label,etc) will be able to render in subpixels.<br/>
 *    If disabled, integer pixels will be used.<br/>
 *    <br/>
 *    To enable set it to 1. Enabled by default.
 * </p>
 * @constant
 * @type Number
 */
cc.COCOSNODE_RENDER_SUBPIXEL = 1;

/**
 * <p>
 *   If enabled, the cc.Sprite objects rendered with cc.SpriteBatchNode will be able to render in subpixels.<br/>
 *   If disabled, integer pixels will be used.<br/>
 *   <br/>
 *   To enable set it to 1. Enabled by default.
 * </p>
 * @constant
 * @type Number
 */
cc.SPRITEBATCHNODE_RENDER_SUBPIXEL = 1;

/**
 * <p>
 *   If enabled, cc.Node will transform the nodes using a cached Affine matrix.<br/>
 *   If disabled, the node will be transformed using glTranslate,glRotate,glScale.<br/>
 *   Using the affine matrix only requires 2 GL calls.<br/>
 *   Using the translate/rotate/scale requires 5 GL calls.<br/>
 *   But computing the Affine matrix is relative expensive.<br/>
 *   But according to performance tests, Affine matrix performs better.<br/>
 *   This parameter doesn't affect cc.SpriteBatchNode nodes.<br/>
 *   <br/>
 *   To enable set it to a value different than 0. Enabled by default.
 * </p>
 * @constant
 * @type Number
 */
cc.NODE_TRANSFORM_USING_AFFINE_MATRIX = 1;

/**
 * <p>
 *     If most of your imamges have pre-multiplied alpha, set it to 1 (if you are going to use .PNG/.JPG file images).<br/>
 *     Only set to 0 if ALL your images by-pass Apple UIImage loading system (eg: if you use libpng or PVR images)<br/>
 *     <br/>
 *     To enable set it to a value different than 0. Enabled by default.
 * </p>
 * @constant
 * @type Number
 */
cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA = 1;

/**
 * <p>
 *   Use GL_TRIANGLE_STRIP instead of GL_TRIANGLES when rendering the texture atlas.<br/>
 *   It seems it is the recommend way, but it is much slower, so, enable it at your own risk<br/>
 *   <br/>
 *   To enable set it to a value different than 0. Disabled by default.
 * </p>
 * @constant
 * @type Number
 */
cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP = 0;

/**
 * <p>
 *    By default, cc.TextureAtlas (used by many cocos2d classes) will use VAO (Vertex Array Objects).<br/>
 *    Apple recommends its usage but they might consume a lot of memory, specially if you use many of them.<br/>
 *    So for certain cases, where you might need hundreds of VAO objects, it might be a good idea to disable it.<br/>
 *    <br/>
 *    To disable it set it to 0. Enabled by default.<br/>
 * </p>
 * @constant
 * @type Number
 */
cc.TEXTURE_ATLAS_USE_VAO = 1;

/**
 * <p>
 *  If enabled, NPOT textures will be used where available. Only 3rd gen (and newer) devices support NPOT textures.<br/>
 *  NPOT textures have the following limitations:<br/>
 *     - They can't have mipmaps<br/>
 *     - They only accept GL_CLAMP_TO_EDGE in GL_TEXTURE_WRAP_{S,T}<br/>
 *  <br/>
 *  To enable set it to a value different than 0. Disabled by default. <br/>
 *  <br/>
 *  This value governs only the PNG, GIF, BMP, images.<br/>
 *  This value DOES NOT govern the PVR (PVR.GZ, PVR.CCZ) files. If NPOT PVR is loaded, then it will create an NPOT texture ignoring this value.
 * </p>
 * @constant
 * @type Number
 * @deprecated This value will be removed in 1.1 and NPOT textures will be loaded by default if the device supports it.
 */
cc.TEXTURE_NPOT_SUPPORT = 0;

/**
 * <p>
 *    If enabled, cocos2d supports retina display.<br/>
 *    For performance reasons, it's recommended disable it in games without retina display support, like iPad only games.<br/>
 *    <br/>
 *    To enable set it to 1. Use 0 to disable it. Enabled by default.<br/>
 *    <br/>
 *    This value governs only the PNG, GIF, BMP, images.<br/>
 *    This value DOES NOT govern the PVR (PVR.GZ, PVR.CCZ) files. If NPOT PVR is loaded, then it will create an NPOT texture ignoring this value.
 * </p>
 * @constant
 * @type Number
 * @deprecated This value will be removed in 1.1 and NPOT textures will be loaded by default if the device supports it.
 */
cc.RETINA_DISPLAY_SUPPORT = 1;

/**
 * <p>
 *    It's the suffix that will be appended to the files in order to load "retina display" images.<br/>
 *    <br/>
 *    On an iPhone4 with Retina Display support enabled, the file @"sprite-hd.png" will be loaded instead of @"sprite.png".<br/>
 *    If the file doesn't exist it will use the non-retina display image.<br/>
 *    <br/>
 *    Platforms: Only used on Retina Display devices like iPhone 4.
 * </p>
 * @constant
 * @type String
 */
cc.RETINA_DISPLAY_FILENAME_SUFFIX = "-hd";

/**
 * <p>
 *   If enabled, all subclasses of cc.Sprite will draw a bounding box<br/>
 *   Useful for debugging purposes only. It is recommened to leave it disabled.<br/>
 *   <br/>
 *   To enable set it to a value different than 0. Disabled by default:<br/>
 *      0 -- disabled<br/>
 *      1 -- draw bounding box<br/>
 *      2 -- draw texture box
 * </p>
 * @constant
 * @type Number
 */
cc.SPRITE_DEBUG_DRAW = 0;

/**
 * <p>
 *    If enabled, all subclasses of cc.Sprite that are rendered using an cc.SpriteBatchNode draw a bounding box.<br/>
 *    Useful for debugging purposes only. It is recommened to leave it disabled.<br/>
 *    <br/>
 *    To enable set it to a value different than 0. Disabled by default.
 * </p>
 * @constant
 * @type Number
 */
cc.SPRITEBATCHNODE_DEBUG_DRAW = 0;

/**
 * <p>
 *   If enabled, all subclasses of cc.LabelBMFont will draw a bounding box <br/>
 *   Useful for debugging purposes only. It is recommened to leave it disabled.<br/>
 *   <br/>
 *   To enable set it to a value different than 0. Disabled by default.<br/>
 * </p>
 * @constant
 * @type Number
 */
cc.LABELBMFONT_DEBUG_DRAW = 0;

/**
 * <p>
 *    If enabled, all subclasses of cc.LabeltAtlas will draw a bounding box<br/>
 *    Useful for debugging purposes only. It is recommened to leave it disabled.<br/>
 *    <br/>
 *    To enable set it to a value different than 0. Disabled by default.
 * </p>
 * @constant
 * @type Number
 */
cc.LABELATLAS_DEBUG_DRAW = 0;

/**
 * whether or not support retina display
 * @constant
 * @type Number
 */
cc.IS_RETINA_DISPLAY_SUPPORTED = 1;

/**
 * default engine
 * @constant
 * @type String
 */
cc.DEFAULT_ENGINE = cc.ENGINE_VERSION + "-canvas";


/* Runtime information  */
cc.config = {
    'os' : navigator.appVersion,
    'deviceType' : 'browser',
    'engine' : 'cocos2d-html5/canvas',
    'arch' : 'web',
    'version' : cc.ENGINE_VERSION,
    'debug' : false
};

/**
 * dump config info, but only in debug mode
 */
cc.dumpConfig = function()
{
    for( i in cc.config )
        cc.log( i + " = " + cc.config[i] );
}
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * @class
 * @extends cc.Class
 */
cc.Set = cc.Class.extend(/** @lends cc.Set# */{
    /**
     * Constructor
     * @param {cc.Set} setObject
     */
    ctor:function (setObject) {
        if (setObject) {
            this._set = Object.create(setObject._set);
        }
        else {
            this._set = new Array();
        }

    },

    /**
     * Return a copy of the cc.Set, it will copy all the elelments.
     * @return {cc.Set}
     */
    copy:function () {
        return new this.Set(this);
    },

    /**
     * It is the same as copy().
     * @return {cc.Set}
     */
    mutableCopy:function () {
        return this.copy();

    },

    /**
     * Return the number of elements the cc.Set contains.
     * @return {Number}
     */
    count:function () {
        return this._set.length;

    },

    /**
     * Add a element into cc.Set, it will retain the element.
     * @param {object} obj
     */
    addObject:function (obj) {
        this._set.push(obj);

    },

    /**
     * Remove the given element, nothing todo if no element equals obj.
     * @param {object} obj
     */
    removeObject:function (obj) {
        /* if(obj in this._set)
         {
         delete this._set[obj]
         } */
        var k = 0;
        for (var i = 0, n = 0; i < this._set.length; i++) {
            if (this._set[i] != obj) {
                this._set[n++] = this._set[i];
                k++;
            }
        }
        array.length = k;

    },

    /**
     * Check if cc.Set contains a element equals obj.
     * @param {object} obj
     * @return {Boolean}
     */
    containsObject:function (obj) {

        if ((obj in this._set) == true) {
            return true;
        }
        else {
            return false;
        }


    },


    /**
     * Return the first element if it contains elements, or null if it doesn't contain any element.
     * @return {object|Null}
     */
    anyObject:function () {
        if (this._set.length > 0) {
            return this._set[0];
        }
        else {
            return null;
        }

    },

    _set:null

});

/**
 * cc.NSMutableSet is the same as cc.Set
 * @class
 * @extends cc.Set
 */
cc.NSMutableSet = cc.Set;
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * first, judge whether the form of the string like this: {x,y}  <br/>
 * if the form is right,the string will be splited into the parameter strs;<br/>
 * or the parameter strs will be empty. <br/>
 * if the form is right return true,else return false.<br/>
 * @function
 * @param {String} content
 * @param {String} strs
 * @return {String}
 */
cc.splitWithForm = function (content, strs) {
    do {
        if (!content) break;

        // string is empty
        if (content.length == 0) break;

        var posLeft = content.indexOf('{');
        var posRight = content.indexOf('}');

        // don't have '{' and '}'
        if (posLeft == -1 || posRight == -1) break;
        // '}' is before '{'
        if (posLeft > posRight) break;

        var pointStr = content.substr(posLeft + 1, posRight - posLeft - 1);
        // nothing between '{' and '}'
        if (pointStr.length == 0) break;

        var nPos1 = pointStr.indexOf('{');
        var nPos2 = pointStr.indexOf('}');
        // contain '{' or '}'
        if (nPos1 != -1 || nPos2 != -1) break;
        strs = pointStr.split(",");
        if (strs.length != 2 || strs[0] != null || strs[1] != null) {
            break;
        }
    } while (0);

    return strs;
};

/**
 * Returns a Core Graphics rectangle structure corresponding to the data in a given string. <br/>
 * The string is not localized, so items are always separated with a comma. <br/>
 * If the string is not well-formed, the function returns cc.RectZero.
 * @function
 * @param {String} content content A string object whose contents are of the form "{{x,y},{w, h}}",<br/>
 * where x is the x coordinate, y is the y coordinate, w is the width, and h is the height. <br/>
 * These components can represent integer or float values.
 * @return {cc.Rect} A Core Graphics structure that represents a rectangle.
 * Constructor
 * @example
 * // example
 * var rect = cc.RectFromString("{{3,2},{4,5}}");
 */
cc.RectFromString = function (content) {
    var result = cc.RectZero();
    do {
        if (!content) break;

        // find the first '{' and the third '}'
        var posLeft = content.indexOf('{') + 1;
        var posRight = content.lastIndexOf('}', content.length);
        if (posLeft == -1 || posRight == -1) break;

        content = content.substring(posLeft, posRight);
        var nPointEnd = content.indexOf('}');
        if (nPointEnd == -1) break;
        nPointEnd = content.indexOf(',', nPointEnd);
        if (nPointEnd == -1) break;
        // get the point string and size string
        var pointStr = content.substr(0, nPointEnd);
        var sizeStr = content.substr(nPointEnd + 1, content.length - nPointEnd);

        // split the string with ','
        var pointInfo = cc.splitWithForm(pointStr);
        var sizeInfo = cc.splitWithForm(sizeStr);

        var x = parseFloat(pointInfo[0]);
        var y = parseFloat(pointInfo[1]);
        var width = parseFloat(sizeInfo[0]);
        var height = parseFloat(sizeInfo[1]);

        result = cc.rect(x, y, width, height);
    } while (0);
    return result;
};

/**
 * Returns a Core Graphics point structure corresponding to the data in a given string.
 * @function
 * @param {String} content   A string object whose contents are of the form "{x,y}",
 * where x is the x coordinate and y is the y coordinate.<br/>
 * The x and y values can represent integer or float values. <br/>
 * The string is not localized, so items are always separated with a comma.<br/>
 * @return {cc.Point} A Core Graphics structure that represents a point.<br/>
 * If the string is not well-formed, the function returns cc.PointZero.
 * Constructor
 * @example
 * //example
 * var point = cc.PointFromString("{3.0,2.5}");
 */
cc.PointFromString = function (content) {
    var ret = cc.PointZero();
    try {
        if (content == "")
            return ret;

        var strs = cc.splitWithForm(content);
        var x = parseFloat(strs[0]);
        var y = parseFloat(strs[1]);
        ret = cc.p(x, y);
    } catch (e) {
    }
    return ret;
};

/**
 * Returns a Core Graphics size structure corresponding to the data in a given string.
 * @function
 * @param {String} content   A string object whose contents are of the form "{w, h}",<br/>
 * where w is the width and h is the height.<br/>
 * The w and h values can be integer or float values. <br/>
 * The string is not localized, so items are always separated with a comma.<br/>
 * @return {cc.Size} A Core Graphics structure that represents a size.<br/>
 * If the string is not well-formed, the function returns cc.SizeZero.
 * @example
 * // example
 * var size = cc.SizeFromString("{3.0,2.5}");
 */
cc.SizeFromString = function (content) {
    var ret = cc.SizeZero();
    try {
        if (content == "")
            return ret;

        var strs = cc.splitWithForm(content);
        var width = parseFloat(strs[0]);
        var height = parseFloat(strs[1]);
        ret = cc.size(width, height);
    } catch (e) {
    }
    return ret;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * @function
 * @param {Number} a
 * @param {Number} b
 * @param {Number} c
 * @param {Number} d
 * @param {Number} tx
 * @param {Number} ty
 */
cc.AffineTransform = function (a, b, c, d, tx, ty) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = tx;
    this.ty = ty;
};

cc.__AffineTransformMake = function (a, b, c, d, tx, ty) {
    return new cc.AffineTransform(a, b, c, d, tx, ty);
};

/**
 * @function
 * @param {Number} a
 * @param {Number} b
 * @param {Number} c
 * @param {Number} d
 * @param {Number} tx
 * @param {Number} ty
 * @return {cc.AffineTransform}
 * Constructor
 */
cc.AffineTransformMake = function (a, b, c, d, tx, ty) {
    return new cc.AffineTransform(a, b, c, d, tx, ty);
};

cc.__PointApplyAffineTransform = function (point, t) {
    var p = cc.p(0, 0);
    p.x = t.a * point.x + t.c * point.y + t.tx;
    p.y = t.b * point.x + t.d * point.y + t.ty;
    return p;
};

/**
 * @function
 * @param {cc.Point} point
 * @param {cc.AffineTransform} t
 * @return {cc.Point}
 * Constructor
 */
cc.PointApplyAffineTransform = function (point, t) {
    return cc.__PointApplyAffineTransform(point, t);
};

cc.__SizeApplyAffineTransform = function (size, t) {
    var s = cc.size(0, 0);
    s.width = t.a * size.width + t.c * size.height;
    s.height = t.b * size.width + t.d * size.height;
    return s;
};

/**
 * @function
 * @param {cc.Size} size
 * @param {cc.AffineTransform} t
 * @return {cc.Size}
 * Constructor
 */
cc.SizeApplyAffineTransform = function (size, t) {
    return cc.__SizeApplyAffineTransform(size, t);
};

/**
 * @function
 * @return {cc.AffineTransform}
 * Constructor
 */
cc.AffineTransformMakeIdentity = function () {
    return cc.__AffineTransformMake(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
};

/**
 * @function
 * @return {cc.AffineTransform}
 * Constructor
 */
cc.AffineTransformIdentity = function () {
    return cc.AffineTransformMakeIdentity();
};

/**
 * @function
 * @param {cc.Rect} rect
 * @param {cc.AffineTransform} anAffineTransform
 * @return {cc.Rect}
 * Constructor
 */
cc.RectApplyAffineTransform = function (rect, anAffineTransform) {
    var top = cc.Rect.CCRectGetMinY(rect);
    var left = cc.Rect.CCRectGetMinX(rect);
    var right = cc.Rect.CCRectGetMaxX(rect);
    var bottom = cc.Rect.CCRectGetMaxY(rect);

    var topLeft = cc.PointApplyAffineTransform(cc.p(left, top), anAffineTransform);
    var topRight = cc.PointApplyAffineTransform(cc.p(right, top), anAffineTransform);
    var bottomLeft = cc.PointApplyAffineTransform(cc.p(left, bottom), anAffineTransform);
    var bottomRight = cc.PointApplyAffineTransform(cc.p(right, bottom), anAffineTransform);

    var minX = Math.min(Math.min(topLeft.x, topRight.x), Math.min(bottomLeft.x, bottomRight.x));
    var maxX = Math.max(Math.max(topLeft.x, topRight.x), Math.max(bottomLeft.x, bottomRight.x));
    var minY = Math.min(Math.min(topLeft.y, topRight.y), Math.min(bottomLeft.y, bottomRight.y));
    var maxY = Math.max(Math.max(topLeft.y, topRight.y), Math.max(bottomLeft.y, bottomRight.y));

    return cc.rect(minX, minY, (maxX - minX), (maxY - minY));
};

/**
 * @function
 * @param {cc.AffineTransform} t
 * @param {Number} tx
 * @param {Number}ty
 * @return {cc.AffineTransform}
 * Constructor
 */
cc.AffineTransformTranslate = function (t, tx, ty) {
    return cc.__AffineTransformMake(t.a, t.b, t.c, t.d, t.tx + t.a * tx + t.c * ty, t.ty + t.b * tx + t.d * ty);
};

/**
 * @function
 * @param {cc.AffineTransform} t
 * @param {Number} sx
 * @param {Number} sy
 * @return {cc.AffineTransform}
 * Constructor
 */
cc.AffineTransformScale = function (t, sx, sy) {
    return cc.__AffineTransformMake(t.a * sx, t.b * sx, t.c * sy, t.d * sy, t.tx, t.ty);
};

/**
 * @function
 * @param {cc.AffineTransform} aTransform
 * @param {Number} anAngle
 * @return {cc.AffineTransform}
 * Constructor
 */
cc.AffineTransformRotate = function (aTransform, anAngle) {
    var fSin = Math.sin(anAngle);
    var fCos = Math.cos(anAngle);

    return cc.__AffineTransformMake(aTransform.a * fCos + aTransform.c * fSin,
        aTransform.b * fCos + aTransform.d * fSin,
        aTransform.c * fCos - aTransform.a * fSin,
        aTransform.d * fCos - aTransform.b * fSin,
        aTransform.tx,
        aTransform.ty);
};

/* Concatenate `t2' to `t1' and return the result:<br/>
 * t' = t1 * t2
 * @param {cc.AffineTransform} t1
 * @param {cc.AffineTransform} t2
 * @return {cc.AffineTransform}
 * Constructor
 */
cc.AffineTransformConcat = function (t1, t2) {
    return cc.__AffineTransformMake(t1.a * t2.a + t1.b * t2.c, t1.a * t2.b + t1.b * t2.d, //a,b
        t1.c * t2.a + t1.d * t2.c, t1.c * t2.b + t1.d * t2.d, //c,d
        t1.tx * t2.a + t1.ty * t2.c + t2.tx, //tx
        t1.tx * t2.b + t1.ty * t2.d + t2.ty);				  //ty
};

/**
 * Return true if `t1' and `t2' are equal, false otherwise.
 * @function
 * @param {cc.AffineTransform} t1
 * @param {cc.AffineTransform} t2
 * @return {Boolean}
 * Constructor
 */
cc.AffineTransformEqualToTransform = function (t1, t2) {
    return (t1.a == t2.a && t1.b == t2.b && t1.c == t2.c && t1.d == t2.d && t1.tx == t2.tx && t1.ty == t2.ty);
};

/**
 * @function
 * @param {cc.AffineTransform} t
 * @return {cc.AffineTransform}
 * Constructor
 */
cc.AffineTransformInvert = function (t) {
    var determinant = 1 / (t.a * t.d - t.b * t.c);

    return cc.__AffineTransformMake(determinant * t.d, -determinant * t.b, -determinant * t.c, determinant * t.a,
        determinant * (t.c * t.ty - t.d * t.tx), determinant * (t.b * t.tx - t.a * t.ty));
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * <p>cc.Point extensions based on Chipmunk's cpVect file.<br />
 * These extensions work both with cc.Point</p>
 *
 * <p>The "ccp" prefix means: "CoCos2d Point"</p>
 *
 * <p> //Examples:<br />
 * - cc.pAdd( cc.p(1,1), cc.p(2,2) ); // preferred cocos2d way<br />
 * - cc.pAdd( cc.p(1,1), cc.p(2,2) ); // also ok but more verbose<br />
 * - cc.pAdd( cc.cpv(1,1), cc.cpv(2,2) ); // mixing chipmunk and cocos2d (avoid)</p>
 */

/**
 * smallest such that 1.0+FLT_EPSILON != 1.0
 * @constant
 * @type Number
 */
cc.POINT_EPSILON = parseFloat('1.192092896e-07F');

/**
 * Returns opposite of point.
 * @param {cc.Point} point
 * @return {cc.Point}
 */
cc.pNeg = function (point) {
    return cc.p(-point.x, -point.y);
};

/**
 * Calculates sum of two points.
 * @param {cc.Point} v1
 * @param {cc.Point} v2
 * @return {cc.Point}
 */
cc.pAdd = function (v1, v2) {
    return cc.p(v1.x + v2.x, v1.y + v2.y);
};

/**
 * Calculates difference of two points.
 * @param {cc.Point} v1
 * @param {cc.Point} v2
 * @return {cc.Point}
 */
cc.pSub = function (v1, v2) {
    return cc.p(v1.x - v2.x, v1.y - v2.y);
};

/**
 * Returns point multiplied by given factor.
 * @param {cc.Point} point
 * @param {Number} floatVar
 * @return {cc.Point}
 */
cc.pMult = function (point, floatVar) {
    return cc.p(point.x * floatVar, point.y * floatVar);
};

/**
 * Calculates midpoint between two points.
 * @param {cc.Point} v1
 * @param {cc.Point} v2
 * @return {cc.pMult}
 */
cc.pMidpoint = function (v1, v2) {
    return cc.pMult(cc.pAdd(v1, v2), 0.5);
};

/**
 * Calculates dot product of two points.
 * @param {cc.Point} v1
 * @param {cc.Point} v2
 * @return {Number}
 */
cc.pDot = function (v1, v2) {
    return v1.x * v2.x + v1.y * v2.y;
};

/**
 * Calculates cross product of two points.
 * @param {cc.Point} v1
 * @param {cc.Point} v2
 * @return {Number}
 */
cc.pCross = function (v1, v2) {
    return v1.x * v2.y - v1.y * v2.x;
};

/**
 * Calculates perpendicular of v, rotated 90 degrees counter-clockwise -- cross(v, perp(v)) >= 0
 * @param {cc.Point} point
 * @return {cc.Point}
 */
cc.pPerp = function (point) {
    return cc.p(-point.y, point.x);
};

/**
 * Calculates perpendicular of v, rotated 90 degrees clockwise -- cross(v, rperp(v)) <= 0
 * @param {cc.Point} point
 * @return {cc.Point}
 */
cc.pRPerp = function (point) {
    return cc.p(point.y, -point.x);
};

/**
 * Calculates the projection of v1 over v2.
 * @param {cc.Point} v1
 * @param {cc.Point} v2
 * @return {cc.pMult}
 */
cc.pProject = function (v1, v2) {
    return cc.pMult(v2, cc.pDot(v1, v2) / cc.pDot(v2, v2));
};

/**
 * Rotates two points.
 * @param  {cc.Point} v1
 * @param  {cc.Point} v2
 * @return {cc.Point}
 */
cc.pRotate = function (v1, v2) {
    return cc.p(v1.x * v2.x - v1.y * v2.y, v1.x * v2.y + v1.y * v2.x);
};

/**
 * Unrotates two points.
 * @param  {cc.Point} v1
 * @param  {cc.Point} v2
 * @return {cc.Point}
 */
cc.pUnrotate = function (v1, v2) {
    return cc.p(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y);
};

/**
 * Calculates the square length of a cc.Point (not calling sqrt() )
 * @param  {cc.Point} v
 *@return {cc.pDot}
 */
cc.pLengthSQ = function (v) {
    return cc.pDot(v, v);
};

/**
 * Calculates distance between point an origin
 * @param  {cc.Point} v
 * @return {Number}
 */
cc.pLength = function (v) {
    return Math.sqrt(cc.pLengthSQ(v));
};

/**
 * Calculates the distance between two points
 * @param {cc.Point} v1
 * @param {cc.Point} v2
 * @return {cc.pLength}
 */
cc.pDistance = function (v1, v2) {
    return cc.pLength(cc.pSub(v1, v2));
};

/**
 * Returns point multiplied to a length of 1.
 * @param {cc.Point} v
 * @return {cc.pMult}
 */
cc.pNormalize = function (v) {
    return cc.pMult(v, 1.0 / cc.pLength(v));
};

/**
 * Converts radians to a normalized vector.
 * @param {Number} a
 * @return {cc.Point}
 */
cc.pForAngle = function (a) {
    return cc.p(Math.cos(a), Math.sin(a));
};

/**
 * Converts a vector to radians.
 * @param {cc.Point} v
 * @return {Number}
 */
cc.pToAngle = function (v) {
    return Math.atan2(v.y, v.x);
};

/**
 * Clamp a value between from and to.
 * @param {Number} value
 * @param {Number} min_inclusive
 * @param {Number} max_inclusive
 * @return {Number}
 */
cc.clampf = function (value, min_inclusive, max_inclusive) {
    if (min_inclusive > max_inclusive) {
        var temp = min_inclusive;
        min_inclusive = max_inclusive;
        max_inclusive = temp;
    }
    return value < min_inclusive ? min_inclusive : value < max_inclusive ? value : max_inclusive;
};

/**
 * Clamp a point between from and to.
 * @param {Number} p
 * @param {Number} min_inclusive
 * @param {Number} max_inclusive
 * @return {cc.Point}
 */
cc.pClamp = function (p, min_inclusive, max_inclusive) {
    return cc.p(cc.clampf(p.x, min_inclusive.x, max_inclusive.x), cc.clampf(p.y, min_inclusive.y, max_inclusive.y));
};

/**
 * Quickly convert cc.Size to a cc.Point
 * @param {cc.Size} s
 * @return {cc.Point}
 */
cc.pFromSize = function (s) {
    return cc.p(s.width, s.height);
};

/**
 * Run a math operation function on each point component <br />
 * Math.abs, Math.fllor, Math.ceil, Math.round.
 * @param {cc.Point} p
 * @param {Function} opFunc
 * @return {cc.Point}
 * @example
 * //For example: let's try to take the floor of x,y
 * var p = cc.pCompOp(cc.p(10,10),Math.abs);
 */
cc.pCompOp = function (p, opFunc) {
    return cc.p(opFunc(p.x), opFunc(p.y));
};

/**
 * Linear Interpolation between two points a and b
 * alpha == 0 ? a
 * alpha == 1 ? b
 * otherwise a value between a..b
 * @param {cc.Point} a
 * @param {cc.Point} b
 * @param {Number} alpha
 * @return {cc.pAdd}
 */
cc.pLerp = function (a, b, alpha) {
    return cc.pAdd(cc.pMult(a, 1 - alpha), cc.pMult(b, alpha));
};

/**
 * @param {cc.Point} a
 * @param {cc.Point} b
 * @param {Number} variance
 * @return {Boolean} if points have fuzzy equality which means equal with some degree of variance.
 */
cc.pFuzzyEqual = function (a, b, variance) {
    if (a.x - variance <= b.x && b.x <= a.x + variance) {
        if (a.y - variance <= b.y && b.y <= a.y + variance) {
            return true;
        }
    }
    return false;
};

/**
 * Multiplies a nd b components, a.x*b.x, a.y*b.y
 * @param {cc.Point} a
 * @param {cc.Point} b
 * @return {cc.Point}
 */
cc.pCompMult = function (a, b) {
    return cc.p(a.x * b.x, a.y * b.y);
};

/**
 * @param {cc.Point} a
 * @param {cc.Point} b
 * @return {Number} the signed angle in radians between two vector directions
 */
cc.pAngleSigned = function (a, b) {
    var a2 = cc.pNormalize(a);
    var b2 = cc.pNormalize(b);
    var angle = Math.atan2(a2.x * b2.y - a2.y * b2.x, cc.pDot(a2, b2));
    if (Math.abs(angle) < cc.POINT_EPSILON) {
        return 0.0;
    }
    return angle;
};

/**
 * @param {cc.Point} a
 * @param {cc.Point} b
 * @return {Number} the angle in radians between two vector directions
 */
cc.pAngle = function (a, b) {
    var angle = Math.acos(cc.pDot(cc.pNormalize(a), cc.pNormalize(b)));
    if (Math.abs(angle) < cc.POINT_EPSILON) return 0.0;
    return angle;
};

/**
 * Rotates a point counter clockwise by the angle around a pivot
 * @param {cc.Point} v v is the point to rotate
 * @param {cc.Point} pivot pivot is the pivot, naturally
 * @param {Number} angle angle is the angle of rotation cw in radians
 * @return {cc.Point} the rotated point
 */
cc.pRotateByAngle = function (v, pivot, angle) {
    var r = cc.pSub(v, pivot);
    var cosa = Math.cos(angle), sina = Math.sin(angle);
    var t = r.x;
    r.x = t * cosa - r.y * sina + pivot.x;
    r.y = t * sina + r.y * cosa + pivot.y;
    return r;
};

/**
 * A general line-line intersection test
 * @param {cc.Point} A A is the startpoint for the first line P1 = (p1 - p2).
 * @param {cc.Point} B B is the endpoint for the first line P1 = (p1 - p2).
 * @param {cc.Point} C C is the startpoint for the second line P2 = (p3 - p4).
 * @param {cc.Point} D D is the endpoint for the second line P2 = (p3 - p4).
 * @param {cc.Point} retP retP.x is the range for a hitpoint in P1 (pa = p1 + s*(p2 - p1)), <br />
 * retP.y is the range for a hitpoint in P3 (pa = p2 + t*(p4 - p3)).
 * @return {Boolean}
 * indicating successful intersection of a line<br />
 * note that to truly test intersection for segments we have to make<br />
 * sure that s & t lie within [0..1] and for rays, make sure s & t > 0<br />
 * the hit point is        p3 + t * (p4 - p3);<br />
 * the hit point also is    p1 + s * (p2 - p1);
 */
cc.pLineIntersect = function (A, B, C, D, retP) {
    if ((A.x == B.x && A.y == B.y) || (C.x == D.x && C.y == D.y)) {
        return false;
    }
    var BAx = B.x - A.x;
    var BAy = B.y - A.y;
    var DCx = D.x - C.x;
    var DCy = D.y - C.y;
    var ACx = A.x - C.x;
    var ACy = A.y - C.y;

    var denom = DCy * BAx - DCx * BAy;

    retP.x = DCx * ACy - DCy * ACx;
    retP.y = BAx * ACy - BAy * ACx;

    if (denom == 0) {
        if (retP.x == 0 || retP.y == 0) {
            // Lines incident
            return true;
        }
        // Lines parallel and not incident
        return false;
    }

    retP.x = retP.x / denom;
    retP.y = retP.y / denom;

    return true;
};

/**
 * ccpSegmentIntersect return YES if Segment A-B intersects with segment C-D.
 * @param {cc.Point} A
 * @param {cc.Point} B
 * @param {cc.Point} C
 * @param {cc.Point} D
 * @return {Boolean}
 */
cc.pSegmentIntersect = function (A, B, C, D) {
    var retP = cc.p(0, 0);
    if (cc.pLineIntersect(A, B, C, D, retP))
        if (retP.x >= 0.0 && retP.x <= 1.0 && retP.y >= 0.0 && retP.y <= 1.0)
            return true;
    return false;
};

/**
 * ccpIntersectPoint return the intersection point of line A-B, C-D
 * @param {cc.Point} A
 * @param {cc.Point} B
 * @param {cc.Point} C
 * @param {cc.Point} D
 * @return {cc.Point}
 */
cc.pIntersectPoint = function (A, B, C, D) {
    var retP = cc.p(0, 0);

    if (cc.pLineIntersect(A, B, C, D, retP)) {
        // Point of intersection
        var P = cc.p(0, 0);
        P.x = A.x + retP.x * (B.x - A.x);
        P.y = A.y + retP.x * (B.y - A.y);
        return P;
    }

    return cc.PointZero();
};

/**
 * check to see if both points are equal
 * @param {cc.Point} A A ccp a
 * @param {cc.Point} B B ccp b to be compared
 * @return {Boolean} the true if both ccp are same
 */
cc.pSameAs = function (A, B) {
    if (A.x && B.x) {
        return (A.x == B.x && A.y == B.y);
    }
    return false;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * <p>cc.UserDefault acts as a tiny localStorage. You can save and get base type values by it. <br/>
 * For example, setBoolForKey("played", true) will add a bool value true into the localStorage. <br/>
 * Its key is "played". You can get the value of the key by getBoolForKey("played").</p>
 *
 * <p>It supports the following base types: <br/>
 * bool, int, float, double, string</p>
 *
 * @class
 * @extends cc.Class
 */

cc.UserDefault = cc.Class.extend(/** @lends cc.UserDefault# */{
    _db:null,
    /*
     * init user default
     * */
    init:function () {
        this._db = this._getLocalStorage();
        return true;
    },

    _getLocalStorage:function () {
        try {
            if (!!window.localStorage) {
                return window.localStorage;
            }
        } catch (e) {
            return undefined;
        }
    },

    _getWebSqlDatabase:function () {

    },

    /**
     * Get bool value by key, if the key doesn't exist, a default value will return. <br/>
     * You can set the default value, or it is false.
     *
     * @param {String} key
     * @param {Boolean} defaultValue
     * @return {Boolean}
     */
    getBoolForKey:function (key, defaultValue) {
        var value = this._getValueForKey(key);
        var ret = defaultValue || false;
        if (value == "true") {
            return true;
        }
        else if (value == "false") {
            return false;
        }
        else if (value) {
            return Boolean(value);
        }

        return ret;
    },

    /**
     * Get integer value by key, if the key doesn't exist, a default value will return.<br/>
     * You can set the default value, or it is 0.
     *
     * @param {String} key
     * @param {Number} defaultValue
     * @return {Number}
     */
    getIntegerForKey:function (key, defaultValue) {
        var value = this._getValueForKey(key);
        var ret = defaultValue || 0;

        if (value) {
            return parseInt(value);
        }

        return ret;
    },

    /**
     * Get float value by key, if the key doesn't exist, a default value will return.<br/>
     * You can set the default value, or it is 0.0f.
     *
     * @param {String} key
     * @param {Number} defaultValue
     * @return {Number}
     */
    getFloatForKey:function (key, defaultValue) {
        var value = this._getValueForKey(key);
        var ret = defaultValue || 0.0;

        if (value) {
            return parseFloat(value);
        }

        return ret;
    },

    /**
     * Get double value by key, if the key doesn't exist, a default value will return.<br/>
     * You can set the default value, or it is 0.0.
     *
     * @param {String} key
     * @param {Number} defaultValue
     * @return {Number}
     */
    getDoubleForKey:function (key, defaultValue) {
        return this.getFloatForKey(key, defaultValue);
    },

    /**
     * Get string value by key, if the key doesn't exist, a default value will return.<br/>
     * You can set the default value, or it is "".
     *
     * @param {String} key
     * @param {String} defaultValue
     * @return {String}
     */
    getStringForKey:function (key, defaultValue) {
        var value = this._getValueForKey(key);
        var ret = defaultValue || "";

        if (value) {
            return  String(value);
        }

        return ret;
    },

    _getValueForKey:function (key) {
        var ret;
        if (this._db) {
            ret = this._db.getItem(key);
        }

        return ret;
    },

    /**
     * Set bool value by key.
     *
     * @param {String} key
     * @param {Boolean} value
     */
    setBoolForKey:function (key, value) {
        // save bool value as sring
        this.setStringForKey(key, String(value));
    },

    /**
     * Set integer value by key.
     *
     * @param {String} key
     * @param {Number} value
     */
    setIntegerForKey:function (key, value) {
        // check key
        if (!key) {
            return;
        }

        this._setValueForKey(key, parseInt(value));
    },

    /**
     * Set float value by key.
     *
     * @param {String} key
     * @param {Number} value
     */
    setFloatForKey:function (key, value) {
        // check key
        if (!key) {
            return;
        }

        this._setValueForKey(key, parseFloat(value));
    },

    /**
     * Set double value by key.
     *
     * @param {String} key
     * @param {Number} value
     */
    setDoubleForKey:function (key, value) {
        return this.setFloatForKey(key, value);
    },

    /**
     * Set string value by key.
     *
     * @param {String} key
     * @param {String} value
     */
    setStringForKey:function (key, value) {
        // check key
        if (!key) {
            return;
        }

        this._setValueForKey(key, String(value));
    },

    _setValueForKey:function (key, value) {
        if (this._db) {
            this._db.setItem(key, value);
        }
    }
});

/**
 * returns a shared instance of the UserDefault
 * @function
 * @return {cc.UserDefault|}
 */
cc.UserDefault.getInstance = function () {
    if (!this._sUserDefault) {
        this._sUserDefault = new cc.UserDefault();
        this._sUserDefault.init();
    }

    return this._sUserDefault;
};

/**
 * purge a shared instance of the UserDefault
 * @function
 * @return {cc.UserDefault|}
 */
cc.UserDefault.purgeInstanceUserDefault = function () {
    if (this._db) {
        this._db.clear();
    }
};

cc.UserDefault._sUserDefault = null;
cc.UserDefault._isFilePathInitialized = false;/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * Default Node tag
 * @constant
 * @type Number
 */
cc.NODE_TAG_INVALID = -1;
/**
 * Node on enter
 * @constant
 */
cc.NODE_ON_ENTER = null;
/**
 * Node on exit
 * @constant
 */
cc.NODE_ON_EXIT = null;

/**
 * save the context
 * @function
 */
cc.saveContext = function () {
    if (cc.renderContextType == cc.CANVAS) {
        cc.renderContext.save();
    } else {
        //glPushMatrix();
    }
};

/**
 * restore the context
 * @function
 */
cc.restoreContext = function () {
    if (cc.renderContextType == cc.CANVAS) {
        cc.renderContext.restore();
    } else {
        //glPopMatrix();
    }
};

/**
 *  XXX: Yes, nodes might have a sort problem once every 15 days if the game runs at 60 FPS and each frame sprites are reordered.
 * @type Number
 */
cc.s_globalOrderOfArrival = 1;


/** <p>cc.Node is the main element. Anything thats gets drawn or contains things that get drawn is a cc.Node.<br/>
 The most popular cc.Nodes are: cc.Scene, cc.Layer, cc.Sprite, cc.Menu.<br/></p>

 <p>The main features of a cc.Node are: <br/>
 - They can contain other cc.Node nodes (addChild, getChildByTag, removeChild, etc) <br/>
 - They can schedule periodic callback (schedule, unschedule, etc) <br/>
 - They can execute actions (runAction, stopAction, etc) <br/></p>

 <p>Some cc.Node nodes provide extra functionality for them or their children.</p>

 <p>Subclassing a cc.Node usually means (one/all) of: <br/>
 - overriding init to initialize resources and schedule callbacks  <br/>
 - create callbacks to handle the advancement of time <br/>
 - overriding draw to render the node   <br/></p>

 <p>Features of cc.Node: <br/>
 - position  <br/>
 - scale (x, y) <br/>
 - rotation (in degrees, clockwise) <br/>
 - cc.Camera (an interface to gluLookAt ) <br/>
 - cc.GridBase (to do mesh transformations)  <br/>
 - anchor point<br/>
 - size <br/>
 - visible<br/>
 - z-order <br/>
 - openGL z position <br/></P>

 <p> Default values: <br/>
 - rotation: 0 <br/>
 - position: (x=0,y=0) <br/>
 - scale: (x=1,y=1) <br/>
 - contentSize: (x=0,y=0)<br/>
 - anchorPoint: (x=0,y=0)<br/></p>

 <p> Limitations:<br/>
 - A cc.Node is a "void" object. It doesn't have a texture <br/></P>

 <p>Order in transformations with grid disabled <br/>
 -# The node will be translated (position)  <br/>
 -# The node will be rotated (rotation)<br/>
 -# The node will be scaled (scale)  <br/>
 -# The node will be moved according to the camera values (camera) <br/></p>

 <p>Order in transformations with grid enabled<br/>
 -# The node will be translated (position)<br/>
 -# The node will be rotated (rotation) <br/>
 -# The node will be scaled (scale) <br/>
 -# The grid will capture the screen <br/>
 -# The node will be moved according to the camera values (camera) <br/>
 -# The grid will render the captured screen <br/></P>

 <p>Camera:  <br/>
 - Each node has a camera. By default it points to the center of the cc.Node.</P>
 * @class
 * @extends cc.Class
 * @example
 * // example
 * cc.Sprite = cc.Node.extend({});
 * cc.Sprite.initWithImage = function(){
 * };
 */
cc.Node = cc.Class.extend(/** @lends cc.Node# */{
    _zOrder:0,
    _vertexZ:0.0,
    _rotation:0.0,
    _scaleX:1.0,
    _scaleY:1.0,
    _position:cc.p(0, 0),
    _skewX:0.0,
    _skewY:0.0,
    // children (lazy allocs),
    _children:null,
    // lazy alloc,
    _camera:null,
    _grid:null,
    _isVisible:true,
    _anchorPoint:cc.p(0, 0),
    _anchorPointInPoints:cc.p(0, 0),
    _contentSize:cc.SizeZero(),
    _isRunning:false,
    _parent:null,
    // "whole screen" objects. like Scenes and Layers, should set _ignoreAnchorPointForPosition to true
    _ignoreAnchorPointForPosition:false,
    _tag:cc.NODE_TAG_INVALID,
    // userData is always inited as nil
    _userData:null,
    _userObject:null,
    _isTransformDirty:true,
    _isInverseDirty:true,
    _isCacheDirty:true,
    _isTransformGLDirty:null,
    _transform:null,
    _inverse:null,
    //since 2.0 api
    _reorderChildDirty:false,
    _shaderProgram:null,
    _orderOfArrival:0,
    _glServerState:null,
    _actionManager:null,
    _scheduler:null,

    /**
     * Constructor
     */
    ctor:function () {
        if (cc.NODE_TRANSFORM_USING_AFFINE_MATRIX) {
            this._isTransformGLDirty = true;
        }
        this._anchorPoint = cc.p(0, 0);
        this._anchorPointInPoints = cc.p(0, 0);
        this._contentSize = cc.size(0, 0);
        this._position = cc.p(0, 0);

        var director = cc.Director.getInstance();
        this._actionManager = director.getActionManager();
        this.getActionManager = function () {
            return this._actionManager;
        };
        this._scheduler = director.getScheduler();
        this.getScheduler = function () {
            return this._scheduler;
        }
    },

    /**
     * @param {Array} array
     * @param {cc.Node.StateCallbackType} function Type
     * @private
     */
    _arrayMakeObjectsPerformSelector:function (array, callbackType) {
        if (!array || array.length == 0)
            return;

        var i;
        switch (callbackType) {
            case cc.Node.StateCallbackType.onEnter:
                for (i = 0; i < array.length; i++) {
                    if (array[i])
                        array[i].onEnter();
                }
                break;
            case cc.Node.StateCallbackType.onExit:
                for (i = 0; i < array.length; i++) {
                    if (array[i])
                        array[i].onExit();
                }
                break;
            case cc.Node.StateCallbackType.onEnterTransitionDidFinish:
                for (i = 0; i < array.length; i++) {
                    if (array[i])
                        array[i].onEnterTransitionDidFinish();
                }
                break;
            case cc.Node.StateCallbackType.cleanup:
                for (i = 0; i < array.length; i++) {
                    if (array[i])
                        array[i].cleanup();
                }
                break;
            case cc.Node.StateCallbackType.updateTransform:
                for (i = 0; i < array.length; i++) {
                    if (array[i])
                        array[i].updateTransform();
                }
                break;
            case cc.Node.StateCallbackType.onExitTransitionDidStart:
                for (i = 0; i < array.length; i++) {
                    if (array[i])
                        array[i].onExitTransitionDidStart();
                }
                break;
            case cc.Node.StateCallbackType.sortAllChildren:
                for (i = 0; i < array.length; i++) {
                    if (array[i])
                        array[i].sortAllChildren();
                }
                break;
            default :
                throw "Unknown callback function";
                break;
        }
    },

    /**
     * @param {cc.Rect} rect
     * @private
     */
    _addDirtyRegionToDirector:function (rect) {
        //if (!cc.firstRun) {
        //cc.Director.getInstance().addRegionToDirtyRegion(rect);
        //}
    },

    _isInDirtyRegion:function () {
        //if (!cc.firstRun) {
        //    return cc.Director.getInstance().rectIsInDirtyRegion(this.getBoundingBoxToWorld());
        //}
    },

    /**
     * set the dirty node
     */
    setNodeDirty:function () {
        this._setNodeDirtyForCache();
        this._isTransformDirty = this._isInverseDirty = true;
        if (cc.NODE_TRANSFORM_USING_AFFINE_MATRIX) {
            this._isTransformGLDirty = true;
        }
    },

    _setNodeDirtyForCache:function () {
        this._isCacheDirty = true;
        if (this._parent) {
            this._parent._setNodeDirtyForCache();
        }
    },

    /**
     *  get the skew degrees in X
     * @return {Number}
     */
    getSkewX:function () {
        return this._skewX;
    },

    /**
     * set the skew degrees in X
     * @param {Number} newSkewX
     */
    setSkewX:function (newSkewX) {
        //save dirty region when before change
        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());

        this._skewX = newSkewX;

        //save dirty region when after changed
        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());
        this.setNodeDirty();
    },

    /** get the skew degrees in Y
     * @return {Number}
     */
    getSkewY:function () {
        return this._skewY;
    },

    /**
     * set the skew degrees in Y
     * @param {Number} newSkewY
     */
    setSkewY:function (newSkewY) {
        //save dirty region when before change
        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());

        this._skewY = newSkewY;
        //save dirty region when after changed
        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());
        this.setNodeDirty();
    },

    /**
     * zOrder getter
     * @return {Number}
     */
    getZOrder:function () {
        return this._zOrder;
    },

    /** zOrder setter : private method
     * used internally to alter the zOrder variable. DON'T call this method manually
     * @param {Number} z
     * @private
     */
    _setZOrder:function (z) {
        this._zOrder = z
    },

    setZOrder:function (z) {
        this._setZOrder(z);
        if (this._parent) {
            this._parent.reorderChild(this, z);
        }
    },

    /**
     * ertexZ getter
     * @return {Number}
     */
    getVertexZ:function () {
        return this._vertexZ;
    },

    /**
     * vertexZ setter
     * @param {Number} Var
     */
    setVertexZ:function (Var) {
        this._vertexZ = Var;
    },

    /**
     * rotation getter
     * @return {Number}
     */
    getRotation:function () {
        return this._rotation;
    },

    _rotationRadians:0,
    /**
     * rotation setter
     * @param {Number} newRotation
     */
    setRotation:function (newRotation) {
        if (this._rotation == newRotation)
            return;
        //save dirty region when before change
        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());

        this._rotation = newRotation;
        this._rotationRadians = this._rotation * (Math.PI / 180);
        //save dirty region when after changed
        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());
        this.setNodeDirty();
    },

    /** Get the scale factor of the node.
     * @warning: Assert when _scaleX != _scaleY.
     * @return {Number}
     */
    getScale:function () {
        cc.Assert(this._scaleX == this._scaleY, "cc.Node#scale. ScaleX != ScaleY. Don't know which one to return");
        return this._scaleX;
    },

    /**
     * The scale factor of the node. 1.0 is the default scale factor.
     * @param {Number} scale or scaleX value
     * @param {Number} scaleY
     */
    setScale:function (scale, scaleY) {
        //save dirty region when before change
        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());

        this._scaleX = scale;
        this._scaleY = scaleY || scale;

        //save dirty region when after changed
        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());
        this.setNodeDirty();
    },

    /**
     * scaleX getter
     * @return {Number}
     */
    getScaleX:function () {
        return this._scaleX;
    },

    /**
     * scaleX setter
     * @param {Number} newScaleX
     */
    setScaleX:function (newScaleX) {
        //save dirty region when before change
        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());

        this._scaleX = newScaleX;

        //save dirty region when after changed
        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());
        this.setNodeDirty();
    },

    /**
     * scaleY getter
     * @return {Number}
     */
    getScaleY:function () {
        return this._scaleY;
    },

    /**
     * scaleY setter
     * @param {Number} newScaleY
     */
    setScaleY:function (newScaleY) {
        //save dirty region when before change
        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());

        this._scaleY = newScaleY;

        //save dirty region when after changed
        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());
        this.setNodeDirty();
    },

    /**
     * position setter
     * @param {cc.Point|Number} newPosOrxValue
     * @param {Number}  yValue
     */
    setPosition:function (newPosOrxValue, yValue) {
        //save dirty region when before change
        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());
        if (yValue) {
            this._position.x = newPosOrxValue;
            this._position.y = yValue;
            //this._position = cc.p(newPosOrxValue,yValue);
        } else if (newPosOrxValue.y != null) {
            this._position = newPosOrxValue;
        }

        //save dirty region when after changed
        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());
        this.setNodeDirty();
    },

    /** <p>get/set Position for Lua (pass number faster than cc.Point object)</p>

     <p>lua code:<br/>
     local x, y = node:getPosition()    -- return x, y values from C++ <br/>
     local x    = node:getPositionX()<br/>
     local y    = node:getPositionY()<br/>
     node:setPosition(x, y)             -- pass x, y values to C++ <br/>
     node:setPositionX(x) <br/>
     node:setPositionY(y)<br/>
     node:setPositionInPixels(x, y)     -- pass x, y values to C++ <br/></P>
     * @return {cc.Point}
     */
    getPosition:function () {
        return cc.p(this._position.x, this._position.y);
    },

    /**
     * @return {Number}
     */
    getPositionX:function () {
        return this._position.x;
    },

    /**
     * @param {Number} x
     */
    setPositionX:function (x) {
        this._position.x = x;
        //this._position = cc.p(x,this._position.y);
        this.setNodeDirty();
    },

    /**
     * @return {Number}
     */
    getPositionY:function () {
        return  this._position.y;
    },

    /**
     * @param {Number} y
     */
    setPositionY:function (y) {
        this._position.y = y;
        //this._position = cc.p(this._position.x, y);
        this.setNodeDirty();
    },

    /**
     * Get children count
     * @return {Number}
     */

    getChildrenCount:function () {
        return this._children ? this._children.length : 0;
    },

    /**
     * children getter
     * @return {object}
     */
    getChildren:function () {
        if (!this._children)
            this._children = [];
        return this._children;
    },

    /**
     * camera getter: lazy alloc
     * @return {cc.Camera}
     */
    getCamera:function () {
        if (!this._camera) {
            this._camera = new cc.Camera();
        }
        return this._camera;
    },

    /**
     * grid getter
     * @return {cc.GridBase}
     */
    getGrid:function () {
        return this._grid;
    },

    /**
     * grid setter
     * @param {cc.GridBase} grid
     */
    setGrid:function (grid) {
        this._grid = grid;
    },

    /**
     * isVisible getter
     * @return {Boolean}
     */
    isVisible:function () {
        return this._isVisible;
    },

    /**
     * isVisible setter
     * @param {Boolean} Var
     */
    setVisible:function (Var) {
        this._isVisible = Var;
        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());
        this.setNodeDirty();
    },

    /** <p>anchorPoint is the point around which all transformations and positioning manipulations take place.<br/>
     It's like a pin in the node where it is "attached" to its parent. <br/>
     The anchorPoint is normalized, like a percentage. (0,0) means the bottom-left corner and (1,1) means the top-right corner. <br/>
     But you can use values higher than (1,1) and lower than (0,0) too.  <br/>
     The default anchorPoint is (0.5,0.5), so it starts in the center of the node. <br/></p>
     */
    getAnchorPoint:function () {
        return cc.p(this._anchorPoint.x, this._anchorPoint.y);
    },

    /**
     * @param {cc.Point} point
     */
    setAnchorPoint:function (point) {
        if (!cc.Point.CCPointEqualToPoint(point, this._anchorPoint)) {
            //save dirty region when before change
            //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());

            this._anchorPoint = point;
            this._anchorPointInPoints = cc.p(this._contentSize.width * this._anchorPoint.x,
                this._contentSize.height * this._anchorPoint.y);

            //save dirty region when after changed
            //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());
            this.setNodeDirty();
        }
    },

    /** AnchorPointInPoints getter
     * @return {cc.Point}
     */
    getAnchorPointInPoints:function () {
        return cc.p(this._anchorPointInPoints.x, this._anchorPointInPoints.y);
    },

    /** <p>The untransformed size of the node. <br/>
     The contentSize remains the same no matter the node is scaled or rotated.<br/>
     All nodes has a size. Layer and Scene has the same size of the screen. <br/></p>
     * @return {cc.Size}
     */
    getContentSize:function () {
        return cc.size(this._contentSize.width, this._contentSize.height);
    },

    /**
     * @param {cc.Size} size
     */
    setContentSize:function (size) {
        if (!cc.Size.CCSizeEqualToSize(size, this._contentSize)) {
            //save dirty region when before change
            //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());
            this._contentSize = size;

            this._anchorPointInPoints = cc.p(this._contentSize.width * this._anchorPoint.x,
                this._contentSize.height * this._anchorPoint.y);
            //save dirty region when before change
            //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());
            this.setNodeDirty();
        }
    },

    /**
     * isRunning getter
     * @return {Boolean}
     */
    isRunning:function () {
        return this._isRunning;
    },

    /** parent getter
     * @return {cc.Node}
     */
    getParent:function () {
        return this._parent;
    },

    /** parent setter
     * @param {cc.Node} Var
     */
    setParent:function (Var) {
        this._parent = Var;
    },

    /** ignoreAnchorPointForPosition getter
     * @return {Boolean}
     */
    isIgnoreAnchorPointForPosition:function () {
        return this._ignoreAnchorPointForPosition;
    },

    /** ignoreAnchorPointForPosition setter
     * @param {Boolean} newValue
     */
    ignoreAnchorPointForPosition:function (newValue) {
        if (newValue != this._ignoreAnchorPointForPosition) {
            //save dirty region when before change
            //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());

            this._ignoreAnchorPointForPosition = newValue;

            //save dirty region when before change
            //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());
            this.setNodeDirty();
        }
    },

    /**
     * tag getter
     * @return {Number}
     */
    getTag:function () {
        return this._tag;
    },

    /** tag setter
     * @param {Number} Var
     */
    setTag:function (Var) {
        this._tag = Var;
    },

    /**
     * @return {object}
     */
    getUserData:function () {
        return this._userData;
    },

    /**
     * @param {object} Var
     */
    setUserData:function (Var) {
        this._userData = Var;
    },

    /**
     * Similar to userData, but instead of holding a void* it holds an id
     * @return {object}
     */
    getUserObject:function () {
        return this._userObject;
    },

    /**
     * Similar to userData, but instead of holding a void* it holds an id
     * @param {object} newValue
     */
    setUserObject:function (newValue) {
        if (this._userObject != newValue) {
            this._userObject = newValue;
        }
    },

    /**
     * Shader Program getter
     * @return {object}
     */
    getShaderProgram:function () {
        return this._shaderProgram;
    },

    /**
     * Shader Program setter
     * @param {object} newValue
     */
    setShaderProgram:function (newValue) {
        if (this._shaderProgram != newValue) {
            this._shaderProgram = newValue;
        }
    },

    /**
     * used internally for zOrder sorting, don't change this manually
     * @return {Number}
     */
    getOrderOfArrival:function () {
        return this._orderOfArrival;
    },

    /**
     * used internally for zOrder sorting, don't change this manually
     * @param {Number} Var
     */
    setOrderOfArrival:function (Var) {
        this._orderOfArrival = Var;
    },

    /**
     * GL server side state getter
     * @return {Number}
     */
    getGLServerState:function () {
        return this._glServerState;
    },

    /**
     * GL server side state setter
     * @param {Number} Var
     */
    setGLServerState:function (Var) {
        this._glServerState = Var;
    },

    /**
     * <p>cc.ActionManager used by all the actions. <br/>
     * (IMPORTANT: If you set a new cc.ActionManager, then previously created actions are going to be removed.)</p>
     * @return {cc.ActionManager}
     */
    getActionManager:function () {
        if (!this._actionManager) {
            this._actionManager = cc.Director.getInstance().getActionManager();
            this.getActionManager = function () {
                return this._actionManager;
            };
        }

        return this._actionManager;
    },

    /**
     * <p>cc.ActionManager used by all the actions. <br/>
     * (IMPORTANT: If you set a new cc.ActionManager, then previously created actions are going to be removed.)</p>
     * @param {cc.ActionManager} actionManager
     */
    setActionManager:function (actionManager) {
        if (this._actionManager != actionManager) {
            this.stopAllActions();
            this._shaderProgram = actionManager;
        }
    },

    /**
     * <p>
     *   cc.Scheduler used to schedule all "updates" and timers.<br/>
     *   IMPORTANT: If you set a new cc.Scheduler, then previously created timers/update are going to be removed.
     * </p>
     * @return {cc.Scheduler}
     */
    getScheduler:function () {
        if (!this._scheduler) {
            this._scheduler = cc.Director.getInstance().getScheduler();
            this.getScheduler = function () {
                return this._scheduler;
            };
        }
        return this._scheduler;
    },

    /**
     * <p>
     *   cc.Scheduler used to schedule all "updates" and timers.<br/>
     *   IMPORTANT: If you set a new cc.Scheduler, then previously created timers/update are going to be removed.
     * </p>
     */
    setScheduler:function (scheduler) {
        if (this._scheduler != scheduler) {
            this.unscheduleAllSelectors();
            this._scheduler = scheduler;
        }
    },

    /** returns a "local" axis aligned bounding box of the node. <br/>
     * The returned box is relative only to its parent.
     * @return {cc.rect}
     */
    getBoundingBox:function () {
        var rect = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        return cc.RectApplyAffineTransform(rect, this.nodeToParentTransform());
    },

    /** returns a "world" axis aligned bounding box of the node. <br/>
     * @return {cc.Rect}
     */
    getBoundingBoxToWorld:function () {
        var rect = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        rect = cc.RectApplyAffineTransform(rect, this.nodeToWorldTransform());
        rect = cc.rect(0 | rect.origin.x - 4, 0 | rect.origin.y - 4, 0 | rect.size.width + 8, 0 | rect.size.height + 8);
        //query child's BoundingBox
        if (!this._children)
            return rect;

        for (var i = 0; i < this._children.length; i++) {
            var child = this._children[i];
            if (child && child._isVisible) {
                var childRect = child.getBoundingBoxToWorld();
                if (childRect) {
                    rect = cc.Rect.CCRectUnion(rect, childRect);
                }
            }
        }
        return rect;
    },
    /**
     * Stops all running actions and schedulers
     */
    cleanup:function () {
        // actions
        this.stopAllActions();
        this.unscheduleAllSelectors();

        // timers
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.cleanup);
    },

    /** Node description
     * @return {String}
     */
    description:function () {
        return "<cc.Node | Tag =" + this._tag + ">";
    },

    _childrenAlloc:function () {
        this._children = [];
    },

    // composition: GET
    /**
     * Gets a child from the container given its tag
     * @param {Number} aTag
     * @return {cc.Node}
     */
    getChildByTag:function (aTag) {
        cc.Assert(aTag != cc.NODE_TAG_INVALID, "Invalid tag");
        if (this._children != null) {
            for (var i = 0; i < this._children.length; i++) {
                var node = this._children[i];
                if (node && node._tag == aTag) {
                    return node;
                }
            }
        }
        //throw "not found";
        return null;
    },
    // composition: ADD

    /** <p>"add" logic MUST only be on this method <br/> </p>
     *
     * <p>If a class want's to extend the 'addChild' behaviour it only needs  <br/>
     * to override this method </p>
     *
     * @param {cc.Node} child
     * @param {Number} zOrder
     * @param {Number} tag
     */
    addChild:function (child, zOrder, tag) {
        var argnum = arguments.length;
        cc.Assert(child != null, "Argument must be non-nil");
        cc.Assert(child._parent == null, "child already added. It can't be added again");
        var tempzOrder = (zOrder != null) ? zOrder : child.getZOrder();
        var tmptag = (tag != null) ? tag : child.getTag();
        child.setTag(tmptag);

        if (!this._children) {
            this._childrenAlloc();
        }

        this._insertChild(child, tempzOrder);

        child.setParent(this);
        if (this._isRunning) {
            child.onEnter();
            child.onEnterTransitionDidFinish();
        }

    },

    // composition: REMOVE
    /** Remove itself from its parent node. If cleanup is true, then also remove all actions and callbacks. <br/>
     *  If the node orphan, then nothing happens.
     * @param {Boolean} cleanup
     */
    removeFromParentAndCleanup:function (cleanup) {
        if (this._parent)
            this._parent.removeChild(this, cleanup);
    },

    /** <p>Removes a child from the container. It will also cleanup all running actions depending on the cleanup parameter. </p>
     *
     *<p> "remove" logic MUST only be on this method  <br/>
     * If a class want's to extend the 'removeChild' behavior it only needs <br/>
     * to override this method </p>
     *
     * @param {cc.Node} child
     * @param {Boolean} cleanup
     */
    removeChild:function (child, cleanup) {
        // explicit nil handling
        if (this._children == null) {
            return;
        }

        if (this._children.indexOf(child) > -1) {
            this._detachChild(child, cleanup);
        }

        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());
        this.setNodeDirty();
    },

    /**
     * Removes a child from the container by tag value. It will also cleanup all running actions depending on the cleanup parameter
     * @param {Number} tag
     * @param {Boolean} cleanup
     */
    removeChildByTag:function (tag, cleanup) {
        cc.Assert(tag != cc.NODE_TAG_INVALID, "Invalid tag");

        var child = this.getChildByTag(tag);
        if (child == null) {
            cc.log("cocos2d: removeChildByTag: child not found!");
        }
        else {
            this.removeChild(child, cleanup);
        }
    },

    /**
     * Removes all children from the container and do a cleanup all running actions depending on the cleanup parameter.
     * @param {Boolean} cleanup
     */
    removeAllChildrenWithCleanup:function (cleanup) {
        // not using detachChild improves speed here
        if (this._children != null) {
            for (var i = 0; i < this._children.length; i++) {
                var node = this._children[i];
                if (node) {
                    // IMPORTANT:
                    //  -1st do onExit
                    //  -2nd cleanup
                    if (this._isRunning) {
                        node.onExitTransitionDidStart();
                        node.onExit();
                    }
                    if (cleanup) {
                        node.cleanup();
                    }
                    // set parent nil at the end
                    node.setParent(null);
                }
            }
            this._children = [];
        }
    },

    /**
     * @param {cc.Node} child
     * @param {Boolean} doCleanup
     * @private
     */
    _detachChild:function (child, doCleanup) {
        // IMPORTANT:
        //  -1st do onExit
        //  -2nd cleanup
        if (this._isRunning) {
            child.onExitTransitionDidStart();
            child.onExit();
        }

        // If you don't do cleanup, the child's actions will not get removed and the
        // its scheduledSelectors_ dict will not get released!
        if (doCleanup) {
            child.cleanup();
        }

        // set parent nil at the end
        child.setParent(null);

        cc.ArrayRemoveObject(this._children, child);
    },

    /** helper used by reorderChild & add
     * @param {cc.Node} child
     * @param {Number} z
     * @private
     */
    _insertChild:function (child, z) {
        this._reorderChildDirty = true;
        var a = this._children[this._children.length - 1];
        if (!a || a.getZOrder() <= z) {
            this._children.push(child);
        } else {
            for (var i = 0; i < this._children.length; i++) {
                var node = this._children[i];
                if (node && (node.getZOrder() > z )) {
                    this._children = cc.ArrayAppendObjectToIndex(this._children, child, i);
                    break;
                }
            }
        }
        child._setZOrder(z);
    },

    /** Reorders a child according to a new z value. <br/>
     * The child MUST be already added.
     * @param {cc.Node} child
     * @param {Number} zOrder
     */
    reorderChild:function (child, zOrder) {
        cc.Assert(child != null, "Child must be non-nil");
        this._reorderChildDirty = true;

        //save dirty region when before change
        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());

        child.setOrderOfArrival(cc.s_globalOrderOfArrival++);
        child._setZOrder(zOrder);

        //save dirty region when after changed
        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());
        this.setNodeDirty();
    },

    /**
     * <p>performance improvement, Sort the children array once before drawing, instead of every time when a child is added or reordered <br/>
     * don't call this manually unless a child added needs to be removed in the same frame </p>
     */
    sortAllChildren:function () {
        if (this._reorderChildDirty) {
            var i, j, length = this._children.length;

            // insertion sort
            for (i = 0; i < length; i++) {
                var tempItem = this._children[i];
                j = i - 1;

                //continue moving element downwards while zOrder is smaller or when zOrder is the same but mutatedIndex is smaller
                while (j >= 0 && ( tempItem._zOrder < this._children[j]._zOrder ||
                    ( tempItem._zOrder == this._children[j]._zOrder && tempItem._orderOfArrival < this._children[j]._orderOfArrival ))) {
                    this._children[j + 1] = this._children[j];
                    j = j - 1;
                }
                this._children[j + 1] = tempItem;
            }

            //don't need to check children recursively, that's done in visit of each child
            this._reorderChildDirty = false;
        }
    },

    // draw
    /** <p>Override this method to draw your own node. <br/>
     * The following GL states will be enabled by default: <br/>
     - glEnableClientState(GL_VERTEX_ARRAY);  <br/>
     - glEnableClientState(GL_COLOR_ARRAY); <br/>
     - glEnableClientState(GL_TEXTURE_COORD_ARRAY); <br/>
     - glEnable(GL_TEXTURE_2D); </p>

     <p>AND YOU SHOULD NOT DISABLE THEM AFTER DRAWING YOUR NODE</p>

     <p>But if you enable any other GL state, you should disable it after drawing your node. </p>
     * @param {CanvasContext} ctx
     */
    draw:function (ctx) {
        //cc.Assert(0);
        // override me
        // Only use- this function to draw your staff.
        // DON'T draw your stuff outside this method
    },

    /**
     * recursive method that visit its children and draw them
     * @param {CanvasContext} ctx
     */
    visit:function (ctx) {
        // quick return if not visible
        if (!this._isVisible) {
            return;
        }

        var context = ctx || cc.renderContext;
        var i;

        if (cc.renderContextType == cc.CANVAS) {
            context.save();
            this.transform(context);

            if (this._children && this._children.length > 0) {
                this.sortAllChildren();
                // draw children zOrder < 0
                for (i = 0; i < this._children.length; i++) {
                    if (this._children[i] && this._children[i]._zOrder < 0) {
                        this._children[i].visit(context);
                    } else {
                        break;
                    }
                }
                //if (this._isInDirtyRegion()) {
                // self draw
                this.draw(context);
                //}
                // draw children zOrder >= 0
                if (this._children) {
                    for (; i < this._children.length; i++) {
                        if (this._children[i] && this._children[i]._zOrder >= 0) {
                            this._children[i].visit(context);
                        }
                    }
                }
            } else {
                //if (this._isInDirtyRegion()) {
                // self draw
                this.draw(context);
                //}
            }
            this._orderOfArrival = 0;
            context.restore();
        } else {
            if (this._grid && this._grid.isActive()) {
                this._grid.beforeDraw();
            }

            this.transform(context);
            if (this._children && this._children.length > 0) {
                this.sortAllChildren();
                // draw children zOrder < 0
                for (i = 0; i < this._children.length; i++) {
                    if (this._children[i] && this._children[i]._zOrder < 0) {
                        this._children[i].visit(context);
                    } else {
                        break;
                    }
                }

                //if (this._isInDirtyRegion()) {
                // self draw
                this.draw(context);
                //}

                // draw children zOrder >= 0
                if (this._children) {
                    for (; i < this._children.length; i++) {
                        if (this._children[i] && this._children[i]._zOrder >= 0) {
                            this._children[i].visit(context);
                        }
                    }
                }
            } else {
                //if (this._isInDirtyRegion()) {
                // self draw
                this.draw(context);
                //}
            }

            this._orderOfArrival = 0;

            if (this._grid && this._grid.isActive()) {
                this._grid.afterDraw(this);
            }

            context.restore();
        }
    },

    /** performs OpenGL view-matrix transformation of it's ancestors.<br/>
     * Generally the ancestors are already transformed, but in certain cases (eg: attaching a FBO) <br/>
     * it's necessary to transform the ancestors again.
     */
    transformAncestors:function () {
        if (this._parent != null) {
            this._parent.transformAncestors();
            this._parent.transform();
        }
    },

    /** transformations <br/>
     * performs OpenGL view-matrix transformation based on position, scale, rotation and other attributes.
     * @param {CanvasContext} ctx
     */
    transform:function (ctx) {
        var context = ctx || cc.renderContext;
        // transformations
        if (cc.renderContextType == cc.CANVAS) {
            if (!this._ignoreAnchorPointForPosition) {
                if (this._parent) {
                    context.translate(0 | (this._position.x - this._parent._anchorPointInPoints.x), -(0 | (this._position.y - this._parent._anchorPointInPoints.y)));
                } else {
                    context.translate(0 | this._position.x, -(0 | this._position.y));
                }
            } else {
                if (this._parent) {
                    context.translate(0 | ( this._position.x - this._parent._anchorPointInPoints.x + this._anchorPointInPoints.x),
                        -(0 | (this._position.y - this._parent._anchorPointInPoints.y + this._anchorPointInPoints.y)));
                } else {
                    context.translate(0 | ( this._position.x + this._anchorPointInPoints.x), -(0 | (this._position.y + this._anchorPointInPoints.y)));
                }
            }

            if (this._rotation != 0) {
                //context.rotate(cc.DEGREES_TO_RADIANS(this._rotation));
                context.rotate(this._rotationRadians);
            }

            if ((this._scaleX != 1) || (this._scaleY != 1)) {
                context.scale(this._scaleX, this._scaleY);
            }

            if ((this._skewX != 0) || (this._skewY != 0)) {
                context.transform(1,
                    -Math.tan(cc.DEGREES_TO_RADIANS(this._skewY)),
                    -Math.tan(cc.DEGREES_TO_RADIANS(this._skewX)),
                    1, 0, 0);
            }
        } else {
            //Todo WebGL implement need fixed
            var transfrom4x4;

            // Convert 3x3 into 4x4 matrix
            var tmpAffine = this.nodeToParentTransform();
            //CGAffineToGL(&tmpAffine, transfrom4x4.mat);

            // Update Z vertex manually
            //transfrom4x4.mat[14] = m_fVertexZ;

            //kmGLMultMatrix( &transfrom4x4 );


            // XXX: Expensive calls. Camera should be integrated into the cached affine matrix
            /*if ( m_pCamera != NULL && !(m_pGrid != NULL && m_pGrid->isActive()) ) {
             bool translate = (m_tAnchorPointInPoints.x != 0.0f || m_tAnchorPointInPoints.y != 0.0f);

             if( translate )
             kmGLTranslatef(RENDER_IN_SUBPIXEL(m_tAnchorPointInPoints.x), RENDER_IN_SUBPIXEL(m_tAnchorPointInPoints.y), 0 );

             m_pCamera->locate();

             if( translate )
             kmGLTranslatef(RENDER_IN_SUBPIXEL(-m_tAnchorPointInPoints.x), RENDER_IN_SUBPIXEL(-m_tAnchorPointInPoints.y), 0 );
             }*/
        }
    },

    //scene managment
    /**
     * callback that is called every time the cc.Node enters the 'stage'.<br/>
     * If the cc.Node enters the 'stage' with a transition, this callback is called when the transition starts.
     * During onEnter you can't a "sister/brother" node.
     */
    onEnter:function () {
        this._isRunning = true;//should be running before resumeSchedule
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.onEnter);
        this.resumeSchedulerAndActions();
    },

    /**
     * <p>callback that is called when the cc.Node enters in the 'stage'.  <br/>
     * If the cc.Node enters the 'stage' with a transition, this callback is called when the transition finishes.</p>
     */
    onEnterTransitionDidFinish:function () {
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.onEnterTransitionDidFinish);
    },

    /**
     * <p>callback that is called every time the cc.Node leaves the 'stage'.  <br/>
     * If the cc.Node leaves the 'stage' with a transition, this callback is called when the transition starts. </p>
     */
    onExitTransitionDidStart:function () {
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.onExitTransitionDidStart);
    },

    /**
     * callback that is called every time the cc.Node leaves the 'stage'.<br/>
     * If the cc.Node leaves the 'stage' with a transition, this callback is called when the transition finishes. <br/>
     * During onExit you can't access a sibling node.
     */
    onExit:function () {
        this._isRunning = false;
        this.pauseSchedulerAndActions();
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.onExit);
    },

    // actions
    /**
     * Executes an action, and returns the action that is executed.<br/>
     * The node becomes the action's target.
     * @warning Starting from v0.8 actions don't retain their target anymore.
     * @param {cc.Action} action
     * @return {cc.Action}
     */
    runAction:function (action) {
        cc.Assert(action != null, "Argument must be non-nil");
        this.getActionManager().addAction(action, this, !this._isRunning);
        return action;
    },

    /**
     * Removes all actions from the running action list
     */
    stopAllActions:function () {
        this.getActionManager().removeAllActionsFromTarget(this);
    },

    /**
     * Removes an action from the running action list
     * @param {cc.Action} action
     */
    stopAction:function (action) {
        this.getActionManager().removeAction(action);
    },

    /**
     * Removes an action from the running action list given its tag
     * @param {Number} tag
     */
    stopActionByTag:function (tag) {
        cc.Assert(tag != cc.ACTION_TAG_INVALID, "Invalid tag");
        this.getActionManager().removeActionByTag(tag, this);
    },

    /**
     * Gets an action from the running action list given its tag
     * @param {Number} tag
     * @return {cc.Action}
     */
    getActionByTag:function (tag) {
        cc.Assert(tag != cc.ACTION_TAG_INVALID, "Invalid tag");
        return this.getActionManager().getActionByTag(tag, this);
    },

    /** Returns the numbers of actions that are running plus the ones that are schedule to run (actions in actionsToAdd and actions arrays).<br/>
     *    Composable actions are counted as 1 action. Example:<br/>
     *    If you are running 1 Sequence of 7 actions, it will return 1. <br/>
     *    If you are running 7 Sequences of 2 actions, it will return 7.
     * @return {Number}
     */
    numberOfRunningActions:function () {
        return this.getActionManager().numberOfRunningActionsInTarget(this);
    },

    // cc.Node - Callbacks
    // timers
    /**
     * schedules the "update" method. It will use the order number 0. This method will be called every frame.<br/>
     * Scheduled methods with a lower order value will be called before the ones that have a higher order value.<br/>
     * Only one "update" method could be scheduled per node.
     */
    scheduleUpdate:function () {
        this.scheduleUpdateWithPriority(0);
    },

    /**
     * schedules the "update" selector with a custom priority. This selector will be called every frame.<br/>
     * Scheduled selectors with a lower priority will be called before the ones that have a higher value.<br/>
     * Only one "update" selector could be scheduled per node (You can't have 2 'update' selectors).<br/>
     * @param {Number} priority
     */
    scheduleUpdateWithPriority:function (priority) {
        this.getScheduler().scheduleUpdateForTarget(this, priority, !this._isRunning);
    },

    /**
     * unschedules the "update" method.
     */
    unscheduleUpdate:function () {
        this.getScheduler().unscheduleUpdateForTarget(this);
    },

    /**
     * schedule
     * @param {function} selector
     * @param {Number} interval
     */
    schedule:function (selector, interval, repeat, delay) {
        interval = interval || 0;

        cc.Assert(selector, "Argument must be non-nil");
        cc.Assert(interval >= 0, "Argument must be positive");

        repeat = (repeat == null) ? cc.REPEAT_FOREVER : repeat;
        delay = delay || 0;

        this.getScheduler().scheduleSelector(selector, this, interval, !this._isRunning, repeat, delay);
    },

    /**
     * Schedules a selector that runs only once, with a delay of 0 or larger
     * @param {cc.Class} selector
     * @param {Number} delay
     */
    scheduleOnce:function (selector, delay) {
        this.schedule(selector, 0.0, 0, delay);
    },

    /**
     * unschedules a custom selector.
     * @param {function} selector
     */
    unschedule:function (selector) {
        // explicit nil handling
        if (!selector)
            return;

        this.getScheduler().unscheduleSelector(selector, this);
    },

    /**
     * unschedule all scheduled selectors: custom selectors, and the 'update' selector.<br/>
     * Actions are not affected by this method.
     */
    unscheduleAllSelectors:function () {
        this.getScheduler().unscheduleAllSelectorsForTarget(this);
    },

    /**
     * resumes all scheduled selectors and actions.<br/>
     * Called internally by onEnter
     */
    resumeSchedulerAndActions:function () {
        this.getScheduler().resumeTarget(this);
        this.getActionManager().resumeTarget(this);
    },

    /**
     * pauses all scheduled selectors and actions.<br/>
     * Called internally by onExit
     */
    pauseSchedulerAndActions:function () {
        this.getScheduler().pauseTarget(this);
        this.getActionManager().pauseTarget(this);
    },

    /** Returns the matrix that transform the node's (local) space coordinates into the parent's space coordinates.<br/>
     * The matrix is in Pixels.
     * @return {cc.AffineTransform}
     */
    nodeToParentTransform:function () {
        if (this._isTransformDirty) {
            // Translate values
            var x = this._position.x;
            var y = this._position.y;

            if (this._ignoreAnchorPointForPosition) {
                x += this._anchorPointInPoints.x;
                y += this._anchorPointInPoints.y;
            }

            // Rotation values
            var c = 1, s = 0;
            if (this._rotation) {
                //var radians = -cc.DEGREES_TO_RADIANS(this._rotation);
                c = Math.cos(-this._rotationRadians);
                s = Math.sin(-this._rotationRadians);
            }

            var needsSkewMatrix = ( this._skewX || this._skewY );

            // optimization:
            // inline anchor point calculation if skew is not needed
            if (!needsSkewMatrix && !cc.Point.CCPointEqualToPoint(this._anchorPointInPoints, cc.p(0, 0))) {
                x += c * -this._anchorPointInPoints.x * this._scaleX + -s * -this._anchorPointInPoints.y * this._scaleY;
                y += s * -this._anchorPointInPoints.x * this._scaleX + c * -this._anchorPointInPoints.y * this._scaleY;
            }


            // Build Transform Matrix
            this._transform = cc.AffineTransformMake(c * this._scaleX, s * this._scaleX,
                -s * this._scaleY, c * this._scaleY, x, y);

            // XXX: Try to inline skew
            // If skew is needed, apply skew and then anchor point
            if (needsSkewMatrix) {
                var skewMatrix = cc.AffineTransformMake(1.0, Math.tan(cc.DEGREES_TO_RADIANS(this._skewY)),
                    Math.tan(cc.DEGREES_TO_RADIANS(this._skewX)), 1.0, 0.0, 0.0);
                this._transform = cc.AffineTransformConcat(skewMatrix, this._transform);

                // adjust anchor point
                if (!cc.Point.CCPointEqualToPoint(this._anchorPointInPoints, cc.p(0, 0))) {
                    this._transform = cc.AffineTransformTranslate(this._transform, -this._anchorPointInPoints.x, -this._anchorPointInPoints.y);
                }
            }

            this._isTransformDirty = false;
        }

        return this._transform;
    },

    /**
     * Returns the matrix that transform parent's space coordinates to the node's (local) space coordinates.<br/>
     * The matrix is in Pixels.
     * @return {Number}
     */
    parentToNodeTransform:function () {
        if (this._isInverseDirty) {
            this._inverse = cc.AffineTransformInvert(this.nodeToParentTransform());
            this._isInverseDirty = false;
        }

        return this._inverse;
    },

    /**
     *  Retrusn the world affine transform matrix. The matrix is in Pixels.
     * @return {cc.AffineTransform}
     */
    nodeToWorldTransform:function () {
        var t = this.nodeToParentTransform();
        for (var p = this._parent; p != null; p = p.getParent()) {
            t = cc.AffineTransformConcat(t, p.nodeToParentTransform());
        }
        return t;
    },

    /**
     * Returns the inverse world affine transform matrix. The matrix is in Pixels.
     * @return {cc.AffineTransform}
     */
    worldToNodeTransform:function () {
        return cc.AffineTransformInvert(this.nodeToWorldTransform());
    },

    /**
     * Converts a Point to node (local) space coordinates. The result is in Points.
     * @param {cc.Point} worldPoint
     * @return {cc.Point}
     */
    convertToNodeSpace:function (worldPoint) {
        return cc.PointApplyAffineTransform(worldPoint, this.worldToNodeTransform());
    },

    /**
     * Converts a Point to world space coordinates. The result is in Points.
     * @param {cc.Point} nodePoint
     * @return {cc.Point}
     */
    convertToWorldSpace:function (nodePoint) {
        return cc.PointApplyAffineTransform(nodePoint, this.nodeToWorldTransform());
    },

    /**
     * Converts a Point to node (local) space coordinates. The result is in Points.<br/>
     * treating the returned/received node point as anchor relative.
     * @param {cc.Point} worldPoint
     * @return {cc.Point}
     */
    convertToNodeSpaceAR:function (worldPoint) {
        return cc.pSub(this.convertToNodeSpace(worldPoint), this._anchorPointInPoints);
    },

    /**
     * Converts a local Point to world space coordinates.The result is in Points.<br/>
     * treating the returned/received node point as anchor relative.
     * @param {cc.Point} nodePoint
     * @return {cc.Point}
     */
    convertToWorldSpaceAR:function (nodePoint) {
        var pt = cc.pAdd(nodePoint, this._anchorPointInPoints);
        return this.convertToWorldSpace(pt);
    },

    _convertToWindowSpace:function (nodePoint) {
        var worldPoint = this.convertToWorldSpace(nodePoint);
        return cc.Director.getInstance().convertToUI(worldPoint);
    },

    /** convenience methods which take a cc.Touch instead of cc.Point
     * @param {cc.Touch} touch
     * @return {cc.Point}
     */
    convertTouchToNodeSpace:function (touch) {
        var point = touch.getLocation();
        point = cc.Director.getInstance().convertToGL(point);
        return this.convertToNodeSpace(point);
    },

    /**
     * converts a cc.Touch (world coordinates) into a local coordiante. This method is AR (Anchor Relative).
     * @param {cc.Touch}touch
     * @return {cc.Point}
     */
    convertTouchToNodeSpaceAR:function (touch) {
        var point = touch.getLocation();
        point = cc.Director.getInstance().convertToGL(point);
        return this.convertToNodeSpaceAR(point);
    },

    /** implement cc.Object's method
     * @param {Number} dt
     */
    update:function (dt) {
    }
});

/**
 * cc.Node's state callback type
 * @constant
 * @type Number
 */
cc.Node.StateCallbackType = {onEnter:1, onExit:2, cleanup:3, onEnterTransitionDidFinish:4, updateTransform:5, onExitTransitionDidStart:6, sortAllChildren:7};


/**
 * allocates and initializes a node.
 * @constructs
 * @return {cc.Node}
 * @example
 * // example
 * var node = cc.Node.create();
 */
cc.Node.create = function () {
    return new cc.Node();
};

/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/


/** <p> cc.AtlasNode is a subclass of cc.Node that implements the cc.RGBAProtocol and<br/>
 * cc.TextureProtocol protocol</p>
 *
 * <p> It knows how to render a TextureAtlas object.  <br/>
 * If you are going to render a TextureAtlas consider subclassing cc.AtlasNode (or a subclass of cc.AtlasNode)</p>
 *
 * <p> All features from cc.Node are valid, plus the following features:  <br/>
 * - opacity and RGB colors </p>
 * @class
 * @extends cc.Node
 */
cc.AtlasNode = cc.Node.extend(/** @lends cc.AtlasNode# */{
    RGBAProtocol:true,
    //! chars per row
    _itemsPerRow:0,
    //! chars per column
    _itemsPerColumn:0,
    //! width of each char
    _itemWidth:0,
    //! height of each char
    _itemHeight:0,
    _colorUnmodified:cc.c3b(0, 0, 0),
    _textureAtlas:null,
    // protocol variables
    _isOpacityModifyRGB:false,
    _blendFunc: {src:cc.BLEND_SRC, dst:cc.BLEND_DST},
    _opacity:0,
    _color:null,
    _originalTexture:null,
    // quads to draw
    _quadsToDraw:0,
    _uniformColor:0,

    /** initializes an cc.AtlasNode  with an Atlas file the width and height of each item and the quantity of items to render
     * @param {String} tile
     * @param {Number} tileWidth
     * @param {Number} tileHeight
     * @param {Number} itemsToRender
     * @return {Boolean}
     */
    initWithTileFile:function (tile, tileWidth, tileHeight, itemsToRender) {
        cc.Assert(tile != null, "title should not be null");
        this._itemWidth = tileWidth;
        this._itemHeight = tileHeight;

        this._opacity = 255;
        this._color = cc.white();
        this._colorUnmodified = cc.white();
        this._isOpacityModifyRGB = true;

        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;

        var newAtlas = new cc.TextureAtlas();
        newAtlas.initWithFile(tile, itemsToRender);
        this.setTextureAtlas(newAtlas);

        if (cc.renderContextType == cc.CANVAS) {
            this._originalTexture = this._textureAtlas.getTexture();
        }

        if (!this._textureAtlas) {
            cc.log("cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.");
            return false;
        }

        this._updateBlendFunc();
        this._updateOpacityModifyRGB();

        this._calculateMaxItems();

        this._quadsToDraw = itemsToRender;

        //shader stuff
        //this.setShaderProgram(cc.ShaderCache.getInstance().programForKey(kCCShader_PositionTexture_uColor));
        //this._uniformColor = glGetUniformLocation( this.getShaderProgram().getProgram(), "u_color");

        return true;

    },

    /** updates the Atlas (indexed vertex array).
     * Shall be overriden in subclasses
     */
    updateAtlasValues:function () {
        cc.Assert(false, "cc.AtlasNode:Abstract updateAtlasValue not overriden");
    },

    /**
     * @param {CanvasContext} ctx   CanvasContext
     */
    draw:function (ctx) {
        this._super();
        if (cc.renderContextType == cc.CANVAS) {

        } else {
            //TODO for WebGL
            //cc.NODE_DRAW_SETUP();

            //ccGLBlendFunc( this._blendFunc.src, this._blendFunc.dst );

            //var colors = [this._color.r / 255.0, this._color.g / 255.0, this._color.b / 255.0, this._opacity / 255.0];
            //this.getShaderProgram().setUniformLocationWith4fv(this._uniformColor, colors, 1);

            //this._textureAtlas.drawNumberOfQuads(this._quadsToDraw, 0);
        }
    },

    /** cc.AtlasNode - RGBA protocol
     * @return {cc.Color3B}
     */
    getColor:function () {
        if (this._isOpacityModifyRGB) {
            return this._colorUnmodified;
        }
        return this._color;
    },

    /**
     * @param {cc.Color3B} color3
     */
    setColor:function (color3) {
        if ((this._color.r == color3.r) && (this._color.g == color3.g) && (this._color.b == color3.b)) {
            return;
        }
        this._color = this._colorUnmodified = color3;

        if (this.getTexture()) {
            if (cc.renderContextType == cc.CANVAS) {
                var cacheTextureForColor = cc.TextureCache.getInstance().getTextureColors(this._originalTexture);
                if (cacheTextureForColor) {
                    var tx = this._originalTexture;
                    var textureRect = cc.rect(0, 0, tx.width, tx.height);
                    var colorTexture = cc.generateTintImage(tx, cacheTextureForColor, this._color, textureRect);
                    var img = new Image();
                    img.src = colorTexture.toDataURL();
                    this.setTexture(img);
                }
            }
        }

        if (this._isOpacityModifyRGB) {
            this._color.r = color3.r * this._opacity / 255;
            this._color.g = color3.g * this._opacity / 255;
            this._color.b = color3.b * this._opacity / 255;
        }
    },

    /**
     * @return {Number}
     */
    getOpacity:function () {
        return this._opacity;
    },

    /**
     * @param {Number} opacity
     */
    setOpacity:function (opacity) {
        this._opacity = opacity;
        // special opacity for premultiplied textures
        //if (this._isOpacityModifyRGB) {
        //    this.setColor(this._colorUnmodified);
        //}
    },

    /**
     * @param {Boolean} value
     */
    setOpacityModifyRGB:function (value) {
        var oldColor = this._color;
        this._isOpacityModifyRGB = value;
        this._color = oldColor;
    },

    /**
     * @return {Boolean}
     */
    isOpacityModifyRGB:function () {
        return this._isOpacityModifyRGB;
    },

    /** cc.AtlasNode - CocosNodeTexture protocol
     * @return {cc.BlendFunc}
     */
    getBlendFunc:function () {
        return this._blendFunc;
    },

    /**
     * @param {cc.BlendFunc} blendFunc
     */
    setBlendFunc:function (src, dst) {
        this._blendFunc = {src:src, dst:dst};
    },

    // cc.Texture protocol

    /** returns the used texture
     * @return {cc.Texture2D}
     */
    getTexture:function () {
        return this._textureAtlas.getTexture();
    },

    /** sets a new texture. it will be retained
     * @param {cc.Texture2D} texture
     */
    setTexture:function (texture) {
        this._textureAtlas.setTexture(texture);
        this._updateBlendFunc();
        this._updateOpacityModifyRGB();
    },

    /**
     * @param {cc.TextureAtlas} value
     */
    setTextureAtlas:function (value) {
        this._textureAtlas = value;
    },

    /**
     * @return {cc.TextureAtlas}
     */
    getTextureAtlas:function () {
        return this._textureAtlas;
    },

    /**
     * @return {Number}
     */
    getQuadsToDraw:function () {
        return this._quadsToDraw;
    },

    /**
     * @param {Number} quadsToDraw
     */
    setQuadsToDraw:function (quadsToDraw) {
        this._quadsToDraw = quadsToDraw;
    },

    _calculateMaxItems:function () {
        var size;
        if (this._textureAtlas.getTexture() instanceof cc.Texture2D) {
            size = this._textureAtlas.getTexture().getContentSize();
        }
        else {
            size = cc.size(this._textureAtlas.getTexture().width, this._textureAtlas.getTexture().height);
        }
        this._itemsPerColumn = parseInt(size.height / this._itemHeight);
        this._itemsPerRow = parseInt(size.width / this._itemWidth);
    },

    _updateBlendFunc:function () {
        /* if (!this._textureAtlas.getTexture().hasPremultipliedAlpha()) {
         this._blendFunc.src = gl.SRC_ALPHA;
         this._blendFunc.dst = gl.ONE_MINUS_SRC_ALPHA;
         }*/
    },

    _updateOpacityModifyRGB:function () {
        //this._isOpacityModifyRGB = this._textureAtlas.getTexture().hasPremultipliedAlpha();
    }

});

/** creates a cc.AtlasNode  with an Atlas file the width and height of each item and the quantity of items to render
 * @param {String} tile
 * @param {Number} tileWidth
 * @param {Number} tileHeight
 * @param {Number} itemsToRender
 * @return {cc.AtlasNode}
 * @example
 * // example
 * var node = cc.AtlasNode.create("pathOfTile", 16, 16, 1);
 */
cc.AtlasNode.create = function (tile, tileWidth, tileHeight, itemsToRender) {
    var ret = new cc.AtlasNode();
    if (ret.initWithTileFile(tile, tileWidth, tileHeight, itemsToRender)) {
        return ret;
    }
    return null;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
var cc = cc = cc || {};

//CONSTANTS:

/** @typedef CCTexture2DPixelFormat
 Possible texture pixel formats
 */
/*
 * Support for RGBA_4_4_4_4 and RGBA_5_5_5_1 was copied from:
 * https://devforums.apple.com/message/37855#37855 by a1studmuffin
 */
cc.TEXTURE_2D_PIXEL_FORMAT_AUTOMATIC = 0;
//! 32-bit texture: RGBA8888
cc.TEXTURE_2D_PIXEL_FORMAT_RGBA8888 = 1;
//! 24-bit texture: RGBA888
cc.TEXTURE_2D_PIXEL_FORMAT_RGB888 = 2;
//! 16-bit texture without Alpha channel
cc.TEXTURE_2D_PIXEL_FORMAT_RGB565 = 3;
//! 8-bit textures used as masks
cc.TEXTURE_2D_PIXEL_FORMAT_A8 = 4;
//! 8-bit intensity texture
cc.TEXTURE_2D_PIXEL_FORMAT_I8 = 5;
//! 16-bit textures used as masks
cc.TEXTURE_2D_PIXEL_FORMAT_AI88 = 6;
//! 16-bit textures: RGBA4444
cc.TEXTURE_2D_PIXEL_FORMAT_RGBA4444 = 7;
//! 16-bit textures: RGB5A1
cc.TEXTURE_2D_PIXEL_FORMAT_RGB5A1 = 8;
//! 4-bit PVRTC-compressed texture: PVRTC4
cc.TEXTURE_2D_PIXEL_FORMAT_PVRTC4 = 9;
//! 2-bit PVRTC-compressed texture: PVRTC2
cc.TEXTURE_2D_PIXEL_FORMAT_PVRTC2 = 10;

//! Default texture format: RGBA8888
cc.TEXTURE_2D_PIXEL_FORMAT_DEFAULT = cc.TEXTURE_2D_PIXEL_FORMAT_RGBA8888;

// backward compatibility stuff
cc.TEXTURE_2D_PIXEL_FORMAT_AUTOMATIC = cc.TEXTURE_2D_PIXEL_FORMAT_AUTOMATIC;
cc.TEXTURE_2D_PIXEL_FORMAT_RGBA8888 = cc.TEXTURE_2D_PIXEL_FORMAT_RGBA8888;
cc.TEXTURE_2D_PIXEL_FORMAT_RGB888 = cc.TEXTURE_2D_PIXEL_FORMAT_RGB888;
cc.TEXTURE_2D_PIXEL_FORMAT_RGB565 = cc.TEXTURE_2D_PIXEL_FORMAT_RGB565;
cc.TEXTURE_2D_PIXEL_FORMAT_A8 = cc.TEXTURE_2D_PIXEL_FORMAT_A8;
cc.TEXTURE_2D_PIXEL_FORMAT_RGBA4444 = cc.TEXTURE_2D_PIXEL_FORMAT_RGBA4444;
cc.TEXTURE_2D_PIXEL_FORMAT_RGB5A1 = cc.TEXTURE_2D_PIXEL_FORMAT_RGB5A1;
cc.TEXTURE_2D_PIXEL_FORMAT_DEFAULT = cc.TEXTURE_2D_PIXEL_FORMAT_DEFAULT;


if (cc.ENABLE_CACHE_TEXTTURE_DATA) {
    //TODO include CCTextureCache.h
}

// If the image has alpha, you can create RGBA8 (32-bit) or RGBA4 (16-bit) or RGB5A1 (16-bit)
// Default is: RGBA8888 (32-bit textures)
cc.g_defaultAlphaPixelFormat = cc.TEXTURE_2D_PIXEL_FORMAT_DEFAULT;
// By default PVR images are treated as if they don't have the alpha channel premultiplied
cc.PVRHaveAlphaPremultiplied_ = false;
/**
 Extension to set the Min / Mag filter
 */

function _ccTexParams(minFilter, magFilter, wrapS, wrapT) {
    this.minFilter = minFilter;
    this.magFilter = magFilter;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
}

//CLASS INTERFACES:

/** @brief cc.Texture2D class.
 * This class allows to easily create OpenGL 2D textures from images, text or raw data.
 * The created cc.Texture2D object will always have power-of-two dimensions.
 * Depending on how you create the cc.Texture2D object, the actual image area of the texture might be smaller than the texture dimensions i.e. "contentSize" != (pixelsWide, pixelsHigh) and (maxS, maxT) != (1.0, 1.0).
 * Be aware that the content of the generated textures will be upside-down!
 */
cc.Texture2D = cc.Class.extend({
    // By default PVR images are treated as if they don't have the alpha channel premultiplied
    _pVRHaveAlphaPremultiplied:null,
    _pixelFormat:null,
    _pixelsWide:null,
    _pixelsHigh:null,
    _name:null,
    _contentSize:null,
    _maxS:null,
    _maxT:null,
    _hasPremultipliedAlpha:null,

    /*public:*/
    ctor:function () {
        // implementation CCTexture2D (PVRTC);
        if (cc.SUPPORT_PVRTC) {
            /**
             Extensions to make it easy to create a cc.Texture2D object from a PVRTC file
             Note that the generated textures don't have their alpha premultiplied - use the blending mode (gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA).
             */
            /** Initializes a texture from a PVRTC buffer */
            this.initWithPVRTCData = function (data, level, bpp, hasAlpha, length, pixelFormat) {
                if (!(cc.Configuration.getInstance().isSupportsPVRTC())) {
                    cc.log("cocos2d: WARNING: PVRTC images is not supported.");
                    return false;
                }

                //TODO
                // glGenTextures(1, this._name);
                //TODO
                // glBindTexture(gl.TEXTURE_2D, this._name);

                this.setAntiAliasTexParameters();

                var format;
                var size = new cc.GLsizei();
                size = length * length * bpp / 8;
                if (hasAlpha) {
                    format = (bpp == 4) ? gl.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG : gl.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                } else {
                    format = (bpp == 4) ? gl.COMPRESSED_RGB_PVRTC_4BPPV1_IMG : gl.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                }
                if (size < 32) {
                    size = 32;
                }
                //TODO
                // glCompressedTexImage2D(gl.TEXTURE_2D, level, format, length, length, 0, size, data);

                this._contentSize = cc.size(length, length);
                this._pixelsWide = length;
                this._pixelsHigh = length;
                this._maxS = 1.0;
                this._maxT = 1.0;
                this._hasPremultipliedAlpha = cc.PVRHaveAlphaPremultiplied_;
                this._pixelFormat = pixelFormat;

                return true;
            };
        }// cc.SUPPORT_PVRTC
    },
    /** pixel format of the texture */
    getPixelFormat:function () {
        return this._pixelFormat;
    },
    //** width in pixels *//
    getPixelsWide:function () {
        return this._pixelsWide;
    },
    //** hight in pixels *//
    getPixelsHigh:function () {
        return this._pixelsHigh;
    },
    //** texture name *//
    getName:function () {
        return this._name;
    },
    //** content size *//
    getContentSizeInPixels:function () {
        var ret = cc.size(0, 0);
        ret.width = this._contentSize.width / cc.CONTENT_SCALE_FACTOR();
        ret.height = this._contentSize.height / cc.CONTENT_SCALE_FACTOR();

        return ret;
    },
    //** texture max S *//
    getMaxS:function () {
        return this._maxS;
    },
    setMaxS:function (maxS) {
        this._maxS = maxS;
    },
    //** texture max T *//
    getMaxT:function () {
        return this._maxT;
    },
    setMaxT:function (maxT) {
        this._maxT = maxT;
    },
    //** whether or not the texture has their Alpha premultiplied *//
    getHasPremultipliedAlpha:function () {
        return this._hasPremultipliedAlpha;
    },
    description:function () {
        var ret = "<cc.Texture2D | Name = " + this._name + " | Dimensions = " + this._pixelsWide + " x " + this._pixelsHigh
            + " | Coordinates = (" + this._maxS + ", " + this._maxT + ")>";
        return ret;
    },
    /** These functions are needed to create mutable textures */
    releaseData:function (data) {
        cc.free(data);
    },
    keepData:function (data, length) {
        //The texture data mustn't be saved becuase it isn't a mutable texture.
        return data;
    },

    /** Intializes with a texture2d with data */
    initWithData:function (pixelFormat, pixelsWide, pixelsHigh, contentSize) {
        //TODO
        // glPixelStorei(gl.UNPACK_ALIGNMENT,1);
        //TODO
        // glGenTextures(1, this._name);
        //TODO
        // glBindTexture(gl.TEXTURE_2D, this._name);

        this.setAntiAliasTexParameters();

        // Specify OpenGL texture image

        switch (pixelFormat) {
            case cc.TEXTURE_2D_PIXEL_FORMAT_RGBA8888:
                //TODO
                // glTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, (GLsizei)pixelsWide, (GLsizei)pixelsHigh, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
                break;
            case cc.TEXTURE_2D_PIXEL_FORMAT_RGB888:
                //TODO
                // glTexImage2D(gl.TEXTURE_2D, 0, gl.RGB, (GLsizei)pixelsWide, (GLsizei)pixelsHigh, 0, gl.RGB, gl.UNSIGNED_BYTE, data);
                break;
            case cc.TEXTURE_2D_PIXEL_FORMAT_RGBA4444:
                //TODO
                // glTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, (GLsizei)pixelsWide, (GLsizei)pixelsHigh, 0, gl.RGBA, gl.UNSIGNED_SHORT_4_4_4_4, data);
                break;
            case cc.TEXTURE_2D_PIXEL_FORMAT_RGB5A1:
                //TODO
                // glTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, (GLsizei)pixelsWide, (GLsizei)pixelsHigh, 0, gl.RGBA, gl.UNSIGNED_SHORT_5_5_5_1, data);
                break;
            case cc.TEXTURE_2D_PIXEL_FORMAT_RGB565:
                //TODO
                // glTexImage2D(gl.TEXTURE_2D, 0, gl.RGB, (GLsizei)pixelsWide, (GLsizei)pixelsHigh, 0, gl.RGB, gl.UNSIGNED_SHORT_5_6_5, data);
                break;
            case cc.TEXTURE_2D_PIXEL_FORMAT_AI88:
                //TODO
                // glTexImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE_ALPHA, (GLsizei)pixelsWide, (GLsizei)pixelsHigh, 0, gl.LUMINANCE_ALPHA, gl.UNSIGNED_BYTE, data);
                break;
            case cc.TEXTURE_2D_PIXEL_FORMAT_A8:
                //TODO
                // glTexImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, (GLsizei)pixelsWide, (GLsizei)pixelsHigh, 0, gl.ALPHA, gl.UNSIGNED_BYTE, data);
                break;
            default:
                cc.Assert(0, "NSInternalInconsistencyException");

        }

        this._contentSize = contentSize;
        this._pixelsWide = pixelsWide;
        this._pixelsHigh = pixelsHigh;
        this._pixelFormat = pixelFormat;
        this._maxS = contentSize.width / pixelsWide;
        this._maxT = contentSize.height / pixelsHigh;

        this._hasPremultipliedAlpha = false;

        return true;
    },

    /**
     Drawing extensions to make it easy to draw basic quads using a CCTexture2D object.
     These functions require gl.TEXTURE_2D and both gl.VERTEX_ARRAY and gl.TEXTURE_COORD_ARRAY client states to be enabled.
     */
    /** draws a texture at a given point */
    drawAtPoint:function (point) {
        var coordinates = [
            0.0, this._maxT,
            this._maxS, this._maxT,
            0.0, 0.0,
            this._maxS, 0.0 ];

        var width = this._pixelsWide * this._maxS,
            height = this._pixelsHigh * this._maxT;

        var vertices = [
            point.x, point.y, 0.0,
            width + point.x, point.y, 0.0,
            point.x, height + point.y, 0.0,
            width + point.x, height + point.y, 0.0 ];

        //TODO
        // glBindTexture(gl.TEXTURE_2D, this._name);
        //TODO
        // glVertexPointer(3, gl.FLOAT, 0, vertices);
        //TODO
        // glTexCoordPointer(2, gl.FLOAT, 0, coordinates);
        //TODO
        // glDrawArrays(gl.TRIANGLE_STRIP, 0, 4);
    },

    /** draws a texture inside a rect */
    drawInRect:function (rect) {
        var coordinates = [
            0.0, this._maxT,
            this._maxS, this._maxT,
            0.0, 0.0,
            this._maxS, 0.0];

        var vertices = [    rect.origin.x, rect.origin.y, /*0.0,*/
            rect.origin.x + rect.size.width, rect.origin.y, /*0.0,*/
            rect.origin.x, rect.origin.y + rect.size.height, /*0.0,*/
            rect.origin.x + rect.size.width, rect.origin.y + rect.size.height        /*0.0*/ ];

        //TODO
        // glBindTexture(gl.TEXTURE_2D, this._name);
        //TODO
        // glVertexPointer(2, gl.FLOAT, 0, vertices);
        //TODO
        // glTexCoordPointer(2, gl.FLOAT, 0, coordinates);
        //TODO
        // glDrawArrays(gl.TRIANGLE_STRIP, 0, 4);
    },

    /**
     Extensions to make it easy to create a CCTexture2D object from an image file.
     Note that RGBA type textures will have their alpha premultiplied - use the blending mode (gl.ONE, gl.ONE_MINUS_SRC_ALPHA).
     */
    /** Initializes a texture from a UIImage object */
    initWithImage:function (uiImage) {
        var POTWide, POTHigh;

        if (uiImage == null) {
            cc.log("cocos2d: cc.Texture2D. Can't create Texture. UIImage is nil");
            return false;
        }

        var conf = cc.Configuration.getInstance();

        if (cc.TEXTURE_NPOT_SUPPORT) {
            if (conf.isSupportsNPOT()) {
                POTWide = uiImage.getWidth();
                POTHigh = uiImage.getHeight();
            }
        } else {
            POTWide = cc.NextPOT(uiImage.getWidth());
            POTHigh = cc.NextPOT(uiImage.getHeight());
        }


        var maxTextureSize = conf.getMaxTextureSize();
        if (POTHigh > maxTextureSize || POTWide > maxTextureSize) {
            cc.log("cocos2d: WARNING: Image (%u x %u) is bigger than the supported %u x %u", POTWide, POTHigh, maxTextureSize, maxTextureSize);
            return null;
        }

        // always load premultiplied images
        return this._initPremultipliedATextureWithImage(uiImage, POTWide, POTHigh);
    },

    /**
     Extensions to make it easy to create a cc.Texture2D object from a string of text.
     Note that the generated textures are of type A8 - use the blending mode (gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA).
     */
    /** Initializes a texture from a string with dimensions, alignment, font name and font size */
    initWithString:function (text, dimensions, alignment, fontName, fontSize) {
        if (arguments.length == 3) {
            fontName = arguments[1];
            fontSize = arguments[2];
            dimensions = cc.size(0, 0);
            alignment = cc.TEXT_ALIGNMENT_CENTER;
        }
        if (cc.ENABLE_CACHE_TEXTTURE_DATA) {
            // cache the texture data
            cc.VolatileTexture.addStringTexture(this, text, dimensions, alignment, fontName, fontSize);
        }
        var image = new cc.Image();
        eAlign = new cc.Image.ETextAlign();
        eAlign = (cc.TEXT_ALIGNMENT_CENTER == alignment) ? cc.Image.ALIGN_CENTER : (cc.TEXT_ALIGNMENT_LEFT == alignment) ? cc.Image.ALIGN_LEFT : cc.Image.ALIGN_RIGHT;

        if (!image.initWithString(text, dimensions.width, dimensions.height, eAlign, fontName, fontSize)) {
            return false;
        }
        return this.initWithImage(image);
    },

    /** Initializes a texture from a PVR file */
    initWithPVRFile:function (file) {
        var ret = false;
        // nothing to do with cc.Object.init

        var pvr = new cc.TexturePVR;
        ret = pvr.initWithContentsOfFile(file);

        if (ret) {
            pvr.setRetainName(true); // don't dealloc texture on release

            this._name = pvr.getName();
            this._maxS = 1.0;
            this._maxT = 1.0;
            this._pixelsWide = pvr.getWidth();
            this._pixelsHigh = pvr.getHeight();
            this._contentSize = cc.size(this._pixelsWide, this._pixelsHigh);
            this._hasPremultipliedAlpha = cc.PVRHaveAlphaPremultiplied_;
            this._pixelFormat = pvr.getFormat();

            this.setAntiAliasTexParameters();
        }
        else {
            cc.log("cocos2d: Couldn't load PVR image %s", file);
        }

        return ret;
    },

    /** sets the min filter, mag filter, wrap s and wrap t texture parameters.
     If the texture size is NPOT (non power of 2), then in can only use gl.CLAMP_TO_EDGE in gl.TEXTURE_WRAP_{S,T}.
     @since v0.8
     */
    setTexParameters:function (texParams) {
        cc.Assert((this._pixelsWide == cc.NextPOT(this._pixelsWide) && this._pixelsHigh == cc.NextPOT(this._pixelsHigh)) ||
            (texParams.wrapS == gl.CLAMP_TO_EDGE && texParams.wrapT == gl.CLAMP_TO_EDGE),
            "gl.CLAMP_TO_EDGE should be used in NPOT textures");
        //TODO
        // BindTexture( gl.TEXTURE_2D, this.this._name );
        //TODO
        // glTexParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texParams.minFilter );
        //TODO
        // glTexParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texParams.magFilter );
        //TODO
        // glTexParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, texParams.wrapS );
        //TODO
        // glTexParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, texParams.wrapT );
    },

    /** sets antialias texture parameters:
     - gl.TEXTURE_MIN_FILTER = gl.LINEAR
     - gl.TEXTURE_MAG_FILTER = gl.LINEAR

     @since v0.8
     */
    setAntiAliasTexParameters:function () {
        var texParams = [ gl.LINEAR, gl.LINEAR, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE ];
        this.setTexParameters(texParams);
    },

    /** sets alias texture parameters:
     - gl.TEXTURE_MIN_FILTER = gl.NEAREST
     - gl.TEXTURE_MAG_FILTER = gl.NEAREST

     @since v0.8
     */
    setAliasTexParameters:function () {
        var texParams = [ gl.NEAREST, gl.NEAREST, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE ];
        this.setTexParameters(texParams);
    },


    /** Generates mipmap images for the texture.
     It only works if the texture size is POT (power of 2).
     @since v0.99.0
     */
    generateMipmap:function () {
        cc.Assert(this._pixelsWide == cc.NextPOT(this._pixelsWide) && this._pixelsHigh == cc.NextPOT(this._pixelsHigh), "Mimpap texture only works in POT textures");
        //TODO
        // glBindTexture( gl.TEXTURE_2D, this.this._name );
        //cc.glGenerateMipmap(gl.TEXTURE_2D);
    },

    /** returns the bits-per-pixel of the in-memory OpenGL texture
     @since v1.0
     */
    bitsPerPixelForFormat:function () {
        var ret = 0;

        switch (this._pixelFormat) {
            case cc.TEXTURE_2D_PIXEL_FORMAT_RGBA8888:
                ret = 32;
                break;
            case cc.TEXTURE_2D_PIXEL_FORMAT_RGB565:
                ret = 16;
                break;
            case cc.TEXTURE_2D_PIXEL_FORMAT_A8:
                ret = 8;
                break;
            case cc.TEXTURE_2D_PIXEL_FORMAT_RGBA4444:
                ret = 16;
                break;
            case cc.TEXTURE_2D_PIXEL_FORMAT_RGB5A1:
                ret = 16;
                break;
            case cc.TEXTURE_2D_PIXEL_FORMAT_PVRTC4:
                ret = 4;
                break;
            case cc.TEXTURE_2D_PIXEL_FORMAT_PVRTC2:
                ret = 2;
                break;
            case cc.TEXTURE_2D_PIXEL_FORMAT_I8:
                ret = 8;
                break;
            case cc.TEXTURE_2D_PIXEL_FORMAT_AI88:
                ret = 16;
                break;
            case cc.TEXTURE_2D_PIXEL_FORMAT_RGB888:
                ret = 24;
                break;
            default:
                ret = -1;
                cc.Assert(false, "illegal pixel format");
                cc.log("bitsPerPixelForFormat: %d, cannot give useful result", this._pixelFormat);
                break;
        }
        return ret;
    },


    /*private:*/
    _initPremultipliedATextureWithImage:function (image, POTWide, POTHigh) {
        var data = null;
        var tempData = null;
        var inPixel32 = null;
        var outPixel16 = null;
        var hasAlpha;
        var imageSize = cc.size(0, 0);
        var pixelFormat = new cc.Texture2DPixelFormat();
        var bpp = new cc.size_t();
        hasAlpha = image.hasAlpha();
        bpp = image.getBitsPerComponent();

        // compute pixel format
        if (hasAlpha) {
            pixelFormat = cc.g_defaultAlphaPixelFormat;
        }
        else {
            if (bpp >= 8) {
                pixelFormat = cc.TEXTURE_2D_PIXEL_FORMAT_RGB888;
            }
            else {
                cc.log("cocos2d: cc.Texture2D: Using RGB565 texture since image has no alpha");
                pixelFormat = cc.TEXTURE_2D_PIXEL_FORMAT_RGB565;
            }
        }


        imageSize = cc.size(image.getWidth(), image.getHeight());

        switch (pixelFormat) {
            case cc.TEXTURE_2D_PIXEL_FORMAT_RGBA8888:
            case cc.TEXTURE_2D_PIXEL_FORMAT_RGBA4444:
            case cc.TEXTURE_2D_PIXEL_FORMAT_RGB5A1:
            case cc.TEXTURE_2D_PIXEL_FORMAT_RGB565:
            case cc.TEXTURE_2D_PIXEL_FORMAT_A8:
                tempData = image.getData();
                cc.Assert(tempData != null, "null image data.");

                if (image.getWidth() == POTWide && image.getHeight() == POTHigh) {
                    data = new (POTHigh * POTWide * 4);
                    cc.memcpy(data, tempData, POTHigh * POTWide * 4);
                }
                else {
                    data = new (POTHigh * POTWide * 4);

                    var pPixelData = tempData;
                    var pTargetData = data;

                    var imageHeight = image.getHeight();
                    for (var y = 0; y < imageHeight; ++y) {
                        cc.memcpy(pTargetData + POTWide * 4 * y, pPixelData + (image.getWidth()) * 4 * y, (image.getWidth()) * 4);
                    }
                }

                break;
            case cc.TEXTURE_2D_PIXEL_FORMAT_RGB888:
                tempData = image.getData();
                cc.Assert(tempData != null, "null image data.");
                if (image.getWidth() == POTWide && image.getHeight() == POTHigh) {
                    data = new (POTHigh * POTWide * 3);
                    cc.memcpy(data, tempData, POTHigh * POTWide * 3);
                }
                else {
                    data = new (POTHigh * POTWide * 3);

                    var pPixelData = tempData;
                    var pTargetData = data;

                    var imageHeight = image.getHeight();
                    for (var y = 0; y < imageHeight; ++y) {
                        cc.memcpy(pTargetData + POTWide * 3 * y, pPixelData + (image.getWidth()) * 3 * y, (image.getWidth()) * 3);
                    }
                }
                break;
            default:
                cc.Assert(0, "Invalid pixel format");
        }

        // Repack the pixel data into the right format

        if (pixelFormat == cc.TEXTURE_2D_PIXEL_FORMAT_RGB565) {
            //Convert "RRRRRRRRRGGGGGGGGBBBBBBBBAAAAAAAA" to "RRRRRGGGGGGBBBBB"
            tempData = new (POTHigh * POTWide * 2);
            inPixel32 = data;
            outPixel16 = tempData;

            var length = POTWide * POTHigh;
            for (var i = 0; i < length; ++i, ++inPixel32) {
                outPixel16++;
                outPixel16 =
                    ((((inPixel32 >> 0) & 0xFF) >> 3) << 11) | // R
                        ((((inPixel32 >> 8) & 0xFF) >> 2) << 5) | // G
                        ((((inPixel32 >> 16) & 0xFF) >> 3) << 0);   // B
            }

            delete data;
            data = tempData;
        }
        else if (pixelFormat == cc.TEXTURE_2D_PIXEL_FORMAT_RGBA4444) {
            //Convert "RRRRRRRRRGGGGGGGGBBBBBBBBAAAAAAAA" to "RRRRGGGGBBBBAAAA"
            tempData = new (POTHigh * POTWide * 2);
            inPixel32 = data;
            outPixel16 = tempData;

            var length = POTWide * POTHigh;
            for (var i = 0; i < length; ++i, ++inPixel32) {
                outPixel16++;
                outPixel16 =
                    ((((inPixel32 >> 0) & 0xFF) >> 4) << 12) | // R
                        ((((inPixel32 >> 8) & 0xFF) >> 4) << 8) | // G
                        ((((inPixel32 >> 16) & 0xFF) >> 4) << 4) | // B
                        ((((inPixel32 >> 24) & 0xFF) >> 4) << 0); // A
            }

            delete data;
            data = tempData;
        }
        else if (pixelFormat == cc.TEXTURE_2D_PIXEL_FORMAT_RGB5A1) {
            //Convert "RRRRRRRRRGGGGGGGGBBBBBBBBAAAAAAAA" to "RRRRRGGGGGBBBBBA"
            tempData = new (POTHigh * POTWide * 2);
            inPixel32 = data;
            outPixel16 = tempData;

            var length = POTWide * POTHigh;
            for (var i = 0; i < length; ++i, ++inPixel32) {
                outPixel16++;
                outPixel16 =
                    ((((inPixel32 >> 0) & 0xFF) >> 3) << 11) | // R
                        ((((inPixel32 >> 8) & 0xFF) >> 3) << 6) | // G
                        ((((inPixel32 >> 16) & 0xFF) >> 3) << 1) | // B
                        ((((inPixel32 >> 24) & 0xFF) >> 7) << 0); // A
            }

            delete data;
            data = tempData;
        }
        else if (pixelFormat == cc.TEXTURE_2D_PIXEL_FORMAT_A8) {
            // fix me, how to convert to A8
            pixelFormat = cc.TEXTURE_2D_PIXEL_FORMAT_RGBA8888;

            /*
             * The code can not work, how to convert to A8?
             *
             tempData = new unsigned char[POTHigh * POTWide];
             inPixel32 = (unsigned int*)data;
             outPixel8 = tempData;

             unsigned int length = POTWide * POTHigh;
             for(unsigned int i = 0; i < length; ++i, ++inPixel32)
             {
             outPixel8++ = (inPixel32 >> 24) & 0xFF;
             }

             delete []data;
             data = tempData;
             */
        }

        if (data) {
            this.initWithData(data, pixelFormat, POTWide, POTHigh, imageSize);

            // should be after calling super init
            this._hasPremultipliedAlpha = image.isPremultipliedAlpha();

            //CGContextRelease(context);
            delete data;
        }
        return true;
    }
});

/** sets the default pixel format for UIImagescontains alpha channel.
 If the UIImage contains alpha channel, then the options are:
 - generate 32-bit textures: cc.TEXTURE_2D_PIXEL_FORMAT_RGBA8888 (default one)
 - generate 24-bit textures: cc.TEXTURE_2D_PIXEL_FORMAT_RGB888
 - generate 16-bit textures: cc.TEXTURE_2D_PIXEL_FORMAT_RGBA4444
 - generate 16-bit textures: cc.TEXTURE_2D_PIXEL_FORMAT_RGB5A1
 - generate 16-bit textures: cc.TEXTURE_2D_PIXEL_FORMAT_RGB565
 - generate 8-bit textures: cc.TEXTURE_2D_PIXEL_FORMAT_A8 (only use it if you use just 1 color)

 How does it work ?
 - If the image is an RGBA (with Alpha) then the default pixel format will be used (it can be a 8-bit, 16-bit or 32-bit texture)
 - If the image is an RGB (without Alpha) then an RGB565 or RGB888 texture will be used (16-bit texture)

 @since v0.8
 */
cc.Texture2D.setDefaultAlphaPixelFormat = function (format) {
    cc.g_defaultAlphaPixelFormat = format;
};

/** returns the alpha pixel format
 @since v0.8
 */
cc.Texture2D.defaultAlphaPixelFormat = function () {
    return cc.g_defaultAlphaPixelFormat;
};

/** treats (or not) PVR files as if they have alpha premultiplied.
 Since it is impossible to know at runtime if the PVR images have the alpha channel premultiplied, it is
 possible load them as if they have (or not) the alpha channel premultiplied.

 By default it is disabled.

 @since v0.99.5
 */
cc.Texture2D.PVRImagesHavePremultipliedAlpha = function (haveAlphaPremultiplied) {
    cc.PVRHaveAlphaPremultiplied_ = haveAlphaPremultiplied;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * TextureCache - Alloc, Init & Dealloc
 * @type object
 */
cc.g_sharedTextureCache = null;

/**
 * Load the images to the cache
 * @param {String} imageUrl
 */
cc.loadImage = function (imageUrl) {
    // compute image type
    var imageType = cc.computeImageFormatType(imageUrl);
    if (imageType == cc.FMT_UNKNOWN) {
        cc.log("unsupported format" + imageUrl);
        return;
    }
    var image = new Image();
    image.src = imageUrl;
    image.onLoad = function (e) {
        cc.TextureCache.getInstance().cacheImage(imageUrl, image);
    };
};

/**
 *  Support image format type
 * @param {String} filename
 * @return {Number}
 */
cc.computeImageFormatType = function (filename) {
    if (filename.toLowerCase().indexOf('.jpg') > 0 || filename.toLowerCase().indexOf('.jpeg') > 0) {
        return cc.FMT_JPG;
    } else if (filename.indexOf('.png') > 0 || filename.indexOf('.PNG') > 0) {
        return cc.FMT_PNG;
    }
    return cc.FMT_UNKNOWN;
};

/**
 *  Implementation TextureCache
 * @class
 * @extends cc.Class
 */
cc.TextureCache = cc.Class.extend(/** @lends cc.TextureCache# */{
    textures:{},
    _textureColorsCache:{},

    /**
     * Constructor
     */
    ctor:function () {
        cc.Assert(cc.g_sharedTextureCache == null, "Attempted to allocate a second instance of a singleton.");
    },

    /**
     *  Loading the images asynchronously
     * @param {String} path
     * @param {cc.Node} target
     * @param {Function} selector
     * @return {Image}
     * @example
     * //example
     * cc.TextureCache.getInstance().addImageAsync("hello.png", this, this.loadingCallBack);
     */
    addImageAsync:function (path, target, selector) {
        cc.Assert(path != null, "TextureCache: path MUST not be null");
        var texture = this.textures[path.toString()];

        if (texture) {
            this._addImageAsyncCallBack(target, selector);
        }
        else {
            texture = new Image();
            var that = this;
            texture.addEventListener("load", function () {
                that._addImageAsyncCallBack(target, selector);
            });
            texture.src = path;
            this.textures[path.toString()] = texture;
        }

        if (cc.renderContextType == cc.CANVAS) {
            return this.textures[path.toString()];
        } else {
            //todo texure for gl
        }
    },
    _addImageAsyncCallBack:function (target, selector) {
        if (target && (typeof(selector) == "string")) {
            target[selector]();
        } else if (target && (typeof(selector) == "function")) {
            selector.call(target);
        }
    },

    /**
     * AddPVRTCImage does not support
     */
    addPVRTCImage:function () {
        cc.Assert(0, "TextureCache:addPVRTCImage does not support");
    },

    /**
     * Description
     * @return {String}
     */
    description:function () {
        return "<TextureCache | Number of textures = " + this.textures.length + ">";
    },

    /**
     * <p>Returns a Texture2D object given an file image <br />
     * If the file image was not previously loaded, it will create a new Texture2D <br />
     *  object and it will return it. It will use the filename as a key.<br />
     * Otherwise it will return a reference of a previously loaded image. <br />
     * Supported image extensions: .png, .jpg, .gif</p>
     * @param {String} path
     * @return {Image}
     * @example
     * //example
     * cc.TextureCache.getInstance().addImage("hello.png");
     */
    addImage:function (path) {
        cc.Assert(path != null, "TextureCache: path MUST not be null");
        var texture = this.textures[path.toString()];
        if (texture) {
            cc.Loader.shareLoader().onResLoaded();
        }
        else {
            texture = new Image();
            var that = this;
            texture.addEventListener("load", function () {

                cc.Loader.shareLoader().onResLoaded();
            });
            texture.addEventListener("error", function () {
                cc.Loader.shareLoader().onResLoadingErr(path);
            });
            texture.src = path;
            this.textures[path.toString()] = texture;
        }

        if (cc.renderContextType == cc.CANVAS) {
            return this.textures[path.toString()];
        } else {
            //todo texture for gl
        }
    },

    /**
     *  Cache the image data
     * @param {String} path
     * @param {Image} texture
     */
    cacheImage:function (path, texture) {
        if (!this.textures[path.toString()]) {
            this.textures[path.toString()] = texture;
        }
    },

    /**
     * <p>Returns a Texture2D object given an UIImage image<br />
     * If the image was not previously loaded, it will create a new Texture2D object and it will return it.<br />
     * Otherwise it will return a reference of a previously loaded image<br />
     * The "key" parameter will be used as the "key" for the cache.<br />
     * If "key" is null, then a new texture will be created each time.</p>
     * @param {Image} image
     * @param {String} key
     * @return {cc.Texture2D}
     */
    addUIImage:function (image, key) {
        cc.Assert(image != null, "TextureCache: image MUST not be nulll");

        var texture = null;

        if (key) {
            if (this.textures.hasOwnProperty(key)) {
                texture = this.textures[key];
                if (texture) {
                    return texture;
                }
            }
        }

        // prevents overloading the autorelease pool
        texture = new cc.Texture2D();
        texture.initWithImage(image);

        if ((key != null) && (texture != null)) {
            this.textures[key] = texture;
        } else {
            cc.log("cocos2d: Couldn't add UIImage in TextureCache");
        }

        return texture;
    },

    /**
     * Returns an already created texture. Returns null if the texture doesn't exist.
     * @param {String} key
     * @return {Image|Null}
     * @example
     * //example
     * var key = cc.TextureCache.getInstance().textureForKey("hello.png");
     */
    textureForKey:function (key) {
        if (this.textures.hasOwnProperty(key)) {
            return this.textures[key];
        } else {
            return null;
        }
    },

    /**
     * @param {Image} texture
     * @return {String|Null}
     * @example
     * //example
     * var key = cc.TextureCache.getInstance().getKeyByTexture(texture);
     */
    getKeyByTexture:function (texture) {
        for (var key in this.textures) {
            if (this.textures[key] == texture) {
                return key;
            }
        }
        return null;
    },

    /**
     * @param {Image} texture
     * @return {Array}
     * @example
     * //example
     * var cacheTextureForColor = cc.TextureCache.getInstance().getTextureColors(texture);
     */
    getTextureColors:function (texture) {
        var key = this.getKeyByTexture(texture);
        if (key) {
            if (texture instanceof HTMLImageElement) {
                key = texture.src;
            } else {
                return null;
            }
        }

        if (!this._textureColorsCache.hasOwnProperty(key)) {
            this._textureColorsCache[key] = cc.generateTextureCacheForColor(texture);
        }
        return this._textureColorsCache[key];
    },

    /**
     * <p>Purges the dictionary of loaded textures. <br />
     * Call this method if you receive the "Memory Warning"  <br />
     * In the short term: it will free some resources preventing your app from being killed  <br />
     * In the medium term: it will allocate more resources <br />
     * In the long term: it will be the same</p>
     * @example
     * //example
     * cc.TextureCache.getInstance().removeAllTextures();
     */
    removeAllTextures:function () {
        this.textures = {};
    },

    /**
     * Deletes a texture from the cache given a texture
     * @param {Image} texture
     * @example
     * //example
     * cc.TextureCache.getInstance().removeTexture(texture);
     */
    removeTexture:function (texture) {
        if (!texture)
            return;

        for (var key in this.textures) {
            if (this.textures[key] == texture) {
                delete(this.textures[key]);
                return;
            }
        }
    },

    /**
     * Deletes a texture from the cache given a its key name
     * @param {String} textureKeyName
     * @example
     * //example
     * cc.TextureCache.getInstance().removeTexture("hello.png");
     */
    removeTextureForKey:function (textureKeyName) {
        if (textureKeyName == null) {
            return;
        }
        if (this.textures[textureKeyName]) {
            delete(this.textures[textureKeyName]);
        }
    },

    /**
     * <p>Output to cc.log the current contents of this TextureCache <br />
     * This will attempt to calculate the size of each texture, and the total texture memory in use. </p>
     */
    dumpCachedTextureInfo:function () {
        var count = 0;
        var totalBytes = 0;
        for (var key in this.textures) {
            var tex = this.textures[key];
            var bpp = tex.bitsPerPixelForFormat();
            // Each texture takes up width * height * bytesPerPixel bytes.
            var bytes = tex.getPixelsWide() * tex.getPixelsHigh() * bpp / 8;
            totalBytes += bytes;
            count++;
            cc.log("cocos2d: '" + tex.toString() + "' id=" + tex.getName() + " " + tex.getPixelsWide() + " x " + tex.getPixelsHigh() + " @ " + bpp + " bpp => " + bytes / 1024 + " KB");
        }

        cc.log("cocos2d: TextureCache dumpDebugInfo: " + count + " textures, for " + (totalBytes / 1024) + " KB (" + (totalBytes / (1024.0 * 1024.0)).toFixed(2) + " MB)");
    },

    /**
     * <p>Returns a Texture2D object given an PVR filename<br />
     * If the file image was not previously loaded, it will create a new Texture2D<br />
     *  object and it will return it. Otherwise it will return a reference of a previously loaded image </p>
     * @param {String} path
     * @return {cc.Texture2D}
     */
    addPVRImage:function (path) {
        cc.Assert(path != null, "TextureCache: file image MUST not be null");

        var key = path;

        if (this.textures[key] != null) {
            return this.textures[key];
        }

        // Split up directory and filename
        var tex = new cc.Texture2D();
        if (tex.initWithPVRFile(key)) {
            this.textures[key] = tex;
        } else {
            cc.log("cocos2d: Couldn't add PVRImage:" + key + " in TextureCache");
        }

        return tex;
    }
});

/**
 * Return ths shared instance of the cache
 * @return {cc.TextureCache}
 */
cc.TextureCache.getInstance = function () {
    if (!cc.g_sharedTextureCache)
        cc.g_sharedTextureCache = new cc.TextureCache();
    return cc.g_sharedTextureCache;
};

/**
 * Purges the cache. It releases the retained instance.
 */
cc.TextureCache.purgeSharedTextureCache = function () {
    cc.g_sharedTextureCache = null;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/


/**
 * <p>A class that implements a Texture Atlas. <br />
 * Supported features: <br />
 * The atlas file can be a PNG, JPG. <br />
 * Quads can be updated in runtime <br />
 * Quads can be added in runtime <br />
 * Quads can be removed in runtime <br />
 * Quads can be re-ordered in runtime <br />
 * The TextureAtlas capacity can be increased or decreased in runtime.</p>
 * @class
 * @extends cc.Class
 */
cc.TextureAtlas = cc.Class.extend(/** @lends cc.TextureAtlas# */{
    _indices:[],
    //0: vertex  1: indices
    _buffersVBO:[0, 1],
    //indicates whether or not the array buffer of the VBO needs to be updated
    _dirty:false,
    _capacity:0,
    _texture:null,
    _quads:[],
    /**
     * Quantity of quads that are going to be drawn.
     * @return {Number}
     */
    getTotalQuads:function () {
        return this._quads.length;
    },

    /**
     * Quantity of quads that can be stored with the current texture atlas size
     * @return {Number}
     */
    getCapacity:function () {
        return this._capacity;
    },

    /**
     * Texture of the texture atlas
     * @return {Image}
     */
    getTexture:function () {
        return this._texture;
    },

    /**
     * @param {Image} texture
     */
    setTexture:function (texture) {
        this._texture = texture;
    },

    /**
     * Quads that are going to be rendered
     * @return {Array}
     */
    getQuads:function () {
        return this._quads;
    },

    /**
     * @param {Array} quads
     */
    setQuads:function (quads) {
        this._quads = quads;
    },

    /**
     * Description
     * @return {String}
     */
    description:function () {
        return '<CCTextureAtlas | totalQuads =' + this._totalQuads + '>';
    },
    _initIndices:function () {
        if (this._capacity == 0)
            return;

        for (var i = 0; i < this._capacity; i++) {
            this._indices[i * 6 + 0] = i * 4 + 0;
            this._indices[i * 6 + 1] = i * 4 + 0;
            this._indices[i * 6 + 2] = i * 4 + 2;
            this._indices[i * 6 + 3] = i * 4 + 1;
            this._indices[i * 6 + 4] = i * 4 + 3;
            this._indices[i * 6 + 5] = i * 4 + 3;
        }
    },

    /**
     * <p>Initializes a TextureAtlas with a filename and with a certain capacity for Quads.<br />
     * The TextureAtlas capacity can be increased in runtime.<br />
     * WARNING: Do not reinitialize the TextureAtlas because it will leak memory. </p>
     * @param {String} file
     * @param {Number} capacity
     * @return {Boolean|Null}
     * @example
     * //example
     * var textureAtlas = new cc.TextureAtlas();
     * textureAtlas.initWithTexture("hello.png", 3);
     */
    initWithFile:function (file, capacity) {
        // retained in property
        var texture = cc.TextureCache.getInstance().addImage(file);

        if (texture) {
            return this.initWithTexture(texture, capacity);
        } else {
            cc.log("cocos2d: Could not open file: " + file);
            return null;
        }
    },

    /**
     * <p>Initializes a TextureAtlas with a previously initialized Texture2D object, and<br />
     * with an initial capacity for Quads.<br />
     * The TextureAtlas capacity can be increased in runtime.<br />
     * WARNING: Do not reinitialize the TextureAtlas because it will leak memory</p>
     * @param {Image} texture
     * @param {Number} capacity
     * @return {Boolean}
     * @example
     * //example
     * var texture = cc.TextureCache.getInstance().addImage("hello.png");
     * var textureAtlas = new cc.TextureAtlas();
     * textureAtlas.initWithTexture(texture, 3);
     */
    initWithTexture:function (texture, capacity) {
        cc.Assert(texture != null, "TextureAtlas.initWithTexture():texture should not be null");
        this._capacity = capacity;

        // retained in property
        this._texture = texture;

        // Re-initialization is not allowed
        cc.Assert(this._quads.length == 0 && this._indices.length == 0, "TextureAtlas.initWithTexture():_quads and _indices should not be null");

        //TODO init array
        this._quads = [];
        this._indices = [];

        if (!( this._quads && this._indices) && this._capacity > 0) {
            return false;
        }

        this._dirty = true;
        this._initIndices();
        return true;
    },

    /**
     * <p>Updates a Quad (texture, vertex and color) at a certain index <br />
     * index must be between 0 and the atlas capacity - 1 </p>
     * @param {cc.V2F_C4B_T2F_Quad} quad
     * @param {Number} index
     */
    updateQuad:function (quad, index) {
        this._quads[index] = quad;
        this._dirty = true;
    },

    /**
     * <p>Inserts a Quad (texture, vertex and color) at a certain index<br />
     * index must be between 0 and the atlas capacity - 1 </p>
     * @param {cc.V2F_C4B_T2F_Quad} quad
     * @param {Number} index
     */
    insertQuad:function (quad, index) {
        this._quads = cc.ArrayAppendObjectToIndex(this._quads, quad, index);
        this._dirty = true;
    },

    /**
     * <p>Removes the quad that is located at a certain index and inserts it at a new index <br />
     * This operation is faster than removing and inserting in a quad in 2 different steps</p>
     * @param {Number} fromIndex
     * @param {Number} newIndex
     */
    insertQuadFromIndex:function (fromIndex, newIndex) {
        if (fromIndex == newIndex)
            return;

        var quad = this._quads[fromIndex];
        cc.ArrayRemoveObjectAtIndex(this._quads, fromIndex);
        if (fromIndex > newIndex) {
            this._quads = cc.ArrayAppendObjectToIndex(this._quads, quad, newIndex);
        } else {
            this._quads = cc.ArrayAppendObjectToIndex(this._quads, quad, newIndex - 1);
        }

        this._dirty = true;
    },

    /**
     * <p>Removes a quad at a given index number.<br />
     * The capacity remains the same, but the total number of quads to be drawn is reduced in 1 </p>
     * @param {Number} index
     */
    removeQuadAtIndex:function (index) {
        cc.ArrayRemoveObjectAtIndex(this._quads, index);

        this._dirty = true;
    },

    /**
     * <p>Removes all Quads. <br />
     * The TextureAtlas capacity remains untouched. No memory is freed.<br />
     * The total number of quads to be drawn will be 0</p>
     */
    removeAllQuads:function () {
        this._quads.length = 0;
    },

    /**
     * <p>Resize the capacity of the CCTextureAtlas.<br />
     * The new capacity can be lower or higher than the current one<br />
     * It returns YES if the resize was successful. <br />
     * If it fails to resize the capacity it will return NO with a new capacity of 0. <br />
     * no used for js</p>
     * @param {Number} newCapacity
     * @return {Boolean}
     */
    resizeCapacity:function (newCapacity) {
        if (newCapacity == this._capacity) {
            return true;
        }

        this._totalQuads = Math.min(this._totalQuads, newCapacity);
        this._capacity = newCapacity;

        return true;
    },

    /**
     * <p>Draws n quads from an index (offset). <br />
     * n + start can't be greater than the capacity of the atlas</p>
     * @param {Number} n
     * @param {Number} start
     */
    drawNumberOfQuads:function (n, start) {
        if (0 == n)
            return;
    },
    /**
     * Draws all the Atlas's Quads
     */
    drawQuads:function () {
        this.drawNumberOfQuads(this._quads.length, 0);
    }
});

/**
 * <p>Creates a TextureAtlas with an filename and with an initial capacity for Quads. <br />
 * The TextureAtlas capacity can be increased in runtime. </p>
 * @param {String} file
 * @param {Number} capacity
 * @return {cc.TextureAtlas|Null}
 * @example
 * //example
 * var textureAtlas = cc.TextureAtlas.create("hello.png", 3);
 */
cc.TextureAtlas.create = function (file, capacity) {
    var textureAtlas = new cc.TextureAtlas();
    if (textureAtlas && textureAtlas.initWithFile(file, capacity)) {
        return textureAtlas;
    }
    return null;
};

/**
 * <p>Creates a TextureAtlas with a previously initialized Texture2D object, and with an initial capacity for n Quads.
 * The TextureAtlas capacity can be increased in runtime.</p>
 * @param {Image} texture
 * @param {Number} capacity
 * @return {cc.TextureAtlas}
 * @example
 * //example
 * var texture = cc.TextureCache.getInstance().addImage("hello.png");
 * var textureAtlas = cc.TextureAtlas.createWithTexture(texture, 3);
 */
cc.TextureAtlas.createWithTexture = function (texture, capacity) {
    var textureAtlas = new cc.TextureAtlas();
    if (textureAtlas && textureAtlas.initWithTexture(texture, capacity)) {
        return textureAtlas;
    }
    return null;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2009      Jason Booth
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * enum for jpg
 * @constant
 * @type Number
 */
cc.IMAGE_FORMAT_JPEG = 0;
/**
 * enum for png
 * @constant
 * @type Number
 */
cc.IMAGE_FORMAT_PNG = 1;
/**
 * enum for raw
 * @constant
 * @type Number
 */
cc.IMAGE_FORMAT_RAWDATA = 2;

/**
 * @param {Number} x
 * @return {Number}
 * Constructor
 */
cc.NextPOT = function (x) {
    x = x - 1;
    x = x | (x >> 1);
    x = x | (x >> 2);
    x = x | (x >> 4);
    x = x | (x >> 8);
    x = x | (x >> 16);
    return x + 1;
};

/**
 * cc.RenderTexture is a generic rendering target. To render things into it,<br/>
 * simply construct a render target, call begin on it, call visit on any cocos<br/>
 * scenes or objects to render them, and call end. For convienience, render texture<br/>
 * adds a sprite as it's display child with the results, so you can simply add<br/>
 * the render texture to your scene and treat it like any other CocosNode.<br/>
 * There are also functions for saving the render texture to disk in PNG or JPG format.
 * @class
 * @extends cc.Node
 */
cc.RenderTexture = cc.Node.extend(/** @lends cc.RenderTexture# */{
    /**
     * the offscreen canvas for rendering and storing the texture
     * @type HTMLCanvasElement
     */
    canvas:null,
    /**
     * stores a reference to the canvas context object
     * @type CanvasContext
     */
    context:null,
    _fBO:0,
    _depthRenderBuffer:0,
    _oldFBO:0,
    _texture:null,
    _uITextureImage:null,
    _pixelFormat:cc.TEXTURE_2D_PIXEL_FORMAT_RGBA8888,
    _sprite:null,

    /**
     * Constructor
     */
    ctor:function () {
        this.canvas = document.createElement('canvas');
        this.context = this.canvas.getContext('2d');
        this.setAnchorPoint(cc.p(0, 0));

        // Listen this event to save render texture before come to background.
        // Then it can be restored after coming to foreground on Android.
        /*extension.CCNotificationCenter.sharedNotificationCenter().addObserver(this,
         callfuncO_selector(CCRenderTexture.listenToBackground),
         EVENT_COME_TO_BACKGROUND,
         null);*/
    },

    /**
     * The sprite
     * @return {cc.Sprite}
     */
    getSprite:function () {
        return this._sprite;
    },

    /**
     * @param {cc.Sprite} sprite
     */
    setSprite:function (sprite) {
        this._sprite = sprite;
    },

    /**
     * @return {HTMLCanvasElement}
     */
    getCanvas:function () {
        return this.canvas;
    },

    /**
     * @param {cc.Size} size
     */
    setContentSize:function (size) {
        if (!size) {
            return;
        }

        //if (!cc.Size.CCSizeEqualToSize(size, this._contentSize)) {
        this._super(size);
        this.canvas.width = size.width * 1.5;
        this.canvas.height = size.height * 1.5;

        this.context.translate(0, this.canvas.height);
        //}
    },

    /**
     * @param {Number} width
     * @param {Number} height
     * @param {cc.IMAGE_FORMAT_JPEG|cc.IMAGE_FORMAT_PNG|cc.IMAGE_FORMAT_RAWDATA} format
     * @param {Number} depthStencilFormat
     * @return {Boolean}
     */
    initWithWidthAndHeight:function (width, height, format, depthStencilFormat) {
        if (cc.renderContextType == cc.CANVAS) {
            this.canvas.width = width || 10;
            this.canvas.height = height || 10;

            this.context.translate(0, this.canvas.height);

            this._sprite = cc.Sprite.createWithTexture(this.canvas);

            return true;
        } else {
            //TODO
            cc.Assert(this._pixelFormat != cc.TEXTURE_2D_PIXEL_FORMAT_A8, "only RGB and RGBA formats are valid for a render texture");

            try {
                width *= cc.CONTENT_SCALE_FACTOR();
                height *= cc.CONTENT_SCALE_FACTOR();

                glGetIntegerv(gl.FRAMEBUFFER_BINDING, this._oldFBO);

                // textures must be power of two squared
                var powW = 0;
                var powH = 0;

                if (cc.Configuration.getInstance().supportsNPOT()) {
                    powW = width;
                    powH = height;
                } else {
                    powW = cc.NextPOT(width);
                    powH = cc.NextPOT(height);
                }

                //void *data = malloc(powW * powH * 4);
                var data = [];
                //memset(data, 0, (int)(powW * powH * 4));
                for (var i = 0; i < powW * powH * 4; i++) {
                    data[i] = 0;
                }

                this._pixelFormat = format;

                this._texture = new cc.Texture2D();
                if (!this._texture)
                    return false;

                this._texture.initWithData(data, this._pixelFormat, powW, powH, cc.size(width, height));
                //free( data );

                var oldRBO;
                glGetIntegerv(GL_RENDERBUFFER_BINDING, oldRBO);

                // generate FBO
                glGenFramebuffers(1, this._fBO);
                glBindFramebuffer(GL_FRAMEBUFFER, this._fBO);

                // associate texture with FBO
                glFramebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, GL_TEXTURE_2D, this._texture.getName(), 0);

                if (this._depthRenderBuffer != 0) {
                    //create and attach depth buffer
                    glGenRenderbuffers(1, this._depthRenderBuffer);
                    glBindRenderbuffer(GL_RENDERBUFFER, this._depthRenderBuffer);
                    glRenderbufferStorage(GL_RENDERBUFFER, depthStencilFormat, powW, powH);
                    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, this._depthRenderBuffer);

                    // if depth format is the one with stencil part, bind same render buffer as stencil attachment
                    if (depthStencilFormat == gl.DEPTH24_STENCIL8)
                        glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_RENDERBUFFER, this._depthRenderBuffer);
                }

                // check if it worked (probably worth doing :) )
                cc.Assert(glCheckFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE, "Could not attach texture to framebuffer");

                this._texture.setAliasTexParameters();

                this._sprite = cc.Sprite.createWithTexture(this._texture);

                this._sprite.setScaleY(-1);
                this.addChild(this._sprite);

                this._sprite.setBlendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

                glBindRenderbuffer(GL_RENDERBUFFER, oldRBO);
                glBindFramebuffer(GL_FRAMEBUFFER, this._oldFBO);
            } catch (ex) {
                return false;
            }
            return true;
        }
    },

    /**
     * starts grabbing
     */
    begin:function () {
        //TODO
        // Save the current matrix
        kmGLPushMatrix();

        var texSize = this._texture.getContentSizeInPixels();

        // Calculate the adjustment ratios based on the old and new projections
        var size = cc.Director.getInstance().getWinSizeInPixels();
        var widthRatio = size.width / texSize.width;
        var heightRatio = size.height / texSize.height;

        // Adjust the orthographic projection and viewport
        glViewport(0, 0, texSize.width, texSize.height);

        var orthoMatrix;
        kmMat4OrthographicProjection(orthoMatrix, -1.0 / widthRatio, 1.0 / widthRatio,
            -1.0 / heightRatio, 1.0 / heightRatio, -1, 1);
        kmGLMultMatrix(orthoMatrix);

        glGetIntegerv(gl.FRAMEBUFFER_BINDING, this._oldFBO);
        glBindFramebuffer(gl.FRAMEBUFFER, this._fBO);//Will direct drawing to the frame buffer created above
    },

    /**
     * starts rendering to the texture while clearing the texture first.<br/>
     * This is more efficient then calling -clear first and then -begin
     * @param {Number} r red 0-255
     * @param {Number} g green 0-255
     * @param {Number} b blue 0-255
     * @param {Number} depthValue
     * @param {Number} stencilValue
     * @param {Number} a alpha 0-255 0 is transparent
     */
    beginWithClear:function (r, g, b, a, depthValue, stencilValue) {
        //TODO
        var clearColor;
        switch (arguments.length) {
            case 4:
                this.begin();

                // save clear color
                clearColor = [0, 0, 0, 0];
                glGetFloatv(GL_COLOR_CLEAR_VALUE, clearColor);

                glClearColor(r, g, b, a);
                glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

                // restore clear color
                glClearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
                break;
            case 5:
                this.begin();

                // save clear color
                clearColor = [0, 0, 0, 0];
                var depthClearValue;
                glGetFloatv(GL_COLOR_CLEAR_VALUE, clearColor);
                glGetFloatv(GL_DEPTH_CLEAR_VALUE, depthClearValue);

                glClearColor(r, g, b, a);
                glClearDepth(depthValue);
                glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

                // restore clear color
                glClearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
                glClearDepth(depthClearValue);
                break;
            case 6:
                this.begin();

                // save clear color
                clearColor = [0, 0, 0, 0];
                var depthClearValue;
                var stencilClearValue;
                glGetFloatv(GL_COLOR_CLEAR_VALUE, clearColor);
                glGetFloatv(GL_DEPTH_CLEAR_VALUE, depthClearValue);
                glGetIntegerv(GL_STENCIL_CLEAR_VALUE, stencilClearValue);

                glClearColor(r, g, b, a);
                glClearDepth(depthValue);
                glClearStencil(stencilValue);
                glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);

                // restore clear color
                glClearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
                glClearDepth(depthClearValue);
                glClearStencil(stencilClearValue);
                break;
            default :
                throw "unknown arguments";
                break;
        }
    },

    /**
     * ends grabbing
     */
    end:function () {
        glBindFramebuffer(GL_FRAMEBUFFER, this._oldFBO);
        kmGLPopMatrix();

        var director = cc.Director.getInstance();

        var size = director.getWinSizeInPixels();

        // restore viewport
        glViewport(0, 0, size.width * cc.CONTENT_SCALE_FACTOR(), size.height * cc.CONTENT_SCALE_FACTOR());

        // special viewport for 3d projection + retina display
        if (director.getProjection() == cc.DIRECTOR_PROJECTION_3D && cc.CONTENT_SCALE_FACTOR() != 1) {
            glViewport((-size.width / 2), (-size.height / 2), (size.width * cc.CONTENT_SCALE_FACTOR()), (size.height * cc.CONTENT_SCALE_FACTOR()));
        }

        director.setProjection(director.getProjection());
    },

    /**
     * clears the texture with a color
     * @param {Number} r red 0-255
     * @param {Number} g green 0-255
     * @param {Number} b blue 0-255
     * @param {Number} a alpha 0-255
     */
    clear:function (r, g, b, a) {
        if (cc.renderContextType == cc.CANVAS) {
            var rect = r;
            if (rect) {
                this.context.clearRect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
            } else {
                this.context.clearRect(0, 0, this.canvas.width, -this.canvas.height);
            }
        } else {
            this.beginWithClear(r, g, b, a);
            this.end();
        }
    },

    /**
     * clears the texture with a specified depth value
     * @param {Number} dep
     */
    clearDepth:function (dep) {
        this.begin();
        //! save old depth value
        var depthClearValue;
        glGetFloatv(GL_DEPTH_CLEAR_VALUE, depthClearValue);

        glClearDepth(depthValue);
        glClear(GL_DEPTH_BUFFER_BIT);

        // restore clear color
        glClearDepth(depthClearValue);
        this.end();
    },

    /**
     * clears the texture with a specified stencil value
     * @param {Number} stencilValue
     */
    clearStencil:function (stencilValue) {
        // save old stencil value
        var stencilClearValue;
        glGetIntegerv(GL_STENCIL_CLEAR_VALUE, stencilClearValue);

        glClearStencil(stencilValue);
        glClear(GL_STENCIL_BUFFER_BIT);

        // restore clear color
        glClearStencil(stencilClearValue);
    },

    /**
     * creates a new CCImage from with the texture's data. Caller is responsible for releasing it by calling delete.
     * @return {cc.Image}
     */
    newCCImage:function () {
        cc.Assert(this._pixelFormat == cc.TEXTURE_2D_PIXEL_FORMAT_RGBA8888, "only RGBA8888 can be saved as image");

        if (!this._texture) {
            return null;
        }

        var size = this._texture.getContentSizeInPixels();

        // to get the image size to save
        //        if the saving image domain exeeds the buffer texture domain,
        //        it should be cut
        var nSavedBufferWidth = size.width;
        var nSavedBufferHeight = size.height;

        var pBuffer = null;
        var pTempData = null;
        var pImage = new cc.Image();

        try {
            pBuffer = [];
            pBuffer.length = nSavedBufferWidth * nSavedBufferHeight * 4;
            if (!(pBuffer))
                return pImage;

            pTempData = [];
            pTempData.length = nSavedBufferWidth * nSavedBufferHeight * 4;
            if (!(pTempData)) {
                pBuffer = null;
                return pImage;
            }

            this.begin();
            glPixelStorei(GL_PACK_ALIGNMENT, 1);
            glReadPixels(0, 0, nSavedBufferWidth, nSavedBufferHeight, GL_RGBA, GL_UNSIGNED_BYTE, pTempData);
            this.end();

            // to get the actual texture data
            // #640 the image read from rendertexture is upseted
            for (var i = 0; i < nSavedBufferHeight; ++i) {
                this._memcpy(pBuffer, i * nSavedBufferWidth * 4,
                    pTempData, (nSavedBufferHeight - i - 1) * nSavedBufferWidth * 4,
                    nSavedBufferWidth * 4);
            }

            pImage.initWithImageData(pBuffer, nSavedBufferWidth * nSavedBufferHeight * 4, cc.FMT_RAWDATA, nSavedBufferWidth, nSavedBufferHeight, 8);
        } catch (ex) {
            return pImage;
        }

        pBuffer = null;
        pTempData = null;
        return pImage;
    },

    _memcpy:function (destArr, destIndex, srcArr, srcIndex, size) {
        for (var i = 0; i < size; i++) {
            destArr[destIndex + i] = srcArr[srcIndex + i];
        }
    },

    /**
     * saves the texture into a file using JPEG format. The file will be saved in the Documents folder.
     * Returns YES if the operation is successful.
     * @param {Number} filePath
     * @param {Number} format
     */
    saveToFile:function (filePath, format) {
        if (!format)
            filePath = cc.FileUtils.getInstance().getWriteablePath() + filePath;
        format = format || cc.IMAGE_FORMAT_JPEG;

        cc.Assert(format == cc.IMAGE_FORMAT_JPEG || format == cc.IMAGE_FORMAT_PNG,
            "the image can only be saved as JPG or PNG format");

        var pImage = this.newCCImage();
        if (pImage) {
            return pImage.saveToFile(filePath, true);
        }
        return false;
    },

    /**
     * Listen "come to background" message, and save render texture. It only has effect on Android.
     * @param {cc.Class} obj
     */
    listenToBackground:function (obj) {
        if (cc.ENABLE_CACHE_TEXTURE_DATA) {
            cc.SAFE_DELETE(this.pITextureImage);

            // to get the rendered texture data
            this.pITextureImage = this.newCCImage();

            if (this.pITextureImage) {
                var s = this._texture.getContentSizeInPixels();
                VolatileTexture.addDataTexture(this._texture, this.pITextureImage.getData(), cc.TEXTURE_2D_PIXEL_FORMAT_RGBA8888, s);
            } else {
                cc.log("Cache rendertexture failed!");
            }
        }
    }
});

/**
 * creates a RenderTexture object with width and height in Points and a pixel format, only RGB and RGBA formats are valid
 * @param {Number} width
 * @param {Number} height
 * @param {cc.IMAGE_FORMAT_JPEG|cc.IMAGE_FORMAT_PNG|cc.IMAGE_FORMAT_RAWDATA} format
 * @param {Number} depthStencilFormat
 * @return {cc.RenderTexture}
 * @example
 * // Example
 * var rt = cc.RenderTexture.create()
 */
cc.RenderTexture.create = function (width, height, format, depthStencilFormat) {
    format = format || cc.TEXTURE_2D_PIXEL_FORMAT_RGBA8888;
    depthStencilFormat = depthStencilFormat || 0;

    var ret = new cc.RenderTexture();
    if (ret && ret.initWithWidthAndHeight(width, height, format, depthStencilFormat)) {
        return ret;
    }
    return null;
};
/****************************************************************************
 Copyright (c) 2010-2011 cocos2d-x.org
 Copyright (c) 2010      Lam Pham

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/


/**
 * Radial Counter-Clockwise
 * @type Number
 * @constant
 */
cc.PROGRESS_TIMER_TYPE_RADIAL = 0;
/**
 * Bar
 * @type Number
 * @constant
 */
cc.PROGRESS_TIMER_TYPE_BAR = 1;

/**
 * @constant
 * @type Number
 */
cc.PROGRESS_TEXTURE_COORDS_COUNT = 4;

/**
 * @constant
 * @type Number
 */
cc.PROGRESS_TEXTURE_COORDS = 0x4b;


/**
 * cc.Progresstimer is a subclass of cc.Node.<br/>
 * It renders the inner sprite according to the percentage.<br/>
 * The progress can be Radial, Horizontal or vertical.
 * @class
 * @extends cc.Node
 */
cc.ProgressTimer = cc.Node.extend(/** @lends cc.ProgressTimer# */{
    RGBAProtocol:true,
    _type:null,
    _percentage:0.0,
    _sprite:null,
    _vertexDataCount:0,
    _vertexData:null,

    _midPoint:cc.PointZero(),
    _barChangeRate:cc.PointZero(),
    _reverseDirection:false,

    ctor:function () {
        this._type = cc.PROGRESS_TIMER_TYPE_RADIAL;
        this._percentage = 0.0;
        this._midPoint = cc.p(0, 0);
        this._barChangeRate = cc.p(0, 0);
        this._reverseDirection = false;
    },

    /**
     *    Midpoint is used to modify the progress start position.
     *    If you're using radials type then the midpoint changes the center point
     *    If you're using bar type the the midpoint changes the bar growth
     *        it expands from the center but clamps to the sprites edge so:
     *        you want a left to right then set the midpoint all the way to cc.p(0,y)
     *        you want a right to left then set the midpoint all the way to cc.p(1,y)
     *        you want a bottom to top then set the midpoint all the way to cc.p(x,0)
     *        you want a top to bottom then set the midpoint all the way to cc.p(x,1)
     *  @return {cc.Point}
     */
    getMidpoint:function () {
        return this._midPoint;
    },

    /**
     * Midpoint setter
     * @param {cc.Point} mpoint
     */
    setMidpoint:function (mpoint) {
        this._midPoint = cc.pClamp(mpoint, cc.PointZero(), cc.p(1, 1));
    },

    /**
     *    This allows the bar type to move the component at a specific rate
     *    Set the component to 0 to make sure it stays at 100%.
     *    For example you want a left to right bar but not have the height stay 100%
     *    Set the rate to be cc.p(0,1); and set the midpoint to = cc.p(0,.5f);
     *  @return {cc.Point}
     */
    getBarChangeRate:function () {
        return this._barChangeRate;
    },

    /**
     * @param {cc.Point} barChangeRate
     */
    setBarChangeRate:function (barChangeRate) {

        this._barChangeRate = cc.pClamp(barChangeRate, cc.PointZero(), cc.p(1, 1));
    },

    /**
     *  Change the percentage to change progress
     * @return {cc.PROGRESS_TIMER_TYPE_RADIAL|cc.PROGRESS_TIMER_TYPE_BAR}
     */
    getType:function () {
        return this._type;
    },

    /**
     * Percentages are from 0 to 100
     * @return {Number}
     */
    getPercentage:function () {
        return this._percentage;
    },

    /**
     * The image to show the progress percentage, retain
     * @return {cc.Sprite}
     */
    getSprite:function () {
        return this._sprite;
    },

    /**
     * Initializes a progress timer with the sprite as the shape the timer goes through
     * @param {cc.Sprite} sprite
     * @return {Boolean}
     */
    initWithSprite:function (sprite) {
        this.setPercentage(0);
        this._vertexData = null;
        this._vertexDataCount = 0;
        this.setAnchorPoint(cc.p(0.5, 0.5));

        this._type = cc.PROGRESS_TIMER_TYPE_RADIAL;
        this._reverseDirection = false;
        this.setMidpoint(cc.p(0.5, 0.5));
        this.setBarChangeRate(cc.p(1, 1));
        this.setSprite(sprite);

        //shader program
        //this.setShaderProgram(cc.ShaderCache.getInstance().programForKey(kCCShader_PositionTextureColor));

        return true;
    },

    /**
     * from 0-100
     * @param {Number} percentage
     */
    setPercentage:function (percentage) {
        if (this._percentage != percentage) {
            this._percentage = cc.clampf(percentage, 0, 100);
            this._updateProgress();
        }
    },

    /**
     * @param {cc.Sprite} sprite
     */
    setSprite:function (sprite) {
        if (this._sprite != sprite) {
            this._sprite = sprite;
            this.setContentSize(this._sprite.getContentSize());

            //	Everytime we set a new sprite, we free the current vertex data
            if (this._vertexData) {
                this._vertexData = null;
                this._vertexDataCount = 0;
            }
        }
    },

    /**
     * set Progress type of cc.ProgressTimer
     * @param {cc.PROGRESS_TIMER_TYPE_RADIAL|cc.PROGRESS_TIMER_TYPE_BAR} type
     */
    setType:function (type) {
        if (type != this._type) {
            //	release all previous information
            if (this._vertexData) {
                this._vertexData = null;
                this._vertexDataCount = 0;
            }

            this._type = type;
        }
    },

    /**
     * set color of sprite
     * @param {cc.Color3B} color
     */
    setColor:function (color) {
        this._sprite.setColor(color);
        this._updateColor();
    },

    /**
     * return color of sprite
     * @return {cc.Color3B}
     */
    getColor:function () {
        return this._sprite.getColor();
    },

    /**
     * return Opacity of sprite
     * @return {Number}
     */
    getOpacity:function () {
        return this._sprite.getOpacity();
    },

    /**
     * Opacity
     * @param {Number} opacity
     */
    setOpacity:function (opacity) {
        this._sprite.setOpacity(opacity);
        this._updateColor();
    },

    setOpacityModifyRGB:function (bValue) {
    },

    isOpacityModifyRGB:function () {
        return false;
    },

    isReverseDirection:function () {
        return this._reverseDirection;
    },

    /**
     * Reverse Progress setter
     * @param {Boolean} reverse
     */
    setReverseDirection:function (reverse) {
        if (this._reverseDirection != reverse) {
            this._reverseDirection = reverse;
            //release all previous information
            this._vertexData = null;
            this._vertexDataCount = 0;
        }
    },

    /**
     * stuff gets drawn here
     * @param {CanvasContext} ctx
     */
    draw:function (ctx) {
        if (cc.renderContextType == cc.CANVAS) {
            var context = ctx || cc.renderContext;

            context.globalAlpha = this._sprite._opacity / 255;
            var centerPoint, mpX = 0, mpY = 0;
            if (this._sprite._flipX) {
                centerPoint = cc.p(this._sprite._contentSize.width / 2, this._sprite._contentSize.height / 2);
                mpX = 0 | (centerPoint.x - this._sprite._anchorPointInPoints.x);
                context.translate(mpX, 0);
                context.scale(-1, 1);
            }

            if (this._sprite._flipY) {
                centerPoint = cc.p(this._sprite._contentSize.width / 2, this._sprite._contentSize.height / 2);
                mpY = -(0 | (centerPoint.y - this._sprite._anchorPointInPoints.y));
                context.translate(0, mpY);
                context.scale(1, -1);
            }

            var pos;
            if (this._type == cc.PROGRESS_TIMER_TYPE_BAR) {
                pos = cc.p(( -this._sprite._anchorPointInPoints.x + this._sprite._offsetPosition.x + this._drawPosition.x),
                    ( -this._sprite._anchorPointInPoints.y + this._sprite._offsetPosition.y + this._drawPosition.y));

                if (this._sprite._texture instanceof HTMLImageElement) {
                    context.drawImage(this._sprite._texture,
                        this._sprite._rect.origin.x + this._origin.x, this._sprite._rect.origin.y + this._origin.y,
                        this._originSize.width, this._originSize.height,
                        pos.x, -(pos.y + this._drawSize.height),
                        this._originSize.width, this._originSize.height);
                } else if (this._sprite._texture instanceof  HTMLCanvasElement) {
                    if ((this._originSize.width != 0) && (this._originSize.height != 0)) {
                        context.drawImage(this._sprite._texture,
                            this._origin.x, this._origin.y,
                            this._originSize.width, this._originSize.height,
                            pos.x, -(pos.y + this._drawSize.height),
                            this._originSize.width, this._originSize.height);
                    }
                }
            } else {
                context.beginPath();
                context.arc(this._origin.x, this._origin.y, this._radius, (Math.PI / 180) * this._startAngle, (Math.PI / 180) * this._endAngle, false);
                context.lineTo(this._origin.x, this._origin.y);
                context.clip();
                context.closePath();

                var offsetPixels = this._sprite._offsetPosition;
                pos = cc.p(0 | ( -this._sprite._anchorPointInPoints.x + offsetPixels.x),
                    0 | ( -this._sprite._anchorPointInPoints.y + offsetPixels.y));

                if (this._sprite._texture instanceof HTMLImageElement) {
                    context.drawImage(this._sprite._texture,
                        this._sprite._rect.origin.x, this._sprite._rect.origin.y,
                        this._sprite._rect.size.width, this._sprite._rect.size.height,
                        pos.x, -(pos.y + this._sprite._rect.size.height),
                        this._sprite._rect.size.width, this._sprite._rect.size.height);
                } else if (this._sprite._texture instanceof  HTMLCanvasElement) {
                    context.drawImage(this._sprite._texture,
                        0, 0,
                        this._sprite._rect.size.width, this._sprite._rect.size.height,
                        pos.x, -(pos.y + this._sprite._rect.size.height),
                        this._sprite._rect.size.width, this._sprite._rect.size.height);
                }
            }
        } else {
            if (!this._vertexData || !this._sprite)
                return;
        }
        cc.INCREMENT_GL_DRAWS(1);
    },

    /**
     * @param {cc.Point} alpha
     * @return {cc.Vertex2F} the vertex position from the texture coordinate
     * @private
     */
    _textureCoordFromAlphaPoint:function (alpha) {
        var ret = new cc.Tex2F(0, 0);
        if (!this._sprite) {
            return ret;
        }
        var quad = this._sprite.getQuad();
        var min = cc.p(quad.bl.texCoords.u, quad.bl.texCoords.v);
        var max = cc.p(quad.tr.texCoords.u, quad.tr.texCoords.v);

        //  Fix bug #1303 so that progress timer handles sprite frame texture rotation
        if (this._sprite.isTextureRectRotated()) {
            var tempX = alpha.x;
            alpha.x = alpha.y;
            alpha.y = tempX;
        }
        return new cc.Tex2F(min.x * (1 - alpha.x) + max.x * alpha.x, min.y * (1 - alpha.y) + max.y * alpha.y);
    },

    _vertexFromAlphaPoint:function (alpha) {
        var ret = new cc.Tex2F(0, 0);
        if (!this._sprite) {
            return ret;
        }
        var quad = this._sprite.getQuad();
        var min = cc.p(quad.bl.vertices.x, quad.bl.vertices.y);
        var max = cc.p(quad.tr.vertices.x, quad.tr.vertices.y);
        ret.x = min.x * (1 - alpha.x) + max.x * alpha.x;
        ret.y = min.y * (1 - alpha.y) + max.y * alpha.y;
        return ret;
    },

    _origin:cc.PointZero(),
    _originSize:cc.SizeZero(),
    _drawSize:cc.SizeZero(),
    _drawPosition:cc.PointZero(),
    _startAngle:270,
    _endAngle:270,
    _radius:0,
    _updateProgress:function () {
        if (cc.renderContextType == cc.CANVAS) {
            var size = this._sprite.getContentSize();
            var textureSize = this._sprite.getTextureRect().size;
            if (this._type == cc.PROGRESS_TIMER_TYPE_RADIAL) {

                this._origin = cc.p(-(size.width * (0.5 - this._midPoint.x)), -(size.height * (0.5 - this._midPoint.y)));
                this._radius = Math.round(Math.sqrt(size.width * size.width + size.height * size.height));
                if (this._reverseDirection) {
                    this._startAngle = 270 - 3.6 * this._percentage;
                } else {
                    this._endAngle = 270 + 3.6 * this._percentage;
                }
            } else {
                this._origin = cc.p(0, 0);
                this._drawPosition = cc.p(0, 0);

                var percentageF = this._percentage / 100;
                var startPoint = cc.p(size.width * this._midPoint.x, size.height * this._midPoint.y);
                var startPointTx = cc.p(textureSize.width * this._midPoint.x, textureSize.height * this._midPoint.y);

                var drawedSize = cc.size((size.width * (1 - this._barChangeRate.x)), (size.height * (1 - this._barChangeRate.y)));
                var drawingSize = cc.size((size.width - drawedSize.width) * percentageF, (size.height - drawedSize.height) * percentageF);
                this._drawSize = cc.size(drawedSize.width + drawingSize.width, drawedSize.height + drawingSize.height);

                var txDrawedSize = cc.size((textureSize.width * (1 - this._barChangeRate.x)), (textureSize.height * (1 - this._barChangeRate.y)));
                var txDrawingSize = cc.size((textureSize.width - txDrawedSize.width) * percentageF, (textureSize.height - txDrawedSize.height) * percentageF);
                this._originSize = cc.size(txDrawedSize.width + txDrawingSize.width, txDrawedSize.height + txDrawingSize.height);

                var needToLeft = startPoint.x * percentageF;
                var needToLeftTx = startPointTx.x * percentageF;

                if (size.width == this._drawSize.width) {
                    this._origin.x = 0;
                    this._drawPosition.x = 0;
                } else {
                    this._origin.x = (startPointTx.x - needToLeftTx);
                    this._drawPosition.x = (startPoint.x - needToLeft);
                }

                var needToTop = (textureSize.height - startPointTx.y) * percentageF;

                if (size.height == this._drawSize.height) {
                    this._origin.y = 0;
                    this._drawPosition.y = 0;
                } else {
                    this._origin.y = (textureSize.height - startPointTx.y - needToTop);
                    this._drawPosition.y = (startPoint.y - (startPoint.y * percentageF));
                }
            }
        } else {
            switch (this._type) {
                case cc.PROGRESS_TIMER_TYPE_RADIAL:
                    this._updateRadial();
                    break;
                case cc.PROGRESS_TIMER_TYPE_BAR:
                    this._updateBar();
                    break;
                default:
                    break;
            }
        }
    },

    _updateBar:function () {
        if (!this._sprite) {
            return;
        }

        var alpha = this._percentage / 100.0;
        var alphaOffset = cc.pMult(cc.p((1.0 - this._barChangeRate.x) + alpha * this._barChangeRate.x,
            (1.0 - this._barChangeRate.y) + alpha * this._barChangeRate.y), 0.5);
        var min = cc.pSub(this._midPoint, alphaOffset);
        var max = cc.pAdd(this._midPoint, alphaOffset);

        if (min.x < 0) {
            max.x += -min.x;
            min.x = 0;
        }

        if (max.x > 1) {
            min.x -= max.x - 1;
            max.x = 1;
        }

        if (min.y < 0) {
            max.y += -min.y;
            min.y = 0;
        }

        if (max.y > 1) {
            min.y -= max.y - 1;
            max.y = 1;
        }

        if (!this._reverseDirection) {
            if (!this._vertexData) {
                this._vertexDataCount = 4;
                this._vertexData = [];
                for (i = 0; i < this._vertexDataCount; i++) {
                    this._vertexData[i] = new cc.V2F_C4B_T2F();
                }
                cc.Assert(this._vertexData, "cc.ProgressTimer. Not enough memory");
            }

            //    TOPLEFT
            this._vertexData[0].texCoords = this._textureCoordFromAlphaPoint(cc.p(min.x, max.y));
            this._vertexData[0].vertices = this._vertexFromAlphaPoint(cc.p(min.x, max.y));

            //    BOTLEFT
            this._vertexData[1].texCoords = this._textureCoordFromAlphaPoint(cc.p(min.x, min.y));
            this._vertexData[1].vertices = this._vertexFromAlphaPoint(cc.p(min.x, min.y));

            //    TOPRIGHT
            this._vertexData[2].texCoords = this._textureCoordFromAlphaPoint(cc.p(max.x, max.y));
            this._vertexData[2].vertices = this._vertexFromAlphaPoint(cc.p(max.x, max.y));

            //    BOTRIGHT
            this._vertexData[3].texCoords = this._textureCoordFromAlphaPoint(cc.p(max.x, min.y));
            this._vertexData[3].vertices = this._vertexFromAlphaPoint(cc.p(max.x, min.y));
        } else {
            if (!this._vertexData) {
                this._vertexData = 8;
                this._vertexData = [];
                for (i = 0; i < this._vertexDataCount; i++) {
                    this._vertexData[i] = new cc.V2F_C4B_T2F();
                }
                cc.Assert(this._vertexData, "cc.ProgressTimer. Not enough memory");
                //    TOPLEFT 1
                this._vertexData[0].texCoords = this._textureCoordFromAlphaPoint(cc.p(0, 1));
                this._vertexData[0].vertices = this._vertexFromAlphaPoint(cc.p(0, 1));

                //    BOTLEFT 1
                this._vertexData[1].texCoords = this._textureCoordFromAlphaPoint(cc.p(0, 0));
                this._vertexData[1].vertices = this._vertexFromAlphaPoint(cc.p(0, 0));

                //    TOPRIGHT 2
                this._vertexData[6].texCoords = this._textureCoordFromAlphaPoint(cc.p(1, 1));
                this._vertexData[6].vertices = this._vertexFromAlphaPoint(cc.p(1, 1));

                //    BOTRIGHT 2
                this._vertexData[7].texCoords = this._textureCoordFromAlphaPoint(cc.p(1, 0));
                this._vertexData[7].vertices = this._vertexFromAlphaPoint(cc.p(1, 0));
            }

            //    TOPRIGHT 1
            this._vertexData[2].texCoords = this._textureCoordFromAlphaPoint(cc.p(min.x, max.y));
            this._vertexData[2].vertices = this._vertexFromAlphaPoint(cc.p(min.x, max.y));

            //    BOTRIGHT 1
            this._vertexData[3].texCoords = this._textureCoordFromAlphaPoint(cc.p(min.x, min.y));
            this._vertexData[3].vertices = this._vertexFromAlphaPoint(cc.p(min.x, min.y));

            //    TOPLEFT 2
            this._vertexData[4].texCoords = this._textureCoordFromAlphaPoint(cc.p(max.x, max.y));
            this._vertexData[4].vertices = this._vertexFromAlphaPoint(cc.p(max.x, max.y));

            //    BOTLEFT 2
            this._vertexData[5].texCoords = this._textureCoordFromAlphaPoint(cc.p(max.x, min.y));
            this._vertexData[5].vertices = this._vertexFromAlphaPoint(cc.p(max.x, min.y));
        }
        this._updateColor();
    },

    _updateRadial:function () {
        if (!this._sprite) {
            return;
        }
        var i;
        var alpha = this._percentage / 100;
        var angle = 2 * (cc.PI) * ( this._reverseDirection ? alpha : 1.0 - alpha);

        //    We find the vector to do a hit detection based on the percentage
        //    We know the first vector is the one @ 12 o'clock (top,mid) so we rotate
        //    from that by the progress angle around the m_tMidpoint pivot
        var topMid = cc.p(this._midPoint.x, 1);
        var percentagePt = cc.pRotateByAngle(topMid, this._midPoint, angle);

        var index = 0;
        var hit = cc.PointZero;

        if (alpha == 0) {
            //    More efficient since we don't always need to check intersection
            //    If the alpha is zero then the hit point is top mid and the index is 0.
            hit = topMid;
            index = 0;
        } else if (alpha == 1) {
            //    More efficient since we don't always need to check intersection
            //    If the alpha is one then the hit point is top mid and the index is 4.
            hit = topMid;
            index = 4;
        } else {
            //    We run a for loop checking the edges of the texture to find the
            //    intersection point
            //    We loop through five points since the top is split in half

            var min_t = cc.FLT_MAX;

            for (i = 0; i <= cc.PROGRESS_TEXTURE_COORDS_COUNT; ++i) {
                var pIndex = (i + (cc.PROGRESS_TEXTURE_COORDS_COUNT - 1)) % cc.PROGRESS_TEXTURE_COORDS_COUNT;

                var edgePtA = this._boundaryTexCoord(i % cc.PROGRESS_TEXTURE_COORDS_COUNT);
                var edgePtB = this._boundaryTexCoord(pIndex);

                //    Remember that the top edge is split in half for the 12 o'clock position
                //    Let's deal with that here by finding the correct endpoints
                if (i == 0) {
                    edgePtB = cc.pLerp(edgePtA, edgePtB, 1 - this._midPoint.x);
                } else if (i == 4) {
                    edgePtA = cc.pLerp(edgePtA, edgePtB, 1 - this._midPoint.x);
                }

                // s and t are returned by ccpLineIntersect
                var s = 0, t = 0;
                var retPoint = cc.p(0, 0);
                if (cc.pLineIntersect(edgePtA, edgePtB, this._midPoint, percentagePt, retPoint)) {
                    //    Since our hit test is on rays we have to deal with the top edge
                    //    being in split in half so we have to test as a segment
                    if ((i == 0 || i == 4)) {
                        //    s represents the point between edgePtA--edgePtB
                        if (!(0 <= retPoint.width && retPoint.width <= 1)) {
                            continue;
                        }
                    }
                    //    As long as our t isn't negative we are at least finding a
                    //    correct hitpoint from m_tMidpoint to percentagePt.
                    if (retPoint.height >= 0) {
                        //    Because the percentage line and all the texture edges are
                        //    rays we should only account for the shortest intersection
                        if (t < min_t) {
                            min_t = t;
                            index = i;
                        }
                    }
                }
            }

            //    Now that we have the minimum magnitude we can use that to find our intersection
            hit = cc.pAdd(this._midPoint, cc.pMult(cc.pSub(percentagePt, this._midPoint), min_t));
        }

        //    The size of the vertex data is the index from the hitpoint
        //    the 3 is for the m_tMidpoint, 12 o'clock point and hitpoint position.
        var sameIndexCount = true;
        if (this._vertexDataCount != index + 3) {
            sameIndexCount = false;
            this._vertexData = null;
            this._vertexDataCount = 0;
        }

        if (!this._vertexData) {
            this._vertexDataCount = index + 3;
            this._vertexData = [];
            for (i = 0; i < this._vertexDataCount; i++) {
                this._vertexData[i] = new cc.V2F_C4B_T2F();
            }
            cc.Assert(this._vertexData, "cc.ProgressTimer. Not enough memory");
        }
        this._updateColor();

        if (!sameIndexCount) {
            //    First we populate the array with the m_tMidpoint, then all
            //    vertices/texcoords/colors of the 12 'o clock start and edges and the hitpoint
            this._vertexData[0].texCoords = this._textureCoordFromAlphaPoint(this._midPoint);
            this._vertexData[0].vertices = this._vertexFromAlphaPoint(this._midPoint);

            this._vertexData[1].texCoords = this._textureCoordFromAlphaPoint(topMid);
            this._vertexData[1].vertices = this._vertexFromAlphaPoint(topMid);

            for (i = 0; i < index; ++i) {
                var alphaPoint = this._boundaryTexCoord(i);
                this._vertexData[i + 2].texCoords = this._textureCoordFromAlphaPoint(alphaPoint);
                this._vertexData[i + 2].vertices = this._vertexFromAlphaPoint(alphaPoint);
            }
        }

        //    hitpoint will go last
        this._vertexData[this._vertexDataCount - 1].texCoords = this._textureCoordFromAlphaPoint(hit);
        this._vertexData[this._vertexDataCount - 1].vertices = this._vertexFromAlphaPoint(hit);
    },

    _updateColor:function () {
        if (!this._sprite) {
            return;
        }

        if (this._vertexData) {
            var sc = this._sprite.getQuad().tl.colors;
            for (var i = 0; i < this._vertexDataCount; ++i) {
                this._vertexData[i].colors = sc;
            }
        }
    },

    _boundaryTexCoord:function (index) {
        if (index < cc.PROGRESS_TEXTURE_COORDS_COUNT) {
            if (this._reverseDirection) {
                return cc.p((cc.PROGRESS_TEXTURE_COORDS >> (7 - (index << 1))) & 1, (cc.PROGRESS_TEXTURE_COORDS >> (7 - ((index << 1) + 1))) & 1);
            } else {
                return cc.p((cc.PROGRESS_TEXTURE_COORDS >> ((index << 1) + 1)) & 1, (cc.PROGRESS_TEXTURE_COORDS >> (index << 1)) & 1);
            }
        }
        return cc.PointZero();
    }
});

/**
 * create a progress timer object with image file name that renders the inner sprite according to the percentage
 * @param {cc.Sprite} sprite
 * @return {cc.ProgressTimer}
 * @example
 * // Example
 * var progress = cc.ProgressTimer.create('progress.png')
 */
cc.ProgressTimer.create = function (sprite) {
    var progressTimer = new cc.ProgressTimer();
    if (progressTimer.initWithSprite(sprite)) {
        return progressTimer;
    } else {
        return null;
    }
};

/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

var cc = cc = cc || {};

/** Base class for other
 */
cc.GridBase = cc.Class.extend({
    _active:null,
    _reuseGrid:null,
    _gridSize:null,
    _texture:null,
    _step:cc.p(0, 0),
    _grabber:null,
    _isTextureFlipped:null,
    /** wheter or not the grid is active */
    isActive:function () {
        return this._active;
    },
    setActive:function (active) {
        this._active = active;
        if (!active) {
            var director = cc.Director.getInstance();
            var proj = director.getProjection();
            director.setProjection(proj);
        }
    },

    /** number of times that the grid will be reused */
    getReuseGrid:function () {
        return this._reuseGrid;
    },
    setReuseGrid:function (reuseGrid) {
        this._reuseGrid = reuseGrid;
    },

    /** size of the grid */
    getGridSize:function () {
        return this._gridSize;
    },
    setGridSize:function (gridSize) {
        this._gridSize.x = parseInt(gridSize.x);
        this._gridSize.y = parseInt(gridSize.y);
    },

    /** pixels between the grids */
    getStep:function () {
        return this._step;
    },
    setStep:function (step) {
        this._step = step;
    },

    /** is texture flipped */
    isTextureFlipped:function () {
        return this._isTextureFlipped;
    },
    setIsTextureFlipped:function (flipped) {
        if (this._isTextureFlipped != flipped) {
            this._isTextureFlipped = flipped;
            this.calculateVertexPoints();
        }
    },

    initWithSize:function (gridSize, texture, flipped) {
        var argnum = arguments.length;
        if (argnum = 1) {
            var director = cc.Director.getInstance();
            var s = director.getWinSizeInPixels();

            var POTWide = cc.NextPOT(s.width);
            var POTHigh = cc.NextPOT(s.height);

            // we only use rgba8888
            var format = cc.TEXTURE_2D_PIXEL_FORMAT_RGBA8888;

            var pTextureTemp = new cc.Texture2D();
            pTextureTemp.initWithData(format, POTWide, POTHigh, s);
            if (!pTextureTemp) {
                cc.log("cocos2d: CCGrid: error creating texture");
                return false;
            }
            texture = pTextureTemp;

            flipped = false;
        }


        var ret = true;

        this._active = false;
        this._reuseGrid = 0;
        this._gridSize = gridSize;
        this._texture = texture;
        this._isTextureFlipped = flipped;

        var texSize = this._texture.getContentSizeInPixels();
        this._step.x = texSize.width / this._gridSize.x;
        this._step.y = texSize.height / this._gridSize.y;

        this._grabber = new cc.Grabber();
        if (this._grabber) {
            this._grabber.grab(this._texture);
        }
        else {
            ret = false;
        }


        this.calculateVertexPoints();

        return ret;

    },

    beforeDraw:function () {
        this.set2DProjection();
        this._grabber.beforeRender(this._texture);
    },
    afterDraw:function (target) {
        this._grabber.afterRender(this._texture);

        this.set3DProjection();

        if (target.getCamera().getDirty()) {
            var offset = target.getAnchorPointInPixels();

            //
            // XXX: Camera should be applied in the AnchorPoint
            //
            //todo gl
            //ccglTranslate(offset.x, offset.y, 0);
            target.getCamera().locate();
            //ccglTranslate(-offset.x, -offset.y, 0);
        }
//todo gl
        //glBindTexture(GL_TEXTURE_2D, this._texture.getName());

        // restore projection for default FBO .fixed bug #543 #544
        //cc.Director.getInstance().setProjection(cc.Director.getInstance().getProjection());
        //cc.Director.getInstance().applyOrientation();
        this.blit();
    },
    blit:function () {
        cc.Assert(0, "");
    },
    reuse:function () {
        cc.Assert(0, "");
    },
    calculateVertexPoints:function () {
        cc.Assert(0, "");
    },
    set2DProjection:function () {
        var winSize = cc.Director.getInstance().getWinSizeInPixels();

        //todo gl
        /* glViewport(0, 0, (GLsizei)(size.width * CC_CONTENT_SCALE_FACTOR()), (GLsizei)(size.height * CC_CONTENT_SCALE_FACTOR()) );
         kmGLMatrixMode(KM_GL_PROJECTION);
         kmGLLoadIdentity();

         kmMat4 orthoMatrix;
         kmMat4OrthographicProjection(&orthoMatrix, 0, size.width * CC_CONTENT_SCALE_FACTOR(), 0, size.height * CC_CONTENT_SCALE_FACTOR(), -1, 1);
         kmGLMultMatrix( &orthoMatrix );

         kmGLMatrixMode(KM_GL_MODELVIEW);
         kmGLLoadIdentity();


         ccSetProjectionMatrixDirty();*/
    }
});
cc.GridBase.create = function () {
    return new cc.GridBase();
};

/**
 cc.Grid3D is a 3D grid implementation. Each vertex has 3 dimensions: x,y,z
 */
cc.Grid3D = cc.GridBase.extend({
    _texCoordinates:null,
    _vertices:null,
    _originalVertices:null,
    _indices:null,
    /** returns the vertex at a given position */
    vertex:function (pos) {
        var index = (pos.x * (this._gridSize.y + 1) + pos.y) * 3;
        var vertArray = this._vertices;

        var vert = new cc.Vertex3F(vertArray[index], vertArray[index + 1], vertArray[index + 2]);

        return vert;
    },
    /** returns the original (non-transformed) vertex at a given position */
    originalVertex:function (pos) {
        var index = (pos.x * (this._gridSize.y + 1) + pos.y) * 3;
        var vertArray = this._originalVertices;

        var vert = new cc.Vertex3F(vertArray[index], vertArray[index + 1], vertArray[index + 2]);

        return vert;
    },
    /** sets a new vertex at a given position */
    setVertex:function (pos, vertex) {
        var index = (pos.x * (this._gridSize.y + 1) + pos.y) * 3;
        var vertArray = this._vertices;
        vertArray[index] = vertex.x;
        vertArray[index + 1] = vertex.y;
        vertArray[index + 2] = vertex.z;
    },

    blit:function () {
        var n = this._gridSize.x * this._gridSize.y;

        // Default GL states: GL_TEXTURE_2D, GL_VERTEX_ARRAY, GL_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY
        // Needed states: GL_TEXTURE_2D, GL_VERTEX_ARRAY, GL_TEXTURE_COORD_ARRAY
        // Unneeded states: GL_COLOR_ARRAY
        //todo gl
        /*glDisableClientState(GL_COLOR_ARRAY);

         glVertexPointer(3, GL_FLOAT, 0, this._vertices);
         glTexCoordPointer(2, GL_FLOAT, 0, this._texCoordinates);
         glDrawElements(GL_TRIANGLES, n*6, GL_UNSIGNED_SHORT, this._indices);

         // restore default GL state
         glEnableClientState(GL_COLOR_ARRAY);*/
    },
    reuse:function () {
        if (this._reuseGrid > 0) {
            --this._reuseGrid;
        }
    },
    calculateVertexPoints:function () {
        var width = this._texture.getPixelsWide();
        var height = this._texture.getPixelsHigh();
        var imageH = this._texture.getContentSizeInPixels().height;

        var numQuads = this._gridSize.x * this._gridSize.y;

        this._vertices = [];
        this._originalVertices = [];
        this._texCoordinates = [];
        this._indices = [];

        var vertArray = this._vertices;
        var texArray = this._texCoordinates;
        var idxArray = this._indices;

        var x, y;

        for (x = 0; x < this._gridSize.x; x++) {
            for (y = 0; y < this._gridSize.y; y++) {
                var x1 = x * this._step.x;
                var x2 = x1 + this._step.x;
                var y1 = y * this._step.y;
                var y2 = y1 + this._step.y;

                vertArray[x * y] = x1;
                vertArray[x * y + 1] = y1;
                vertArray[x * y + 2] = 0;
                vertArray[x * y + 3] = x2;
                vertArray[x * y + 4] = y1;
                vertArray[x * y + 5] = 0;
                vertArray[x * y + 6] = x1;
                vertArray[x * y + 7] = y2;
                vertArray[x * y + 8] = 0;
                vertArray[x * y + 9] = x2;
                vertArray[x * y + 10] = y2;
                vertArray[x * y + 11] = 0;

                var newY1 = y1;
                var newY2 = y2;

                if (this._isTextureFlipped) {
                    newY1 = imageH - y1;
                    newY2 = imageH - y2;
                }

                texArray[x * y + 12] = x1 / width;
                texArray[x * y + 13] = newY1 / height;
                texArray[x * y + 14] = x2 / width;
                texArray[x * y + 15] = newY1 / height;
                texArray[x * y + 16] = x1 / width;
                texArray[x * y + 17] = newY2 / height;
                texArray[x * y + 18] = x2 / width;
                texArray[x * y + 19] = newY2 / height;
            }
        }

        for (x = 0; x < numQuads; x++) {
            idxArray[x * 6 + 0] = x * 4 + 0;
            idxArray[x * 6 + 1] = x * 4 + 1;
            idxArray[x * 6 + 2] = x * 4 + 2;

            idxArray[x * 6 + 3] = x * 4 + 1;
            idxArray[x * 6 + 4] = x * 4 + 2;
            idxArray[x * 6 + 5] = x * 4 + 3;
        }

    }
});

cc.Grid3D.create = function (gridSize, texture, flipped) {

};

/**
 cc.TiledGrid3D is a 3D grid implementation. It differs from Grid3D in that
 the tiles can be separated from the grid.
 */
cc.TiledGrid3D = cc.GridBase.extend({
    _texCoordinates:null,
    _vertices:null,
    _originalVertices:null,
    _indices:null,
    /** returns the tile at the given position */
    tile:function (pos) {
        var idx = (this._gridSize.y * pos.x + pos.y) * 4 * 3;
        var vertArray = this._vertices;
        var ret = new cc.Quad3();
        return ret;
    },
    /** returns the original tile (untransformed) at the given position */
    originalTile:function (pos) {
        var idx = (this._gridSize.y * pos.x + pos.y) * 4 * 3;
        var vertArray = this._originalVertices;

        var ret = new cc.Quad3(vertArray[idx], vertArray[idx + 1], vertArray[idx + 2], vertArray[idx + 3]);

        return ret;
    },
    /** sets a new tile */
    setTile:function (pos, coords) {
        var idx = (this._gridSize.y * pos.x + pos.y) * 4 * 3;
        var vertArray = this._vertices;
        vertArray[idx] = coords;
    },

    blit:function () {
        var n = this._gridSize.x * this._gridSize.y;

        // Default GL states: GL_TEXTURE_2D, GL_VERTEX_ARRAY, GL_COLOR_ARRAY, GL_TEXTURE_COORD_ARRAY
        // Needed states: GL_TEXTURE_2D, GL_VERTEX_ARRAY, GL_TEXTURE_COORD_ARRAY
        // Unneeded states: GL_COLOR_ARRAY
        //todo gl
        /*glDisableClientState(GL_COLOR_ARRAY);

         glVertexPointer(3, GL_FLOAT, 0, this._vertices);
         glTexCoordPointer(2, GL_FLOAT, 0, this._texCoordinates);
         glDrawElements(GL_TRIANGLES, (GLsizei)n*6, GL_UNSIGNED_SHORT, this._indices);

         // restore default GL state
         glEnableClientState(GL_COLOR_ARRAY);*/
    },
    reuse:function () {
        if (this._reuseGrid > 0) {
            var numQuads = this._gridSize.x * this._gridSize.y;
            for (var i = 0, len = numQuads.length * 12; i < len; i++) {
                this._originalVertices.push(this._vertices[i])
            }
            //todo fix
            //memcpy(this._originalVertices, this._vertices, numQuads * 12 * sizeof(GLfloat));
            --this._reuseGrid;
        }
    },
    calculateVertexPoints:function () {
        var width = this._texture.getPixelsWide();
        var height = this._texture.getPixelsHigh();
        var imageH = this._texture.getContentSizeInPixels().height;

        var numQuads = this._gridSize.x * this._gridSize.y;

        this._vertices = [];
        this._originalVertices = [];
        this._texCoordinates = [];
        this._indices = [];

        var vertArray = this._vertices;
        var texArray = this._texCoordinates;
        var idxArray = this._indices;

        var x, y;

        for (x = 0; x < this._gridSize.x; x++) {
            for (y = 0; y < this._gridSize.y; y++) {
                var x1 = x * this._step.x;
                var x2 = x1 + this._step.x;
                var y1 = y * this._step.y;
                var y2 = y1 + this._step.y;

                vertArray[x * y] = x1;
                vertArray[x * y + 1] = y1;
                vertArray[x * y + 2] = 0;
                vertArray[x * y + 3] = x2;
                vertArray[x * y + 4] = y1;
                vertArray[x * y + 5] = 0;
                vertArray[x * y + 6] = x1;
                vertArray[x * y + 7] = y2;
                vertArray[x * y + 8] = 0;
                vertArray[x * y + 9] = x2;
                vertArray[x * y + 10] = y2;
                vertArray[x * y + 11] = 0;
                var newY1 = y1;
                var newY2 = y2;

                if (this._isTextureFlipped) {
                    newY1 = imageH - y1;
                    newY2 = imageH - y2;
                }

                texArray[x * y + 12] = x1 / width;
                texArray[x * y + 13] = newY1 / height;
                texArray[x * y + 14] = x2 / width;
                texArray[x * y + 15] = newY1 / height;
                texArray[x * y + 16] = x1 / width;
                texArray[x * y + 17] = newY2 / height;
                texArray[x * y + 18] = x2 / width;
                texArray[x * y + 19] = newY2 / height;
            }
        }

        for (x = 0; x < numQuads; x++) {
            idxArray[x * 6 + 0] = x * 4 + 0;
            idxArray[x * 6 + 1] = x * 4 + 1;
            idxArray[x * 6 + 2] = x * 4 + 2;

            idxArray[x * 6 + 3] = x * 4 + 1;
            idxArray[x * 6 + 4] = x * 4 + 2;
            idxArray[x * 6 + 5] = x * 4 + 3;
        }
        for (var i = 0, len = numQuads.length * 12; i < len; i++) {
            this._originalVertices.push(this._vertices[i])
        }
        //todo fix
        //memcpy(this._originalVertices, this._vertices, numQuads * 12 * sizeof(GLfloat));
    }
});

cc.TiledGrid3D.create = function (gridSize, texture, flipped) {
    var ret = new cc.TiledGrid3D();
    ret.initWithSize(gridSize, texture, flipped)
    return ret;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

var cc = cc = cc || {};

/** FBO class that grabs the the contents of the screen */
cc.Grabber = cc.Class.extend({
    _fbo:0,
    _oldFBO:0,
    _glesVersion:null,
    ctor:function () {
        // generate FBO
        //todo gl
        //ccglGenFramebuffers(1, this._fbo);
    },
    grab:function (texture) {
        //todo gl
        /*glGetIntegerv(CC_GL_FRAMEBUFFER_BINDING, this._oldFBO);

         // bind
         ccglBindFramebuffer(CC_GL_FRAMEBUFFER, this._fbo);

         // associate texture with FBO
         ccglFramebufferTexture2D(CC_GL_FRAMEBUFFER, CC_GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D,
         texture.getName(), 0);

         // check if it worked (probably worth doing :) )
         var status = ccglCheckFramebufferStatus(CC_GL_FRAMEBUFFER);
         if (status != CC_GL_FRAMEBUFFER_COMPLETE) {
         cc.log("Frame Grabber: could not attach texture to frmaebuffer");
         }

         ccglBindFramebuffer(CC_GL_FRAMEBUFFER, this._oldFBO);*/
    },
    beforeRender:function (texture) {
        //todo gl
        /*glGetIntegerv(CC_GL_FRAMEBUFFER_BINDING, this._oldFBO);
         ccglBindFramebuffer(CC_GL_FRAMEBUFFER, this._fbo);

         // BUG XXX: doesn't work with RGB565.

         */
        /*glClearColor(0, 0, 0, 0);*/
        /*

         // BUG #631: To fix #631, uncomment the lines with #631
         // Warning: But it CCGrabber won't work with 2 effects at the same time
         glClearColor(0.0, 0.0, 0.0, 1.0);	// #631

         glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

         glColorMask(true, true, true, false);	// #631*/
    },
    afterRender:function (texture) {
        //todo gl
        /* ccglBindFramebuffer(CC_GL_FRAMEBUFFER, this._oldFBO);
         glColorMask(true, true, true, true);	// #631*/
    }
});
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/** Default Action tag
 * @constant
 * @type {Number}
 */

cc.ACTION_TAG_INVALID = -1;

/**
 * Base class for cc.Action objects.
 * @class
 * @extends cc.Class
 */
cc.Action = cc.Class.extend(/** @lends cc.Action# */{
    //***********variables*************
    _originalTarget:null,

    /** The "target".
     The target will be set with the 'startWithTarget' method.
     When the 'stop' method is called, target will be set to nil.
     The target is 'assigned', it is not 'retained'.
     */
    _target:null,
    _tag:cc.ACTION_TAG_INVALID,

    //**************Public Functions***********
    /**
     * @return {String}
     */
    description:function () {
        return "<cc.Action | Tag = " + this._tag + ">";
    },

    /**
     * to copy object with deep copy.
     * @param {object} zone
     * @return {object}
     */
    copyWithZone:function (zone) {
        return this.copy();
    },

    /**
     * to copy object with deep copy.
     * @return {object}
     */
    copy:function () {
        return cc.clone(this);
    },

    /**
     * return true if the action has finished
     * @return {Boolean}
     */
    isDone:function () {
        return true;
    },

    /**
     * called before the action start. It will also set the target.
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._originalTarget = target;
        this._target = target;
    },

    /**
     * called after the action has finished. It will set the 'target' to nil.
     * IMPORTANT: You should never call "action stop" manually. Instead, use: "target.stopAction(action);"
     */
    stop:function () {
        this._target = null;
    },
    /** called every frame with it's delta time. DON'T override unless you know what you are doing.
     *
     * @param {Number} dt
     */

    step:function (dt) {
        cc.log("[Action step]. override me");
    },

    /**
     <p>called once per frame. time a value between 0 and 1  </P>

     <p>For example:  <br/>
     - 0 means that the action just started <br/>
     - 0.5 means that the action is in the middle<br/>
     - 1 means that the action is over </P>
     * @param {Number}  time
     */
    update:function (time) {
        cc.log("[Action update]. override me");
    },

    /**
     *
     * @return {cc.Node}
     */
    getTarget:function () {
        return this._target;
    },

    /** The action will modify the target properties.
     *
     * @param {cc.Node} target
     */
    setTarget:function (target) {
        this._target = target;
    },

    /**
     *
     * @return {cc.Node}
     */
    getOriginalTarget:function () {
        return this._originalTarget;
    },

    /** Set the original target, since target can be nil. <br/>
     * Is the target that were used to run the action.  <br/>
     * Unless you are doing something complex, like cc.ActionManager, you should NOT call this method. <br/>
     * The target is 'assigned', it is not 'retained'. <br/>
     * @param {cc.Node} originalTarget
     */
    setOriginalTarget:function (originalTarget) {
        this._originalTarget = originalTarget;
    },

    /**
     *
     * @return {Number}
     */
    getTag:function () {
        return this._tag;
    },

    /**
     *
     * @param {Number} tag
     */
    setTag:function (tag) {
        this._tag = tag;
    }
});
/** Allocates and initializes the action
 * @returns {cc.Action}
 * @example
 * // example
 * var action = cc.Action.create();
 */
cc.Action.create = function () {
    return new cc.Action();
};


/**
 * <p>Base class actions that do have a finite time duration.<br/>
 * Possible actions: <br/>
 * - An action with a duration of 0 seconds<br/>
 * - An action with a duration of 35.5 seconds  </p>

 * Infinite time actions are valid
 * @class
 * @extends cc.Action
 */
cc.FiniteTimeAction = cc.Action.extend(/** @lends cc.FiniteTimeAction# */{
    //! duration in seconds
    _duration:0,

    /** get duration in seconds of the action
     *
     * @return {Number}
     */
    getDuration:function () {
        return this._duration;
    },

    /** set duration in seconds of the action
     *
     * @param {Number} duration
     */
    setDuration:function (duration) {
        this._duration = duration;
    },

    /** returns a reversed action
     *
     * @return {Null}
     */
    reverse:function () {
        cc.log("cocos2d: FiniteTimeAction#reverse: Implement me");
        return null;
    }
});


/**
 * Changes the speed of an action, making it take longer (speed>1)
 * or less (speed<1) time. <br/>
 * Useful to simulate 'slow motion' or 'fast forward' effect.
 * @warning This action can't be Sequenceable because it is not an cc.IntervalAction
 * @class
 * @extends cc.Action
 */
cc.Speed = cc.Action.extend(/** @lends cc.Speed# */{
    _speed:0.0,
    _innerAction:null,

    /**
     * @return {Number}
     */
    getSpeed:function () {
        return this._speed;
    },

    /** alter the speed of the inner function in runtime
     * @param {Number} speed
     */
    setSpeed:function (speed) {
        this._speed = speed;
    },

    /** initializes the action
     * @param {cc.ActionInterval} action
     * @param {Number} speed
     * @return {Boolean}
     */
    initWithAction:function (action, speed) {
        cc.Assert(action != null, "");
        this._innerAction = action;
        this._speed = speed;
        return true;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        //this._super(target);
        cc.Action.prototype.startWithTarget.call(this, target);
        this._innerAction.startWithTarget(target);
    },

    /**
     *  Stop the action
     */
    stop:function () {
        this._innerAction.stop();
        cc.Action.prototype.stop.call(this);
    },

    /**
     * @param {Number} dt
     */
    step:function (dt) {
        this._innerAction.step(dt * this._speed);
    },

    /**
     * @return {Boolean}
     */
    isDone:function () {
        return this._innerAction.isDone();
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return (cc.Speed.create(this._innerAction.reverse(), this._speed));
    },

    /**
     *
     * @param {cc.ActionInterval} action
     */
    setInnerAction:function (action) {
        if (this._innerAction != action) {
            this._innerAction = action;
        }
    },

    /**
     *
     * @return {cc.ActionInterval}
     */
    getInnerAction:function () {
        return this._innerAction;
    }
});
/** creates the action
 *
 * @param {cc.ActionInterval} action
 * @param {Number} speed
 * @return {cc.Speed}
 */
cc.Speed.create = function (action, speed) {
    var ret = new cc.Speed();
    if (ret && ret.initWithAction(action, speed)) {
        return ret;
    }
    return null;
};

/**
 * cc.Follow is an action that "follows" a node.

 * @example
 * //example
 * //Instead of using cc.Camera as a "follower", use this action instead.
 * layer.runAction(cc.Follow.actionWithTarget(hero));

 * @class
 * @extends cc.Action
 */
cc.Follow = cc.Action.extend(/** @lends cc.Follow# */{
    /**
     * @return {Boolean}
     */
    isBoundarySet:function () {
        return this._boundarySet;
    },

    /** alter behavior - turn on/off boundary
     * @param {Boolean} value
     */
    setBoudarySet:function (value) {
        this._boundarySet = value;
    },

    /** initializes the action
     * initializes the action with a set boundary
     * @param {cc.Node} followedNode
     * @param {cc.Rect} rect
     * @return {Boolean}
     */
    initWithTarget:function (followedNode, rect) {
        cc.Assert(followedNode != null, "");

        rect = rect || cc.RectZero();
        this._followedNode = followedNode;

        this._boundarySet = cc.Rect.CCRectEqualToRect(rect, cc.RectZero());

        this._boundaryFullyCovered = false;

        var winSize = cc.Director.getInstance().getWinSize();
        this._fullScreenSize = cc.p(winSize.width, winSize.height);
        this._halfScreenSize = cc.pMult(this._fullScreenSize, 0.5);

        if (this._boundarySet) {
            this.leftBoundary = -((rect.origin.x + rect.size.width) - this._fullScreenSize.x);
            this.rightBoundary = -rect.origin.x;
            this.topBoundary = -rect.origin.y;
            this.bottomBoundary = -((rect.origin.y + rect.size.height) - this._fullScreenSize.y);

            if (this.rightBoundary < this.leftBoundary) {
                // screen width is larger than world's boundary width
                //set both in the middle of the world
                this.rightBoundary = this.leftBoundary = (this.leftBoundary + this.rightBoundary) / 2;
            }
            if (this.topBoundary < this.bottomBoundary) {
                // screen width is larger than world's boundary width
                //set both in the middle of the world
                this.topBoundary = this.bottomBoundary = (this.topBoundary + this.bottomBoundary) / 2;
            }

            if ((this.topBoundary == this.bottomBoundary) && (this.leftBoundary == this.rightBoundary)) {
                this._boundaryFullyCovered = true;
            }
        }
        return true;
    },

    /**
     * @param {Number} dt
     */
    step:function (dt) {
        if (this._boundarySet) {
            // whole map fits inside a single screen, no need to modify the position - unless map boundaries are increased
            if (this._boundaryFullyCovered)
                return;

            var tempPos = cc.pSub(this._halfScreenSize, this._followedNode.getPosition());

            this._target.setPosition(cc.p(cc.clampf(tempPos.x, this.leftBoundary, this.rightBoundary),
                cc.clampf(tempPos.y, this.bottomBoundary, this.topBoundary)));
        } else {
            this._target.setPosition(cc.pSub(this._halfScreenSize, this._followedNode.getPosition()));
        }
    },

    /**
     * @return {Boolean}
     */
    isDone:function () {
        return ( !this._followedNode.isRunning() );
    },

    /**
     * Stop the action.
     */
    stop:function () {
        this._target = null;
        cc.Action.prototype.stop.call(this);
    },

    // node to follow
    _followedNode:null,
    // whether camera should be limited to certain area
    _boundarySet:false,
    // if screen size is bigger than the boundary - update not needed
    _boundaryFullyCovered:false,
    // fast access to the screen dimensions
    _halfScreenSize:null,
    _fullScreenSize:null,

    /** world leftBoundary
     * @Type {Number}
     */
    leftBoundary:0.0,
    /** world rightBoundary
     * @Type Number
     */
    rightBoundary:0.0,
    /** world topBoundary
     * @Type Number
     */
    topBoundary:0.0,
    /** world bottomBoundary
     * @Type {Number}
     */
    bottomBoundary:0.0
});
/** creates the action with a set boundary <br/>
 * creates the action with no boundary set
 * @param {cc.Node} followedNode
 * @param {cc.Rect} rect
 * @return {cc.Follow|Null} returns the cc.Follow object on success
 * @example
 * // example
 * // creates the action with a set boundary
 * var sprite = cc.Sprite.create("spriteFileName");
 * var followAction = cc.Follow.create(sprite, cc.rect(0, 0, s.width * 2 - 100, s.height));
 * this.runAction(followAction);
 *
 * // creates the action with no boundary set
 * var sprite = cc.Sprite.create("spriteFileName");
 * var followAction = cc.Follow.create(sprite);
 * this.runAction(followAction);
 */
cc.Follow.create = function (followedNode, rect) {
    rect = rect || new cc.RectZero();
    var ret = new cc.Follow();
    if (rect != null && ret && ret.initWithTarget(followedNode, rect)) {
        return ret;
    }
    else if (ret && ret.initWithTarget(followedNode)) {
        return ret;
    }
    return null;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * <p> An interval action is an action that takes place within a certain period of time. <br/>
 * It has an start time, and a finish time. The finish time is the parameter<br/>
 * duration plus the start time.</p>
 *
 * <p>These CCActionInterval actions have some interesting properties, like:<br/>
 * - They can run normally (default)  <br/>
 * - They can run reversed with the reverse method   <br/>
 * - They can run with the time altered with the Accelerate, AccelDeccel and Speed actions. </p>
 *
 * <p>For example, you can simulate a Ping Pong effect running the action normally and<br/>
 * then running it again in Reverse mode. </p>
 *
 * @class
 * @extends cc.FiniteTimeAction
 * @Example
 * // example
 * var pingPongAction = cc.Sequence.create(action, action.reverse());
 */
cc.ActionInterval = cc.FiniteTimeAction.extend(/** @lends cc.ActionInterval# */{
    _elapsed:0,
    _firstTick:false,

    /** how many seconds had elapsed since the actions started to run.
     * @return {Number}
     */
    getElapsed:function () {
        return this._elapsed;
    },

    /** initializes the action
     * @param {Number} d duration in seconds
     * @return {Boolean}
     */
    initWithDuration:function (d) {
        this._duration = (d == 0) ? cc.FLT_EPSILON : d;
        // prevent division by 0
        // This comparison could be in step:, but it might decrease the performance
        // by 3% in heavy based action games.
        this._elapsed = 0;
        this._firstTick = true;
        return true;
    },

    /** returns true if the action has finished
     * @return {Boolean}
     */
    isDone:function () {
        return (this._elapsed >= this._duration);
    },

    /**
     * @param {Number} dt delta time in seconds
     */
    step:function (dt) {
        if (this._firstTick) {
            this._firstTick = false;
            this._elapsed = 0;
        } else {
            this._elapsed += dt;
        }
        //this.update((1 > (this._elapsed / this._duration)) ? this._elapsed / this._duration : 1);
        //this.update(Math.max(0, Math.min(1, this._elapsed / Math.max(this._duration, cc.FLT_EPSILON))));
        var t = this._elapsed / (this._duration > 0.0000001192092896 ? this._duration : 0.0000001192092896);
        t = (1 > t ? t : 1);
        this.update(t > 0 ? t : 0);
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        //this._super(target);
        cc.Action.prototype.startWithTarget.call(this, target)
        this._elapsed = 0;
        this._firstTick = true;
    },

    /**
     * @return {Null}
     */
    reverse:function () {
        cc.Assert(false, "cc.IntervalAction: reverse not implemented.");
        return null;
    },

    /**
     * @param {Number} amp
     */
    setAmplitudeRate:function (amp) {
        // Abstract class needs implementation
        cc.Assert(0, 'Actioninterval setAmplitudeRate');
    },

    /**
     * @return {Number}
     */
    getAmplitudeRate:function () {
        // Abstract class needs implementation
        cc.Assert(0, 'Actioninterval getAmplitudeRate');
        return 0;
    }
});

/**
 * @param {Number} d duration in seconds
 * @return {cc.ActionInterval}
 * @example
 * // example
 * var actionInterval = cc.ActionInterval.create(3);
 */
cc.ActionInterval.create = function (d) {
    var action = new cc.ActionInterval();
    action.initWithDuration(d);
    return action;
};


/** Runs actions sequentially, one after another
 * @class
 * @extends cc.ActionInterval
 */
cc.Sequence = cc.ActionInterval.extend(/** @lends cc.Sequence# */{
    _actions:null,
    _split:null,
    _last:0,

    /**
     * Constructor
     */
    ctor:function () {
        this._actions = [];
    },

    /** initializes the action <br/>
     * @param {cc.FiniteTimeAction} actionOne
     * @param {cc.FiniteTimeAction} actionTwo
     * @return {Boolean}
     */
    initOneTwo:function (actionOne, actionTwo) {
        cc.Assert(actionOne != null, "Sequence.initOneTwo");
        cc.Assert(actionTwo != null, "Sequence.initOneTwo");

        var one = actionOne.getDuration();
        var two = actionTwo.getDuration();
        if (isNaN(one) || isNaN(two)) {
            console.log(actionOne);
            console.log(actionTwo);
        }
        var d = actionOne.getDuration() + actionTwo.getDuration();
        this.initWithDuration(d);

        this._actions[0] = actionOne;
        this._actions[1] = actionTwo;

        return true;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        //this._super(target);
        this._split = this._actions[0].getDuration() / this._duration;
        this._last = -1;
    },

    /**
     * stop the action
     */
    stop:function () {
        // Issue #1305
        if (this._last != -1) {
            this._actions[this._last].stop();
        }
        cc.Action.prototype.stop.call(this);
    },

    /**
     * @param {Number} time  time in seconds
     */
    update:function (time) {
        var new_t, found = 0;
        if (time < this._split) {
            // action[0]
            //found = 0;
            new_t = (this._split) ? time / this._split : 1;
        } else {
            // action[1]
            found = 1;
            new_t = (this._split == 1) ? 1 : (time - this._split) / (1 - this._split);

            if (this._last == -1) {
                // action[0] was skipped, execute it.
                this._actions[0].startWithTarget(this._target);
                this._actions[0].update(1);
                this._actions[0].stop();
            }
            if (!this._last) {
                // switching to action 1. stop action 0.
                this._actions[0].update(1);
                this._actions[0].stop();
            }
        }

        if (this._last != found) {
            this._actions[found].startWithTarget(this._target);
        }
        this._actions[found].update(new_t);
        this._last = found;
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.Sequence._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());
    },

    /**
     * to copy object with deep copy.
     * @return {object}
     */
    copy:function () {
        return cc.Sequence._actionOneTwo(this._actions[0].copy(), this._actions[1].copy() );
    }
});
/** helper constructor to create an array of sequenceable actions
 * @param {Array|cc.FiniteTimeAction} tempArray
 * @return {cc.FiniteTimeAction}
 * @example
 * // example
 * // create sequence with actions
 * var seq = cc.Sequence.create(act1, act2);
 *
 * // create sequence with array
 * var seq = cc.Sequence.create(actArray);
 */
cc.Sequence.create = function (/*Multiple Arguments*/tempArray) {
    var paraArray = (tempArray instanceof Array) ? tempArray : arguments;
    var prev = paraArray[0];
    for (var i = 1; i < paraArray.length; i++) {
        if (paraArray[i]) {
            prev = cc.Sequence._actionOneTwo(prev, paraArray[i]);
        }
    }
    return prev;
};

/** creates the action
 * @param {cc.FiniteTimeAction} actionOne
 * @param {cc.FiniteTimeAction} actionTwo
 * @return {cc.Sequence}
 * @private
 */
cc.Sequence._actionOneTwo = function (actionOne, actionTwo) {
    var sequence = new cc.Sequence();
    sequence.initOneTwo(actionOne, actionTwo);
    return sequence;
};


/** Repeats an action a number of times.
 * To repeat an action forever use the CCRepeatForever action.
 * @class
 * @extends cc.ActionInterval
 */
cc.Repeat = cc.ActionInterval.extend(/** @lends cc.Repeat# */{
    _times:0,
    _total:0,
    _nextDt:0,
    _actionInstant:false,
    _innerAction:null, //CCFiniteTimeAction

    /**
     * @param {cc.FiniteTimeAction} action
     * @param {Number} times
     * @return {Boolean}
     */
    initWithAction:function (action, times) {
        var duration = action.getDuration() * times;

        if (this.initWithDuration(duration)) {
            this._times = times;
            this._innerAction = action;

            if (action instanceof cc.ActionInstant) {
                this._times -= 1;
            }

            this._total = 0;
            return true;
        }
        return false;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._total = 0;
        this._nextDt = this._innerAction.getDuration() / this._duration;
        //this._super(target);
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._innerAction.startWithTarget(target);
    },

    /**
     * stop the action
     */
    stop:function () {
        this._innerAction.stop();
        cc.Action.prototype.stop.call(this);
    },

    /**
     * @param {Number} time time in seconds
     */
    update:function (time) {
        if (time >= this._nextDt) {
            while (time > this._nextDt && this._total < this._times) {
                this._innerAction.update(1);
                this._total++;
                this._innerAction.stop();
                this._innerAction.startWithTarget(this._target);
                this._nextDt += this._innerAction.getDuration() / this._duration;
            }

            // fix for issue #1288, incorrect end value of repeat
            if (time >= 1.0 && this._total < this._times) {
                this._total++;
            }

            // don't set a instantaction back or update it, it has no use because it has no duration
            if (this._actionInstant) {
                if (this._total == this._times) {
                    this._innerAction.update(1);
                    this._innerAction.stop();
                } else {
                    // issue #390 prevent jerk, use right update
                    this._innerAction.update(time - (this._nextDt - this._innerAction.getDuration() / this._duration));
                }
            }
        } else {
            this._innerAction.update((time * this._times) % 1.0);
        }
    },

    /**
     * @return {Boolean}
     */
    isDone:function () {
        return this._total == this._times;
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.Repeat.create(this._innerAction.reverse(), this._times);
    },

    /**
     * @param {cc.FiniteTimeAction} action
     */
    setInnerAction:function (action) {
        if (this._innerAction != action) {
            this._innerAction = action;
        }
    },

    /**
     * @return {cc.FiniteTimeAction}
     */
    getInnerAction:function () {
        return this._innerAction;
    }
});
/** creates a CCRepeat action. Times is an unsigned integer between 1 and pow(2,30)
 * @param {cc.FiniteTimeAction} action
 * @param {Number} times
 * @return {cc.Repeat}
 * @example
 * // example
 * var rep = cc.Repeat.create(cc.Sequence.create(jump2, jump1), 5);
 */
cc.Repeat.create = function (action, times) {
    var repeat = new cc.Repeat();
    repeat.initWithAction(action, times);
    return repeat;
};


/**  Repeats an action for ever.  <br/>
 * To repeat the an action for a limited number of times use the Repeat action. <br/>
 * @warning This action can't be Sequenceable because it is not an IntervalAction
 * @class
 * @extends cc.ActionInterval
 */

cc.RepeatForever = cc.ActionInterval.extend(/** @lends cc.RepeatForever# */{
    _innerAction:null, //CCActionInterval

    /**
     * @param {cc.ActionInterval} action
     * @return {Boolean}
     */
    initWithAction:function (action) {
        cc.Assert(action != null, "");

        this._innerAction = action;
        return true;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        //this._super(target);
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._innerAction.startWithTarget(target);
    },

    /**
     * @param dt delta time in seconds
     */
    step:function (dt) {
        this._innerAction.step(dt);
        if (this._innerAction.isDone()) {
            //var diff = this._innerAction.getElapsed() - this._innerAction.getDuration();
            this._innerAction.startWithTarget(this._target);
            // to prevent jerk. issue #390 ,1247
            //this._innerAction.step(0);
            //this._innerAction.step(diff);
            this._innerAction.step(this._innerAction.getElapsed() - this._innerAction.getDuration());
        }
    },

    /**
     * @return {Boolean}
     */
    isDone:function () {
        return false;
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return (cc.RepeatForever.create(this._innerAction.reverse()));
    },

    /**
     *
     * @param {cc.ActionInterval} action
     */
    setInnerAction:function (action) {
        if (this._innerAction != action) {
            this._innerAction = action;
        }
    },

    /**
     * @return {cc.ActionInterval}
     */
    getInnerAction:function () {
        return this._innerAction;
    }
});
/**
 * Repeat the acton forever
 * @param action
 * @return {cc.RepeatForever}
 * @example
 * // example
 * var repeat = cc.RepeatForever.create(cc.RotateBy.create(1.0, 360));
 */
cc.RepeatForever.create = function (action) {
    var ret = new cc.RepeatForever();
    if (ret && ret.initWithAction(action)) {
        return ret;
    }
    return null;
};


/** Spawn a new action immediately
 * @class
 * @extends cc.ActionInterval
 */
cc.Spawn = cc.ActionInterval.extend(/** @lends cc.Spawn# */{
    /** initializes the Spawn action with the 2 actions to spawn
     * @param {cc.FiniteTimeAction} action1
     * @param {cc.FiniteTimeAction} action2
     * @return {Boolean}
     */
    initOneTwo:function (action1, action2) {
        cc.Assert(action1 != null, "no action1");
        cc.Assert(action2 != null, "no action2");

        var ret = false;

        var d1 = action1.getDuration();
        var d2 = action2.getDuration();

        if (this.initWithDuration(Math.max(d1, d2))) {
            this._one = action1;
            this._two = action2;

            if (d1 > d2) {
                this._two = cc.Sequence._actionOneTwo(action2, cc.DelayTime.create(d1 - d2));
            } else if (d1 < d2) {
                this._one = cc.Sequence._actionOneTwo(action1, cc.DelayTime.create(d2 - d1));
            }

            ret = true;
        }
        return ret;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._one.startWithTarget(target);
        this._two.startWithTarget(target);
    },

    /**
     * Stop the action
     */
    stop:function () {
        this._one.stop();
        this._two.stop();
        cc.Action.prototype.stop.call(this);
    },

    /**
     * @param {Number} time time in seconds
     */
    update:function (time) {
        if (this._one) {
            this._one.update(time);
        }
        if (this._two) {
            this._two.update(time);
        }
    },

    /**
     * @return {cc.FiniteTimeAction}
     */
    reverse:function () {
        return cc.Spawn._actionOneTwo(this._one.reverse(), this._two.reverse());
    },
    _one:null,
    _two:null
});

/**
 * @param {Array|cc.FiniteTimeAction}tempArray
 * @return {cc.FiniteTimeAction}
 * @example
 * // example
 * var action = cc.Spawn.create(cc.JumpBy.create(2, cc.p(300, 0), 50, 4), cc.RotateBy.create(2, 720));
 */
cc.Spawn.create = function (/*Multiple Arguments*/tempArray) {
    var paramArray = (tempArray instanceof Array) ? tempArray : arguments;
    var prev = paramArray[0];
    for (var i = 1; i < paramArray.length; i++) {
        if (paramArray[i] != null) {
            prev = this._actionOneTwo(prev, paramArray[i]);
        }
    }
    return prev;
};

/**
 * @param {cc.FiniteTimeAction} action1
 * @param {cc.FiniteTimeAction} action2
 * @return {cc.Spawn}
 * @private
 */
cc.Spawn._actionOneTwo = function (action1, action2) {
    var pSpawn = new cc.Spawn();
    pSpawn.initOneTwo(action1, action2);

    return pSpawn;
};


/** Rotates a cc.Node object to a certain angle by modifying it's
 * rotation attribute. <br/>
 * The direction will be decided by the shortest angle.
 * @class
 * @extends cc.ActionInterval
 */
cc.RotateTo = cc.ActionInterval.extend(/** @lends cc.RotateTo# */{
    _dstAngle:0,
    _startAngle:0,
    _diffAngle:0,
    /**
     * @param {Number} duration
     * @param {Number} deltaAngle
     * @return {Boolean}
     */
    initWithDuration:function (duration, deltaAngle) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
            this._dstAngle = deltaAngle;
            return true;
        }

        return false;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);

        this._startAngle = target.getRotation();

        if (this._startAngle > 0) {
            this._startAngle = this._startAngle % 360.0;
        }
        else {
            this._startAngle = this._startAngle % 360.0;
        }

        this._diffAngle = this._dstAngle - this._startAngle;
        if (this._diffAngle > 180) {
            this._diffAngle -= 360;
        }

        if (this._diffAngle < -180) {
            this._diffAngle += 360;
        }
    },

    /**
     * RotateTo reverse not implemented
     */
    reverse:function () {
        cc.Assert(0, "RotateTo reverse not implemented");
    },

    /**
     * @param {Number} time time in seconds
     */
    update:function (time) {
        if (this._target) {
            this._target.setRotation(this._startAngle + this._diffAngle * time);
        }
    }
});

/**
 * @param {Number} duration duration in seconds
 * @param {Number} deltaAngle deltaAngle in degrees.
 * @return {cc.RotateTo}
 * @example
 * // example
 * var rotateTo = cc.RotateTo.create(2, 61.0);
 */
cc.RotateTo.create = function (duration, deltaAngle) {
    var rotateTo = new cc.RotateTo();
    rotateTo.initWithDuration(duration, deltaAngle);

    return rotateTo;
};


/** Rotates a cc.Node object clockwise a number of degrees by modifying it's rotation attribute.
 * @class
 * @extends  cc.ActionInterval
 */
cc.RotateBy = cc.ActionInterval.extend(/** @lends cc.RotateBy# */{
    _angle:0,
    _startAngle:0,

    /**
     * @param {Number} duration duration in seconds
     * @param {Number} deltaAngle deltaAngle in degrees
     * @return {Boolean}
     */
    initWithDuration:function (duration, deltaAngle) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
            this._angle = deltaAngle;
            return true;
        }

        return false;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._startAngle = target.getRotation();
    },

    /**
     * @param {Number} time
     */
    update:function (time) {
        if (this._target) {
            this._target.setRotation(this._startAngle + this._angle * time);
        }
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.RotateBy.create(this._duration, -this._angle);
    }
});

/**
 * @param {Number} duration druation in seconds
 * @param {Number} deltaAngle deltaAngle in degrees
 * @return {cc.RotateBy}
 * @example
 * // example
 * var actionBy = cc.RotateBy.create(2, 360);
 */
cc.RotateBy.create = function (duration, deltaAngle) {
    var rotateBy = new cc.RotateBy();
    rotateBy.initWithDuration(duration, deltaAngle);

    return rotateBy;
};


/** Moves a cc.Node object to the position x,y. x and y are absolute coordinates by modifying it's position attribute.
 * @class
 * @extends cc.ActionInterval
 */
cc.MoveTo = cc.ActionInterval.extend(/** @lends cc.MoveTo# */{
    /**
     * @param {Number} duration duration in seconds
     * @param {cc.Poin} position
     * @return {Boolean}
     */
    initWithDuration:function (duration, position) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
            this._endPosition = position;
            return true;
        }

        return false;
    },

    /**
     * @param {Number} target
     */
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._startPosition = target.getPosition();
        this._delta = cc.pSub(this._endPosition, this._startPosition);
    },

    /**
     * @param {Number} time time in seconds
     */
    update:function (time) {
        if (this._target) {
            this._target.setPosition(cc.p(this._startPosition.x + this._delta.x * time,
                this._startPosition.y + this._delta.y * time));
        }
    },

    /**
     * MoveTo reverse is not implemented
     */
    reverse:function () {
        cc.Assert(0, "moveto reverse is not implemented");
    },
    _endPosition:cc.p(0, 0),
    _startPosition:cc.p(0, 0),
    _delta:cc.p(0, 0)
});

/**
 * @param {Number} duration duration in seconds
 * @param {cc.Point} position
 * @return {cc.MoveTo}
 * @example
 * // example
 * var actionTo = cc.MoveTo.create(2, cc.p(windowSize.width - 40, windowSize.height - 40));
 */
cc.MoveTo.create = function (duration, position) {
    var moveTo = new cc.MoveTo();
    moveTo.initWithDuration(duration, position);

    return moveTo;
};


/** Moves a cc.Node object x,y pixels by modifying it's position attribute. <br/>
 * x and y are relative to the position of the object. <br/>
 * @class
 * @extends cc.MoveTo
 */
cc.MoveBy = cc.MoveTo.extend(/** @lends cc.MoveBy# */{

    /**
     * @param {Number} duration  duration in seconds
     * @param {cc.Point} position
     * @return {Boolean}
     */
    initWithDuration:function (duration, position) {
        if (cc.MoveTo.prototype.initWithDuration.call(this, duration, position)) {
            this._delta = position;
            return true;
        }

        return false;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        var temp = this._delta;
        cc.MoveTo.prototype.startWithTarget.call(this, target);
        this._delta = temp;
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.MoveBy.create(this._duration, cc.p(-this._delta.x, -this._delta.y));
    }
});
/**
 * @param {Number} duration duration in seconds
 * @param {cc.Point} position
 * @return {cc.MoveBy}
 * @example
 * // example
 * var actionBy = cc.MoveBy.create(2, cc.p(80, 80));
 */
cc.MoveBy.create = function (duration, position) {
    var moveBy = new cc.MoveBy();
    moveBy.initWithDuration(duration, position);

    return moveBy;
};


/** Skews a cc.Node object to given angles by modifying it's skewX and skewY attributes
 * @class
 * @extends cc.ActionInterval
 */
cc.SkewTo = cc.ActionInterval.extend(/** @lends cc.SkewTo# */{
    /**
     * @param {Number} t time in seconds
     * @param {Number} sx
     * @param {Number} sy
     * @return {Boolean}
     */
    initWithDuration:function (t, sx, sy) {
        var ret = false;

        if (cc.ActionInterval.prototype.initWithDuration.call(this, t)) {
            this._endSkewX = sx;
            this._endSkewY = sy;

            ret = true;
        }

        return ret;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);

        this._startSkewX = target.getSkewX();


        if (this._startSkewX > 0) {
            this._startSkewX = this._startSkewX % 180;
        }
        else {
            this._startSkewX = this._startSkewX % -180;
        }

        this._deltaX = this._endSkewX - this._startSkewX;

        if (this._deltaX > 180) {
            this._deltaX -= 360;
        }
        if (this._deltaX < -180) {
            this._deltaX += 360;
        }


        this._startSkewY = target.getSkewY();
        if (this._startSkewY > 0) {
            this._startSkewY = this._startSkewY % 360;
        }
        else {
            this._startSkewY = this._startSkewY % -360;
        }

        this._deltaY = this._endSkewY - this._startSkewY;

        if (this._deltaY > 180) {
            this._deltaY -= 360;
        }
        if (this._deltaY < -180) {
            this._deltaY += 360;
        }
    },

    /**
     * @param {Number} t time in seconds
     */
    update:function (t) {
        this._target.setSkewX(this._startSkewX + this._deltaX * t);

        this._target.setSkewY(this._startSkewY + this._deltaY * t);
    },
    _skewX:0,
    _skewY:0,
    _startSkewX:0,
    _startSkewY:0,
    _endSkewX:0,
    _endSkewY:0,
    _deltaX:0,
    _deltaY:0
});
/**
 * @param {Number} t time in seconds
 * @param {Number} sx
 * @param {Number} sy
 * @return {cc.SkewTo}
 * @example
 * // example
 * var actionTo = cc.SkewTo.create(2, 37.2, -37.2);
 */

cc.SkewTo.create = function (t, sx, sy) {
    var skewTo = new cc.SkewTo();
    if (skewTo) {
        skewTo.initWithDuration(t, sx, sy)
    }
    return skewTo;
};


/** Skews a cc.Node object by skewX and skewY degrees
 * @class
 * @extends cc.SkewTo
 */
cc.SkewBy = cc.SkewTo.extend(/** @lends cc.SkewBy# */{
    /**
     * @param {Number} t time in seconds
     * @param {Number} deltaSkewX  skew in degrees for X axis
     * @param {Number} deltaSkewY  skew in degrees for Y axis
     * @return {Boolean}
     */
    initWithDuration:function (t, deltaSkewX, deltaSkewY) {
        var ret = false;

        if (cc.SkewTo.prototype.initWithDuration.call(this, t, deltaSkewX, deltaSkewY)) {
            this._skewX = deltaSkewX;
            this._skewY = deltaSkewY;

            ret = true;
        }

        return ret;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        cc.SkewTo.prototype.startWithTarget.call(this, target);
        this._deltaX = this._skewX;
        this._deltaY = this._skewY;
        this._endSkewX = this._startSkewX + this._deltaX;
        this._endSkewY = this._startSkewY + this._deltaY;
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.SkewBy.create(this._duration, -this._skewX, -this._skewY);
    }
});
/**
 * @param {Number} t time in seconds
 * @param {Number} sx sx skew in degrees for X axis
 * @param {Number} sy sy skew in degrees for Y axis
 * @return {cc.SkewBy}
 * @example
 * // example
 * var actionBy = cc.SkewBy.create(2, 0, -90);
 */
cc.SkewBy.create = function (t, sx, sy) {
    var skewBy = new cc.SkewBy();
    if (skewBy) {
        skewBy.initWithDuration(t, sx, sy);
    }

    return skewBy;
};


/**  Moves a cc.Node object simulating a parabolic jump movement by modifying it's position attribute.
 * @class
 * @extends cc.ActionInterval
 */
cc.JumpBy = cc.ActionInterval.extend(/** @lends cc.JumpBy# */{
    /**
     * @param {Number} duration
     * @param {cc.Point} position
     * @param {Number} height
     * @param {Number} jumps
     * @return {Boolean}
     */
    initWithDuration:function (duration, position, height, jumps) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
            this._delta = position;
            this._height = height;
            this._jumps = jumps;

            return true;
        }

        return false;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._startPosition = target.getPosition();
    },

    /**
     * @param {Number} time
     */
    update:function (time) {
        if (this._target) {
            var frac = time * this._jumps % 1.0;
            var y = this._height * 4 * frac * (1 - frac);
            y += this._delta.y * time;
            var x = this._delta.x * time;
            this._target.setPosition(cc.p(this._startPosition.x + x, this._startPosition.y + y));
        }
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.JumpBy.create(this._duration, cc.p(-this._delta.x, -this._delta.y), this._height, this._jumps);
    },
    _startPosition:cc.p(0, 0),
    _delta:cc.p(0, 0),
    _height:0,
    _jumps:0
});

/**
 * @param {Number} duration
 * @param {cc.Point} position
 * @param {Number} height
 * @param {Number} jumps
 * @return {cc.JumpBy}
 * @example
 * // example
 * var actionBy = cc.JumpBy.create(2, cc.p(300, 0), 50, 4);
 */
cc.JumpBy.create = function (duration, position, height, jumps) {
    var jumpBy = new cc.JumpBy();
    jumpBy.initWithDuration(duration, position, height, jumps);

    return jumpBy;
};


/**  Moves a cc.Node object to a parabolic position simulating a jump movement by modifying it's position attribute.
 * @class
 * @extends cc.JumpBy
 */
cc.JumpTo = cc.JumpBy.extend(/** @lends cc.JumpTo# */{
    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        cc.JumpBy.prototype.startWithTarget.call(this, target);
        this._delta = cc.p(this._delta.x - this._startPosition.x, this._delta.y - this._startPosition.y);
    }
});

/**
 * @param {Number} duration
 * @param {cc.Point} position
 * @param {Number} height
 * @param {Number} jumps
 * @return {cc.JumpTo}
 * @example
 * // example
 * var actionTo = cc.JumpTo.create(2, cc.p(300, 300), 50, 4);
 */
cc.JumpTo.create = function (duration, position, height, jumps) {
    var jumpTo = new cc.JumpTo();
    jumpTo.initWithDuration(duration, position, height, jumps);

    return jumpTo;
};

/**
 * Bezier configuration structure
 * @class
 * @extends cc.Class
 */
cc.BezierConfig = cc.Class.extend(/** @lends cc.BezierConfig# */{
    /**
     * Constructor
     */
    ctor:function () {
        this.endPosition = cc.p(0, 0);
        this.controlPoint_1 = cc.p(0, 0);
        this.controlPoint_2 = cc.p(0, 0);
    }
});

/**
 * @function
 * @param {Number} a
 * @param {Number} b
 * @param {Number} c
 * @param {Number} d
 * @param {Number} t
 * @return {Number}
 */
cc.bezierat = function (a, b, c, d, t) {
    return (Math.pow(1 - t, 3) * a +
        3 * t * (Math.pow(1 - t, 2)) * b +
        3 * Math.pow(t, 2) * (1 - t) * c +
        Math.pow(t, 3) * d );
};

/** An action that moves the target with a cubic Bezier curve by a certain distance.
 * @class
 * @extends cc.ActionInterval
 */
cc.BezierBy = cc.ActionInterval.extend(/** @lends cc.BezierBy# */{
    /**
     * @param {Number} t time in seconds
     * @param {cc.BezierConfig} c
     * @return {Boolean}
     */
    initWithDuration:function (t, c) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, t)) {
            this._config = c;
            return true;
        }

        return false;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._startPosition = target.getPosition();
    },

    /**
     * @param {Number} time
     */
    update:function (time) {
        if (this._target) {
            var xa = 0;
            var xb = this._config.controlPoint_1.x;
            var xc = this._config.controlPoint_2.x;
            var xd = this._config.endPosition.x;

            var ya = 0;
            var yb = this._config.controlPoint_1.y;
            var yc = this._config.controlPoint_2.y;
            var yd = this._config.endPosition.y;

            var x = cc.bezierat(xa, xb, xc, xd, time);
            var y = cc.bezierat(ya, yb, yc, yd, time);
            this._target.setPosition(cc.pAdd(this._startPosition, cc.p(x, y)));
        }
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        var r = new cc.BezierConfig();

        r.endPosition = cc.pNeg(this._config.endPosition);
        r.controlPoint_1 = cc.pAdd(this._config.controlPoint_2, cc.pNeg(this._config.endPosition));
        r.controlPoint_2 = cc.pAdd(this._config.controlPoint_1, cc.pNeg(this._config.endPosition));

        return cc.BezierBy.create(this._duration, r);
    },

    /**
     * Constructor
     */
    ctor:function () {
        this._config = new cc.BezierConfig();
        this._startPosition = cc.p(0, 0);
    }
});

/**
 * @param {Number} t time in seconds
 * @param {cc.BezierConfig} c
 * @return {cc.BezierBy}
 * @example
 * // example
 * var bezier = new cc.BezierConfig();
 * bezier.controlPoint_1 = cc.p(0, windowSize.height / 2);
 * bezier.controlPoint_2 = cc.p(300, -windowSize.height / 2);
 * bezier.endPosition = cc.p(300, 100);
 *
 * var bezierForward = cc.BezierBy.create(3, bezier);
 *
 */
cc.BezierBy.create = function (t, c) {
    var bezierBy = new cc.BezierBy();
    bezierBy.initWithDuration(t, c);

    return bezierBy;
};


/** An action that moves the target with a cubic Bezier curve to a destination point.
 * @class
 * @extends cc.BezierBy
 */
cc.BezierTo = cc.BezierBy.extend(/** @lends cc.BezierTo# */{
    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        cc.BezierBy.prototype.startWithTarget.call(this, target);
        this._config.controlPoint_1 = cc.pSub(this._config.controlPoint_1, this._startPosition);
        this._config.controlPoint_2 = cc.pSub(this._config.controlPoint_2, this._startPosition);
        this._config.endPosition = cc.pSub(this._config.endPosition, this._startPosition);
    }
});
/**
 * @param {Number} t
 * @param {cc.BezierConfig} c
 * @return {cc.BezierTo}
 * @example
 * // example
 *  var bezier = new cc.BezierConfig();
 * bezier.controlPoint_1 = cc.p(100, windowSize.height / 2);
 * bezier.controlPoint_2 = cc.p(200, -windowSize.height / 2);
 * bezier.endPosition = cc.p(240, 160);
 *
 * var bezierTo = cc.BezierTo.create(2, bezier);
 */
cc.BezierTo.create = function (t, c) {
    var bezierTo = new cc.BezierTo();
    bezierTo.initWithDuration(t, c);

    return bezierTo;
};


/** Scales a cc.Node object to a zoom factor by modifying it's scale attribute.
 * @warning This action doesn't support "reverse"
 * @class
 * @extends cc.ActionInterval
 */
cc.ScaleTo = cc.ActionInterval.extend(/** @lends cc.ScaleTo# */{
    /**
     * @param {Number} duration
     * @param {Number} sx
     * @param {Number} sy
     * @return {Boolean}
     */
    initWithDuration:function (duration, sx, sy)//function overload here
    {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
            this._endScaleX = sx;
            this._endScaleY = (sy != null) ? sy : sx;

            return true;
        }

        return false;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        //this._super(target);
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._startScaleX = target.getScaleX();
        this._startScaleY = target.getScaleY();
        this._deltaX = this._endScaleX - this._startScaleX;
        this._deltaY = this._endScaleY - this._startScaleY;
    },

    /**
     * @param {Number} time
     */
    update:function (time) {
        if (this._target) {
            this._target.setScale(this._startScaleX + this._deltaX * time, this._startScaleY + this._deltaY * time);
            //this._target.setScaleX(this._startScaleX + this._deltaX * time);
            //this._target.setScaleY(this._startScaleY + this._deltaY * time);
        }
    },
    _scaleX:1,
    _scaleY:1,
    _startScaleX:1,
    _startScaleY:1,
    _endScaleX:0,
    _endScaleY:0,
    _deltaX:0,
    _deltaY:0
});
/**
 * @param {Number} duration
 * @param {Number} sx  scale parameter in X
 * @param {Number|Null} sy scale parameter in Y, if Null equal to sx
 * @return {cc.ScaleTo}
 * @example
 * // example
 * // It scales to 0.5 in both X and Y.
 * var actionTo = cc.ScaleTo.create(2, 0.5);
 *
 * // It scales to 0.5 in x and 2 in Y
 * var actionTo = cc.ScaleTo.create(2, 0.5, 2);
 */
cc.ScaleTo.create = function (duration, sx, sy)//function overload
{
    var scaleTo = new cc.ScaleTo();
    if (sy) {
        scaleTo.initWithDuration(duration, sx, sy);
    } else {
        scaleTo.initWithDuration(duration, sx);
    }

    return scaleTo;
};


/** Scales a cc.Node object a zoom factor by modifying it's scale attribute.
 * @class
 * @extends cc.ScaleTo
 */
cc.ScaleBy = cc.ScaleTo.extend(/** @lends cc.ScaleBy# */{
    /**
     * @param {Number} target
     */
    startWithTarget:function (target) {
        //this._super(target);
        cc.ScaleTo.prototype.startWithTarget.call(this, target);
        this._deltaX = this._startScaleX * this._endScaleX - this._startScaleX;
        this._deltaY = this._startScaleY * this._endScaleY - this._startScaleY;
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.ScaleBy.create(this._duration, 1 / this._endScaleX, 1 / this._endScaleY);
    }
});
/**
 * @param {Number} duration duration in seconds
 * @param {Number} sx sx  scale parameter in X
 * @param {Number|Null} sy sy scale parameter in Y, if Null equal to sx
 * @return {cc.ScaleBy}
 * @example
 * // example without sy, it scales by 2 both in X and Y
 * var actionBy = cc.ScaleBy.create(2, 2);
 *
 * //example with sy, it scales by 0.25 in X and 4.5 in Y
 * var actionBy2 = cc.ScaleBy.create(2, 0.25, 4.5);
 */
cc.ScaleBy.create = function (duration, sx, sy) {
    var scaleBy = new cc.ScaleBy();
    if (arguments.length == 3) {
        scaleBy.initWithDuration(duration, sx, sy);
    }
    else {
        scaleBy.initWithDuration(duration, sx);
    }

    return scaleBy;
};

/** Blinks a cc.Node object by modifying it's visible attribute
 * @class
 * @extends cc.ActionInterval
 */
cc.Blink = cc.ActionInterval.extend(/** @lends cc.Blink# */{
    /**
     * @param {Number} duration duration in seconds
     * @param {Number} blinks blinks in times
     * @return {Boolean}
     */
    initWithDuration:function (duration, blinks) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
            this._times = blinks;
            return true;
        }

        return false;
    },

    /**
     * @param {Number} time time in seconds
     */
    update:function (time) {
        if (this._target && !this.isDone()) {
            var slice = 1.0 / this._times;
            var m = time % slice;
            this._target.setVisible(m > slice / 2 ? true : false);
        }
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.Blink.create(this._duration, this._times);
    },
    _times:0
});
/**
 * @param {Number} duration  duration in seconds
 * @param blinks blinks in times
 * @return {cc.Blink}
 * @example
 * // example
 * var action = cc.Blink.create(2, 10);
 */
cc.Blink.create = function (duration, blinks) {
    var blink = new cc.Blink();
    blink.initWithDuration(duration, blinks);

    return blink;
};


/** Fades In an object that implements the cc.RGBAProtocol protocol. It modifies the opacity from 0 to 255.<br/>
 * The "reverse" of this action is FadeOut
 * @class
 * @extends cc.ActionInterval
 */
cc.FadeIn = cc.ActionInterval.extend(/** @lends cc.FadeIn# */{
    /**
     * @param {Number} time time in seconds
     */
    update:function (time) {
        this._target.setOpacity(255 * time);
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.FadeOut.create(this._duration);
    }
});

/**
 * @param {Number} duration duration in seconds
 * @return {cc.FadeIn}
 * @example
 * //example
 * var action = cc.FadeIn.create(1.0);
 */
cc.FadeIn.create = function (duration) {
    var action = new cc.FadeIn();

    action.initWithDuration(duration);

    return action;
};


/** Fades Out an object that implements the cc.RGBAProtocol protocol. It modifies the opacity from 255 to 0.
 * The "reverse" of this action is FadeIn
 * @class
 * @extends cc.ActionInterval
 */
cc.FadeOut = cc.ActionInterval.extend(/** @lends cc.FadeOut# */{
    /**
     * @param {Number} time  time in seconds
     */
    update:function (time) {
        this._target.setOpacity(255 * (1 - time));
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.FadeIn.create(this._duration);
    }
});

/**
 * @param {Number} d  duration in seconds
 * @return {cc.FadeOut}
 * @example
 * // example
 * var action = cc.FadeOut.create(1.0);
 */
cc.FadeOut.create = function (d) {
    var action = new cc.FadeOut();

    action.initWithDuration(d);

    return action;
};


/** Fades an object that implements the cc.RGBAProtocol protocol. It modifies the opacity from the current value to a custom one.
 * @warning This action doesn't support "reverse"
 * @class
 * @extends cc.ActionInterval
 */
cc.FadeTo = cc.ActionInterval.extend(/** @lends cc.FadeTo# */{
    /**
     * @param {Number} duration  duration in seconds
     * @param {Number} opacity
     * @return {Boolean}
     */
    initWithDuration:function (duration, opacity) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
            this._toOpacity = opacity;
            return true;
        }

        return false;
    },

    /**
     * @param {Number} time time in seconds
     */
    update:function (time) {
        this._target.setOpacity((this._fromOpacity + (this._toOpacity - this._fromOpacity) * time));
    },

    /**
     * @param {cc.Sprite} target
     */
    startWithTarget:function (target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._fromOpacity = target.getOpacity();
    },
    _toOpacity:'',
    _fromOpacity:''
});

/**
 * @param {Number} duration
 * @param {Number} opacity 0-255, 0 is transparent
 * @return {cc.FadeTo}
 * @example
 * // example
 * var action = cc.FadeTo.create(1.0, 0);
 */
cc.FadeTo.create = function (duration, opacity) {
    var fadeTo = new cc.FadeTo();
    fadeTo.initWithDuration(duration, opacity);

    return fadeTo;
};


/** Tints a cc.Node that implements the cc.NodeRGB protocol from current tint to a custom one.
 * @warning This action doesn't support "reverse"
 * @class
 * @extends cc.ActionInterval
 */
cc.TintTo = cc.ActionInterval.extend(/** @lends cc.TintTo# */{
    /**
     * @param {Number} duration
     * @param {Number} red 0-255
     * @param {Number} green  0-255
     * @param {Number} blue 0-255
     * @return {Boolean}
     */
    initWithDuration:function (duration, red, green, blue) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
            this._to = cc.c3b(red, green, blue);
            return true;
        }

        return false;
    },

    /**
     * @param {cc.Sprite} target
     */
    startWithTarget:function (target) {
        //this._super(target);
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._from = this._target.getColor();
    },

    /**
     * @param {Number} time time in seconds
     */
    update:function (time) {
        this._target.setColor(cc.c3b(this._from.r + (this._to.r - this._from.r) * time,
            (this._from.g + (this._to.g - this._from.g) * time),
            (this._from.b + (this._to.b - this._from.b) * time)));
    },
    _to:new cc.Color3B(),
    _from:new cc.Color3B()
});

/**
 * @param {Number} duration
 * @param {Number} red 0-255
 * @param {Number} green  0-255
 * @param {Number} blue 0-255
 * @return {cc.TintTo}
 * @example
 * // example
 * var action = cc.TintTo.create(2, 255, 0, 255);
 */
cc.TintTo.create = function (duration, red, green, blue) {
    var tintTo = new cc.TintTo();
    tintTo.initWithDuration(duration, red, green, blue);

    return tintTo;
};


/**  Tints a cc.Node that implements the cc.NodeRGB protocol from current tint to a custom one.
 * @class
 * @extends cc.ActionInterval
 */
cc.TintBy = cc.ActionInterval.extend(/** @lends cc.TintBy# */{
    /**
     * @param {Number} duration
     * @param {Number} deltaRed 0-255
     * @param {Number} deltaGreen 0-255
     * @param {Number} deltaBlue 0-255
     * @return {Boolean}
     */
    initWithDuration:function (duration, deltaRed, deltaGreen, deltaBlue) {
        //if (this._super(duration)) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
            this._deltaR = deltaRed;
            this._deltaG = deltaGreen;
            this._deltaB = deltaBlue;

            return true;
        }

        return false;
    },

    /**
     * @param {cc.Sprite} target
     */
    startWithTarget:function (target) {
        //this._super(target);
        cc.ActionInterval.prototype.startWithTarget.call(this, target);

        if (target.RGBAProtocol) {
            var color = target.getColor();
            this._fromR = color.r;
            this._fromG = color.g;
            this._fromB = color.b;
        }
    },

    /**
     * @param {Number} time time in seconds
     */
    update:function (time) {
        if (this._target.RGBAProtocol) {
            this._target.setColor(cc.c3b((this._fromR + this._deltaR * time),
                (this._fromG + this._deltaG * time),
                (this._fromB + this._deltaB * time)));
        }
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.TintBy.create(this._duration, -this._deltaR, -this._deltaG, -this._deltaB);
    },
    _deltaR:0,
    _deltaG:0,
    _deltaB:0,

    _fromR:0,
    _fromG:0,
    _fromB:0
});

/**
 * @param {Number} duration  duration in seconds
 * @param {Number} deltaRed
 * @param {Number} deltaGreen
 * @param {Number} deltaBlue
 * @return {cc.TintBy}
 * @example
 * // example
 * var action = cc.TintBy.create(2, -127, -255, -127);
 */
cc.TintBy.create = function (duration, deltaRed, deltaGreen, deltaBlue) {
    var tintBy = new cc.TintBy();
    tintBy.initWithDuration(duration, deltaRed, deltaGreen, deltaBlue);

    return tintBy;
};


/** Delays the action a certain amount of seconds
 * @class
 * @extends cc.ActionInterval
 */
cc.DelayTime = cc.ActionInterval.extend(/** @lends cc.DelayTime# */{

    /**
     * @param {Number} time time in seconds
     */
    update:function (time) {

    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.DelayTime.create(this._duration);
    }
});

/**
 * @param {Number} d duration in seconds
 * @return {cc.DelayTime}
 * @example
 * // example
 * var delay = cc.DelayTime.create(1);
 */
cc.DelayTime.create = function (d) {
    var action = new cc.DelayTime();

    action.initWithDuration(d);

    return action;
};


/** Executes an action in reverse order, from time=duration to time=0

 * @warning Use this action carefully. This action is not
 * sequenceable. Use it as the default "reversed" method
 * of your own actions, but using it outside the "reversed"
 * scope is not recommended.
 * @class
 * @extends cc.ActionInterval
 */
cc.ReverseTime = cc.ActionInterval.extend(/** @lends cc.ReverseTime# */{
    /**
     * @param {cc.FiniteTimeAction} action
     * @return {Boolean}
     */
    initWithAction:function (action) {
        cc.Assert(action != null, "");
        cc.Assert(action != this._other, "");

        //if (this._super(action.getDuration())) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, action.getDuration())) {
            // Don't leak if action is reused
            this._other = action;
            return true;
        }

        return false;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        //this._super(target);
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._other.startWithTarget(target);
    },

    /**
     * @param {Number} time time in seconds
     */
    update:function (time) {
        if (this._other) {
            this._other.update(1 - time);
        }
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return this._other.copy();
    },

    /**
     * Stop the action
     */
    stop:function () {
        this._other.stop();
        //this._super();
        cc.Action.prototype.stop.call(this);
    },
    _other:null
});

/**
 * @param {cc.FiniteTimeAction} action
 * @return {cc.ReverseTime}
 * @example
 * // example
 *  var reverse = cc.ReverseTime.create(this);
 */
cc.ReverseTime.create = function (action) {
    var reverseTime = new cc.ReverseTime();
    reverseTime.initWithAction(action);

    return reverseTime;
};


/**  Animates a sprite given the name of an Animation
 * @class
 * @extends cc.ActionInterval
 */
cc.Animate = cc.ActionInterval.extend(/** @lends cc.Animate# */{
    _animation:null,
    _nextFrame:0,
    _origFrame:null,
    _executedLoops:0,
    _splitTimes:null,

    /**
     * @return {cc.Animation}
     */
    getAnimation:function () {
        return this._animation;
    },

    /**
     * @param {cc.Animation} animation
     */
    setAnimation:function (animation) {
        this._animation = animation;
    },

    /**
     * @param {cc.Animation} animation
     * @return {Boolean}
     */
    initWithAnimation:function (animation) {
        cc.Assert(animation != null, "Animate: argument Animation must be non-NULL");

        var singleDuration = animation.getDuration();
        if (this.initWithDuration(singleDuration * animation.getLoops())) {
            this._nextFrame = 0;
            this.setAnimation(animation);

            this._origFrame = null;
            this._executedLoops = 0;

            this._splitTimes = [];

            var accumUnitsOfTime = 0;
            var newUnitOfTimeValue = singleDuration / animation.getTotalDelayUnits();

            var frames = animation.getFrames();
            cc.ArrayVerifyType(frames, cc.AnimationFrame);

            for (var i = 0; i < frames.length; i++) {
                var frame = frames[i];
                var value = (accumUnitsOfTime * newUnitOfTimeValue) / singleDuration;
                accumUnitsOfTime += frame.getDelayUnits();
                this._splitTimes.push(value);
            }
            return true;
        }
        return false;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        //this._super(target);
        cc.ActionInterval.prototype.startWithTarget.call(this, target);

        if (this._animation.getRestoreOriginalFrame()) {
            this._origFrame = target.displayFrame();
        }
        this._nextFrame = 0;
        this._executedLoops = 0;
    },

    /**
     * @param {Number} time
     */
    update:function (time) {
        // if t==1, ignore. Animation should finish with t==1
        if (time < 1.0) {
            time *= this._animation.getLoops();

            // new loop?  If so, reset frame counter
            var loopNumber = 0 | time;
            if (loopNumber > this._executedLoops) {
                this._nextFrame = 0;
                this._executedLoops++;
            }

            // new t for animations
            time = time % 1.0;
        }

        var frames = this._animation.getFrames();
        var numberOfFrames = frames.length;
        var frameToDisplay = null;

        for (var i = this._nextFrame; i < numberOfFrames; i++) {
            var splitTime = this._splitTimes[i];

            if (splitTime <= time) {
                var frame = frames[i];
                frameToDisplay = frame.getSpriteFrame();
                this._target.setDisplayFrame(frameToDisplay);

                var dict = frame.getUserInfo();
                if (dict) {
                    //TODO: [[NSNotificationCenter defaultCenter] postNotificationName:CCAnimationFrameDisplayedNotification object:target_ userInfo:dict];
                }
                this._nextFrame = i + 1;
                break;
            }
        }
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        var oldArray = this._animation.getFrames();
        var newArray = [];
        cc.ArrayVerifyType(oldArray, cc.AnimationFrame);
        if (oldArray.length > 0) {
            for (var i = oldArray.length - 1; i >= 0; i--) {
                var element = oldArray[i];
                if (!element) {
                    break;
                }
                newArray.push(element.copy());
            }
        }

        var newAnim = cc.Animation.createWithAnimationFrames(newArray, this._animation.getDelayPerUnit(), this._animation.getLoops());
        newAnim.setRestoreOriginalFrame(this._animation.getRestoreOriginalFrame());
        return cc.Animate.create(newAnim);

    },

    /**
     * stop the action
     */
    stop:function () {
        if (this._animation.getRestoreOriginalFrame() && this._target) {
            this._target.setDisplayFrame(this._origFrame);
        }
        //this._super();
        cc.Action.prototype.stop.call(this);
    }
});

/**
 * create the animate with animation
 * @param {cc.Animation} animation
 * @return {cc.Animate}
 * @example
 * // example
 * // create the animation with animation
 * var anim = cc.Animate.create(dance_grey);
 */
cc.Animate.create = function (animation) {
    var animate = new cc.Animate();
    animate.initWithAnimation(animation);
    return animate;
};

/**
 * <p>
 *     Overrides the target of an action so that it always runs on the target<br/>
 *     specified at action creation rather than the one specified by runAction.
 * </p>
 * @class
 * @extends cc.ActionInterval
 */
cc.TargetedAction = cc.ActionInterval.extend(/** @lends cc.TargetedAction# */{
    _action:null,
    _forcedTarget:null,

    /**
     * Init an action with the specified action and forced target
     * @param {cc.Node} target
     * @param {cc.FiniteTimeAction} action
     * @return {Boolean}
     */
    initWithTarget:function (target, action) {
        if (this.initWithDuration(action.getDuration())) {
            this._forcedTarget = target;
            this._action = action;
            return true;
        }
        return false;
    },

    startWithTarget:function (target) {
        //this._super(this._forcedTarget);
        cc.ActionInterval.prototype.startWithTarget.call(this, this._forcedTarget);
        this._action.startWithTarget(this._forcedTarget);
    },

    stop:function () {
        this._action.stop();
    },

    update:function (time) {
        this._action.update(time);
    },

    /**
     * return the target that the action will be forced to run with
     * @return {cc.Node}
     */
    getForcedTarget:function () {
        return this._forcedTarget;
    },

    /**
     * set the target that the action will be forced to run with
     * @param {cc.Node} forcedTarget
     */
    setForcedTarget:function (forcedTarget) {
        if (this._forcedTarget != forcedTarget) {
            this._forcedTarget = forcedTarget;
        }
    }
});

/**
 * Create an action with the specified action and forced target
 * @param {cc.Node} target
 * @param {cc.FiniteTimeAction} action
 */
cc.TargetedAction.create = function (target, action) {
    var retObj = new cc.TargetedAction();
    retObj.initWithTarget(target, action);
    return retObj;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * Instant actions are immediate actions. They don't have a duration like
 * the CCIntervalAction actions.
 * @class
 * @extends cc.FiniteTimeAction
 */
cc.ActionInstant = cc.FiniteTimeAction.extend(/** @lends cc.ActionInstant# */{
    /**
     * @return {Boolean}
     */
    isDone:function () {
        return true;
    },

    /**
     * @param {Number} dt
     */
    step:function (dt) {
        this.update(1);
    },

    /**
     * @param {Number} time
     */
    update:function (time) {
        //nothing
    }
});

/**  Show the node
 * @class
 * @extends cc.ActionInstant
 */
cc.Show = cc.ActionInstant.extend(/** @lends cc.Show# */{
    /**
     * @param {cc.Node} target
     */
    update:function (target) {
        //this._super(target);
        this._target.setVisible(true);
    },

    /**
     * @return {cc.FiniteTimeAction}
     */
    reverse:function () {
        return cc.Hide.create.call(this);
    }
});
/**
 * @return {cc.Show}
 * @example
 * // example
 * var showAction = cc.Show.create();
 */
cc.Show.create = function () {
    return new cc.Show();
};

/**
 * Hide the node
 * @class
 * @extends cc.ActionInstant
 */
cc.Hide = cc.ActionInstant.extend(/** @lends cc.Hide# */{
    /**
     * @param {Number} time
     */
    update:function (time) {
        //this._super(target);
        this._target.setVisible(false);
    },

    /**
     * @return {cc.FiniteTimeAction}
     */
    reverse:function () {
        return cc.Show.create.call(this);
    }
});
/**
 * @return {cc.Hide}
 * @example
 * // example
 * var hideAction = cc.Hide.create();
 */
cc.Hide.create = function () {
    return (new cc.Hide());
};


/** Toggles the visibility of a node
 * @class
 * @extends cc.ActionInstant
 */
cc.ToggleVisibility = cc.ActionInstant.extend(/** @lends cc.ToggleVisibility# */{
    /**
     * @param {Number} time
     */
    update:function (time) {
        //this._super();
        this._target.setVisible(!this._target.isVisible());
    },

    /**
     * @return {cc.ToggleVisibility}
     */
    reverse:function () {
        return new cc.ToggleVisibility();
    }
});

/**
 * @return {cc.ToggleVisibility}
 * @example
 * // example
 * var toggleVisibilityAction = cc.ToggleVisibility.create();
 */
cc.ToggleVisibility.create = function () {
    return (new cc.ToggleVisibility());
};

/**
 * Flips the sprite horizontally
 * @class
 * @extends cc.ActionInstant
 */
cc.FlipX = cc.ActionInstant.extend(/** @lends cc.FlipX# */{
    /**
     * @param {Boolean} x
     * @return {Boolean}
     */
    initWithFlipX:function (x) {
        this._flipX = x;
        return true;
    },

    /**
     * @param {Number} time
     */
    update:function (time) {
        //this._super();
        this._target.setFlipX(this._flipX);
    },

    /**
     * @return {cc.FiniteTimeAction}
     */
    reverse:function () {
        return cc.FlipX.create(!this._flipX);
    },
    _flipX:false
});

/**
 * @param {Boolean} x
 * @return {cc.FlipX}
 * var flipXAction = cc.FlipX.create(true);
 */
cc.FlipX.create = function (x) {
    var ret = new cc.FlipX();
    if (ret.initWithFlipX(x))
        return ret;
    return null;
};

/**
 * Flips the sprite vertically
 * @class
 * @extends cc.ActionInstant
 */
cc.FlipY = cc.ActionInstant.extend(/** @lends cc.FlipY# */{
    /**
     * @param {Boolean} Y
     * @return {Boolean}
     */
    initWithFlipY:function (Y) {
        this._flipY = Y;
        return true;
    },

    /**
     * @param {Number} time
     */
    update:function (time) {
        //this._super();
        this._target.setFlipY(this._flipY);
    },

    /**
     * @return {cc.FiniteTimeAction}
     */
    reverse:function () {
        return cc.FlipY.create(!this._flipY);
    },
    _flipY:false
});
/**
 * @param {Boolean} y
 * @return {cc.FlipY}
 * @example
 * // example
 * var flipYAction = cc.FlipY.create();
 */
cc.FlipY.create = function (y) {
    var ret = new cc.FlipY();
    if (ret.initWithFlipY(y))
        return ret;
    return null;
};


/** Places the node in a certain position
 * @class
 * @extends cc.ActionInstant
 */
cc.Place = cc.ActionInstant.extend(/** @lends cc.Place# */{
    /** Initializes a Place action with a position
     * @param {cc.Point} pos
     * @return {Boolean}
     */
    initWithPosition:function (pos) {
        this._position = pos;
        return true;
    },

    /**
     * @param {Number} time
     */
    update:function (time) {
        //this._super(target);
        this._target.setPosition(this._position);
    }
});
/** creates a Place action with a position
 * @param {cc.Point} pos
 * @return {cc.Place}
 * @example
 * // example
 * var placeAction = cc.Place.create(cc.p(200, 200));
 */
cc.Place.create = function (pos) {
    var ret = new cc.Place();
    ret.initWithPosition(pos);
    return ret;
};


/** Calls a 'callback'
 * @class
 * @extends cc.ActionInstant
 */
cc.CallFunc = cc.ActionInstant.extend(/** @lends cc.CallFunc# */{
    /**
     * @param {object} selectorTarget
     * @param {function|Null} selector
     * @param {*|Null} data data for function, it accepts all data types.
     * @return {Boolean}
     */
    initWithTarget:function (selectorTarget, selector, data) {
        this._data = data || null;
        this._callFunc = selector || null;
        this._selectorTarget = selectorTarget || null;
        return true;
    },

    /**
     * execute the function.
     */
    execute:function () {
        if (this._callFunc != null)//CallFunc, N, ND
        {
            this._callFunc.call(this._selectorTarget, this._target, this._data);
        }
    },

    /**
     * @param {Number} time
     */
    update:function (time) {
        //this._super(target);
        this.execute();
    },

    /**
     * @return {object}
     */
    getTargetCallback:function () {
        return this._selectorTarget;
    },

    /**
     * @param {object} sel
     */
    setTargetCallback:function (sel) {
        if (sel != this._selectorTarget) {
            if (this._selectorTarget) {
                this._selectorTarget = null;
            }
            this._selectorTarget = sel;
        }
    },

    copy:function() {
        var n = new cc.CallFunc();
        n.initWithTarget( this._selectorTarget, this._callFunc, this._data );
        return n;
    },
    _selectorTarget:null,
    _callFunc:null
});
/** creates the action with the callback
 * @param {object} selectorTarget
 * @param {function|Null} selector
 * @param {*|Null} data data for function, it accepts all data types.
 * @return {cc.CallFunc}
 * @example
 * // example
 * // CallFunc without data
 * var finish = cc.CallFunc.create(this, this.removeSprite);
 *
 * // CallFunc with data
 * var finish = cc.CallFunc.create(this._grossini, this.removeFromParentAndCleanup, true),
 */

cc.CallFunc.create = function (selectorTarget, selector, data) {
    var ret = new cc.CallFunc();
    if (ret && ret.initWithTarget(selectorTarget, selector, data)) {
        ret._callFunc = selector;
        return ret;
    }
    return null;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * @class
 * @extends cc.Class
 */
cc.HashElement = cc.Class.extend(/** @lends cc.HashElement# */{
    actions:null,
    target:null, //ccobject
    actionIndex:0,
    currentAction:null, //CCAction
    currentActionSalvaged:false,
    paused:false,
    hh:null, //ut hash handle
    /**
     * Constructor
     */
    ctor:function () {
        this.actions = [];
    }
});

/**
 * cc.ActionManager is a singleton that manages all the actions.<br/>
 * Normally you won't need to use this singleton directly. 99% of the cases you will use the CCNode interface,
 * which uses this singleton.
 * But there are some cases where you might need to use this singleton. <br/>
 * Examples:<br/>
 * - When you want to run an action where the target is different from a CCNode.<br/>
 * - When you want to pause / resume the actions<br/>
 * @class
 * @extends cc.Class
 */
cc.ActionManager = cc.Class.extend({
    _targets:null,
    _currentTarget:null,
    _currentTargetSalvaged:false,

    _searchElementByTarget:function (arr, target) {
        for (var k = 0; k < arr.length; k++) {
            if (target == arr[k].target) {
                return arr[k];
            }
        }
        return null;
    },

    /**
     * Constructor
     */
    ctor:function () {
        this._targets = [];
    },

    /** Adds an action with a target.
     * If the target is already present, then the action will be added to the existing target.
     * If the target is not present, a new instance of this target will be created either paused or not, and the action will be added to the newly created target.
     * When the target is paused, the queued actions won't be 'ticked'.
     * @param {cc.Action} action
     * @param {cc.Node} target
     * @param {Boolean} paused
     */
    addAction:function (action, target, paused) {
        cc.Assert(action != null, "no action");
        cc.Assert(target != null, "");
        //check if the action target already exists
        var element = this._searchElementByTarget(this._targets, target);
        //if doesnt exists, create a hashelement and push in mpTargets
        if (!element) {
            element = new cc.HashElement();
            element.paused = paused;
            element.target = target;
            this._targets.push(element);
        }
        //creates a array for that eleemnt to hold the actions
        this._actionAllocWithHashElement(element);
        cc.Assert((element.actions.indexOf(action) == -1), "ActionManager.addAction(),");

        element.actions.push(action);
        action.startWithTarget(target);
    },

    /**
     * Removes all actions from all the targets.
     */
    removeAllActions:function () {
        for (var i = 0; i < this._targets.length; i++) {
            var element = this._targets[i];
            if (element) {
                this.removeAllActionsFromTarget(element.target);
            }
        }
    },
    /** Removes all actions from a certain target. <br/>
     * All the actions that belongs to the target will be removed.
     * @param {object} target
     */
    removeAllActionsFromTarget:function (target) {
        // explicit null handling
        if (target == null) {
            return;
        }
        var element = this._searchElementByTarget(this._targets, target);

        //var element = (target in this._targets)? this._targets[ptarget]: null;
        if (element) {
            if (element.currentAction in element.actions && !(element.currentActionSalvaged)) {
                element.currentActionSalvaged = true;
            }

            element.actions = [];
            if (this._currentTarget == element) {
                this._currentTargetSalvaged = true;
            }
            else {
                this._deleteHashElement(element);
            }
        } else {
            //cc.log("cocos2d: removeAllActionsFromTarget: Target not found");
        }
    },
    /** Removes an action given an action reference.
     * @param {cc.Action} action
     */
    removeAction:function (action) {
        // explicit null handling
        if (action == null) {
            return;
        }
        var target = action.getOriginalTarget();
        var element = this._searchElementByTarget(this._targets, target);

        if (element) {
            for (var i = 0; i < element.actions.length; i++) {
                if (element.actions[i] == action) {
                    element.actions.splice(i, 1);
                    break;
                }
            }
        } else {
            cc.log("cocos2d: removeAction: Target not found");
        }
    },

    /** Removes an action given its tag and the target
     * @param {Number} tag
     * @param {object} target
     */
    removeActionByTag:function (tag, target) {
        cc.Assert(tag != cc.ACTION_TAG_INVALID, "");
        cc.Assert(target != null, "");

        var element = this._searchElementByTarget(this._targets, target);

        if (element) {
            var limit = element.actions.length;
            for (var i = 0; i < limit; ++i) {
                var action = element.actions[i];
                if (action) {
                    if (action.getTag() == tag && action.getOriginalTarget() == target) {
                        this._removeActionAtIndex(i, element);
                        break;
                    }
                }
            }
        }
    },

    /** Gets an action given its tag an a target
     * @param {Number} tag
     * @param {object} target
     * @return {cc.Action|Null}  return the Action with the given tag on success
     */
    getActionByTag:function (tag, target) {
        cc.Assert(tag != cc.ACTION_TAG_INVALID, "");
        var element = this._searchElementByTarget(this._targets, target);
        if (element) {
            if (element.actions != null) {
                for (var i = 0; i < element.actions.length; ++i) {
                    var action = element.actions[i];
                    if (action) {
                        if (action.getTag() == tag) {
                            return action;
                        }
                    }
                }
            }
        }

        return null;
    },


    /** Returns the numbers of actions that are running in a certain target. <br/>
     * Composable actions are counted as 1 action. <br/>
     * Example: <br/>
     * - If you are running 1 Sequence of 7 actions, it will return 1. <br/>
     * - If you are running 7 Sequences of 2 actions, it will return 7.
     * @param {object} target
     * @return {Number}
     */
    numberOfRunningActionsInTarget:function (target) {
        var element = this._searchElementByTarget(this._targets, target);
        if (element) {
            return (element.actions) ? element.actions.length : 0;
        }

        return 0;
    },
    /** Pauses the target: all running actions and newly added actions will be paused.
     * @param {object} target
     */
    pauseTarget:function (target) {
        var element = this._searchElementByTarget(this._targets, target);
        if (element) {
            element.paused = true;
        }
    },
    /** Resumes the target. All queued actions will be resumed.
     * @param {object} target
     */
    resumeTarget:function (target) {
        var element = this._searchElementByTarget(this._targets, target);
        if (element) {
            element.paused = false;
        }
    },

    /**
     * Pauses all running actions, returning a list of targets whose actions were paused.
     */
    pauseAllRunningActions:function(){
        var idsWithActions = [];
        for(var i = 0; i< this._targets.length; i++){
            var element = this._targets[i];
            if(element && !element.paused){
                element.paused = true;
                idsWithActions.push(element.target);
            }
        }
        return idsWithActions;
    },

    /**
     * Resume a set of targets (convenience function to reverse a pauseAllRunningActions call)
     * @param {Array} targetsToResume
     */
    resumeTargets:function(targetsToResume){
        if(!targetsToResume){
            return;
        }
        for(var i = 0 ; i< targetsToResume.length; i++){
            if(targetsToResume[i])
                this.resumeTarget(targetsToResume[i]);
        }
    },

    /** purges the shared action manager. It releases the retained instance. <br/>
     * because it uses this, so it can not be static
     */
    purgeSharedManager:function () {
        cc.Director.getInstance().getScheduler().unscheduleUpdateForTarget(this);
    },

    //protected
    _removeActionAtIndex:function (index, element) {
        var action = element.actions[index];

        if ((action == element.currentAction) && (!element.currentActionSalvaged)) {
            element.currentActionSalvaged = true;
        }

        cc.ArrayRemoveObjectAtIndex(element.actions,index);

        // update actionIndex in case we are in tick. looping over the actions
        if (element.actionIndex >= index) {
            element.actionIndex--;
        }

        if (element.actions.length == 0) {
            if (this._currentTarget == element) {
                this._currentTargetSalvaged = true;
            } else {
                this._deleteHashElement(element);
            }
        }
    },

    _deleteHashElement:function (element) {
        cc.ArrayRemoveObject(this._targets, element);
        if (element) {
            element.actions = null;
            element.target = null;
        }
    },

    _actionAllocWithHashElement:function (element) {
        // 4 actions per Node by default
        if (element.actions == null) {
            element.actions = [];
        }
    },

    /**
     * @param {Number} dt delta time in seconds
     */
    update:function (dt) {
        for (var elt = 0; elt < this._targets.length; elt++) {
            this._currentTarget = this._targets[elt];
            this._currentTargetSalvaged = false;
            if (!this._currentTarget.paused) {
                // The 'actions' CCMutableArray may change while inside this loop.
                for (this._currentTarget.actionIndex = 0; this._currentTarget.actionIndex < this._currentTarget.actions.length;
                     this._currentTarget.actionIndex++) {
                    this._currentTarget.currentAction = this._currentTarget.actions[this._currentTarget.actionIndex];
                    if (!this._currentTarget.currentAction) {
                        continue;
                    }

                    this._currentTarget.currentActionSalvaged = false;

                    this._currentTarget.currentAction.step(dt);

                    if (this._currentTarget.currentActionSalvaged) {
                        // The currentAction told the node to remove it. To prevent the action from
                        // accidentally deallocating itself before finishing its step, we retained
                        // it. Now that step is done, it's safe to release it.
                        this._currentTarget.currentAction = null;//release
                    } else if (this._currentTarget.currentAction.isDone()) {
                        this._currentTarget.currentAction.stop();

                        var action = this._currentTarget.currentAction;
                        // Make currentAction nil to prevent removeAction from salvaging it.
                        this._currentTarget.currentAction = null;
                        this.removeAction(action);
                    }

                    this._currentTarget.currentAction = null;
                }
            }

            // elt, at this moment, is still valid
            // so it is safe to ask this here (issue #490)

            // only delete currentTarget if no actions were scheduled during the cycle (issue #481)
            if (this._currentTargetSalvaged && this._currentTarget.actions.length == 0) {
                this._deleteHashElement(this._currentTarget);
            }
        }
    }
});
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (C) 2010      Lam Pham

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * Progress to percentage
 * @class
 * @extends cc.ActionInterval
 */
cc.ProgressTo = cc.ActionInterval.extend(/** @lends cc.ProgressTo# */{
    _to:0,
    _from:0,

    /** Initializes with a duration and a percent
     * @param {Number} duration duration in seconds
     * @param {Number} percent
     * @return {Boolean}
     */
    initWithDuration:function (duration, percent) {
        if (this._super(duration)) {
            this._to = percent;
            return true;
        }
        return false;
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {
        var newZone = null;
        var copy = null;
        if (zone && zone._copyObject) {
            //in case of being called at sub class
            copy = zone._copyObject;
        } else {
            copy = new cc.ProgressTo();
            zone = newZone = new cc.Zone(copy);
        }

        this._super(zone);

        copy.initWithDuration(this._duration, this._to);

        return copy;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super(target);
        this._from = target.getPercentage();

        // XXX: Is this correct ?
        // Adding it to support CCRepeat
        if (this._from == 100) {
            this._from = 0;
        }
    },

    /**
     * @param {Number} time time in seconds
     */
    update:function (time) {
        if (this._target  instanceof cc.ProgressTimer) {
            this._target.setPercentage(this._from + (this._to - this._from) * time);
        }
    }
});

/** Creates and initializes with a duration and a percent
 * @param {Number} duration duration in seconds
 * @param {Number} percent
 * @return {cc.ProgressTo}
 * @example
 * // example
 * var to = cc.ProgressTo.create(2, 100);
 *
 */
cc.ProgressTo.create = function (duration, percent) {
    var progressTo = new cc.ProgressTo();
    progressTo.initWithDuration(duration, percent);

    return progressTo;
};

/**
 * Progress from a percentage to another percentage
 * @class
 * @extends cc.ActionInterval
 */
cc.ProgressFromTo = cc.ActionInterval.extend(/** @lends cc.ProgressFromTo# */{
    _to:0,
    _from:0,
    /** Initializes the action with a duration, a "from" percentage and a "to" percentage
     * @param {Number} duration duration in seconds
     * @param {Number} fromPercentage
     * @param {Number} toPercentage
     * @return {Boolean}
     */
    initWithDuration:function (duration, fromPercentage, toPercentage) {
        if (this._super(duration)) {
            this._to = toPercentage;
            this._from = fromPercentage;
            return true;
        }
        return false;
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {
        var newZone = null;
        var copy = null;
        if (zone && zone._copyObject) {
            //in case of being called at sub class
            copy = zone._copyObject;
        } else {
            copy = new cc.ProgressFromTo();
            zone = newZone = new cc.Zone(copy);
        }

        this._super(zone);
        copy.initWithDuration(this._duration, this._from, this._to);
        return copy;
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.ProgressFromTo.create(this._duration, this._to, this._from);
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super(target);
    },

    /**
     * @param {Number} time time in seconds
     */
    update:function (time) {
        if (this._target  instanceof cc.ProgressTimer) {
            this._target.setPercentage(this._from + (this._to - this._from) * time);
        }
    }
});

/** Creates and initializes the action with a duration, a "from" percentage and a "to" percentage
 * @param {Number} duration duration in seconds
 * @param {Number} fromPercentage
 * @param {Number} toPercentage
 * @return {cc.ProgressFromTo}
 * @example
 * // example
 *  var fromTO = cc.ProgressFromTo.create(2, 100.0, 0.0);
 */
cc.ProgressFromTo.create = function (duration, fromPercentage, toPercentage) {
    var progressFromTo = new cc.ProgressFromTo();
    progressFromTo.initWithDuration(duration, fromPercentage, toPercentage);
    return progressFromTo;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

var cc = cc = cc || {};

/**
 @brief Base class for cc.Camera actions
 */
cc.ActionCamera = cc.ActionInterval.extend({
    centerXOrig:0,
    centerYOrig:0,
    centerZOrig:0,
    eyeXOrig:0,
    eyeYOrig:0,
    eyeZOrig:0,
    upXOrig:0,
    upYOrig:0,
    upZOrig:0,
    // super methods
    startWithTarget:function (target) {
        this._super(target);

        var camera = target.getCamera();
        camera.getCenterXYZ(this.centerXOrig, this.centerYOrig, this.centerZOrig);
        camera.getEyeXYZ(this.eyeXOrig, this.eyeYOrig, this.eyeZOrig);
        camera.getUpXYZ(this.upXOrig, this.upYOrig, this.upZOrig);
    },
    reverse:function () {
        return cc.ReverseTime.create(this);
    }
});

/**
 @brief cc.OrbitCamera action
 Orbits the camera around the center of the screen using spherical coordinates
 */
cc.OrbitCamera = cc.ActionCamera.extend({
    radius:0.0,
    deltaRadius:0.0,
    angleZ:0.0,
    deltaAngleZ:0.0,
    angleX:0.0,
    deltaAngleX:0.0,
    radZ:0.0,
    radDeltaZ:0.0,
    radX:0.0,
    radDeltaX:0.0,

    /** initializes a cc.OrbitCamera action with radius, delta-radius,  z, deltaZ, x, deltaX */
    initWithDuration:function (t, radius, deltaRadius, angleZ, deltaAngleZ, angleX, deltaAngleX) {
        if (this._super(t)) {
            this.radius = radius;
            this.deltaRadius = deltaRadius;
            this.angleZ = angleZ;
            this.deltaAngleZ = deltaAngleZ;
            this.angleX = angleX;
            this.deltaAngleX = deltaAngleX;

            this.radDeltaZ = cc.DEGREES_TO_RADIANS(deltaAngleZ);
            this.radDeltaX = cc.DEGREES_TO_RADIANS(deltaAngleX);
            return true;
        }
        return false;
    },
    /** positions the camera according to spherical coordinates */
    sphericalRadius:function (newRadius, zenith, azimuth) {
        var ex, ey, ez, cx, cy, cz, x, y, z;
        var r; // radius
        var s;

        var camera = this._target.getCamera();
        camera.getEyeXYZ(ex, ey, ez);
        camera.getCenterXYZ(cx, cy, cz);

        x = ex - cx;
        y = ey - cy;
        z = ez - cz;

        r = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2));
        s = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
        if (s == 0.0)
            s = cc.FLT_EPSILON;
        if (r == 0.0)
            r = cc.FLT_EPSILON;

        zenith = Math.acos(z / r);
        if (x < 0)
            azimuth = Math.PI - Math.asin(y / s);
        else
            azimuth = Math.asin(y / s);

        newRadius = r / cc.Camera.getZEye();
    },
    // super methods
    copyWithZone:function (zone) {
        var newZone = null;
        var ret = null;
        if (zone && zone.copyObject) //in case of being called at sub class
            ret = zone.copyObject;
        else {
            ret = new cc.OrbitCamera();
            zone = newZone = new cc.Zone(ret);
        }

        cc.ActionInterval.copyWithZone(zone);

        ret.initWithDuration(this._duration, this.radius, this.deltaRadius, this.angleZ, this.deltaAngleZ, this.angleX, this.deltaAngleX);

        return ret;
    },
    startWithTarget:function (target) {
        this._super(target);
        var r, zenith, azimuth;
        this.sphericalRadius(r, zenith, azimuth);
        if (isNaN(this.radius)) {
            this.radius = r;
        }
        if (isNaN(this.angleZ)) {
            this.angleZ = cc.RADIANS_TO_DEGREES(zenith);
        }
        if (isNaN(this.angleX)) {
            this.angleX = cc.RADIANS_TO_DEGREES(azimuth);
        }

        this.radZ = cc.DEGREES_TO_RADIANS(this.angleZ);
        this.radX = cc.DEGREES_TO_RADIANS(this.angleX);
    },
    update:function (dt) {
        var r = (this.radius + this.deltaRadius * dt) * cc.Camera.getZEye();
        var za = this.radZ + this.radDeltaZ * dt;
        var xa = this.radX + this.radDeltaX * dt;

        var i = Math.sin(za) * Math.cos(xa) * r + this.centerXOrig;
        var j = Math.sin(za) * Math.sin(xa) * r + this.centerYOrig;
        var k = Math.cos(za) * r + this.centerZOrig;

        this._target.getCamera().setEyeXYZ(i, j, k);
    }
});

/** creates a cc.OrbitCamera action with radius, delta-radius,  z, deltaZ, x, deltaX */
cc.OrbitCamera.create = function (t, radius, deltaRadius, angleZ, deltaAngleZ, angleX, deltaAngleX) {
    var ret = new cc.OrbitCamera();
    if (ret.initWithDuration(t, radius, deltaRadius, angleZ, deltaAngleZ, angleX, deltaAngleX)) {
        return ret;
    }
    return null;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * Base class for Easing actions
 * @class
 * @extends cc.ActionInterval
 */

cc.ActionEase = cc.ActionInterval.extend(/** @lends cc.ActionEase# */{

    /** initializes the action
     * @param {cc.ActionInterval} action
     * @return {Boolean}
     */
    initWithAction:function (action) {
        cc.Assert(action != null, "");

        if (this.initWithDuration(action.getDuration())) {
            this._other = action;
            return true;
        }
        return false;
    },
    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super(target);
        this._other.startWithTarget(this._target);   //TODO, need to be checked
    },

    /**
     * Stop the action.
     */
    stop:function () {
        this._other.stop();
        this._super();
    },

    /**
     * @param {Number} time1
     */
    update:function (time1) {
        this._other.update(time1);
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.ActionEase.create(this._other.reverse());
    },

    _other:null
});

/** creates the action of ActionEase
 * @param {cc.ActionInterval} action
 * @return {cc.ActionEase}
 * @example
 * // example
 * var moveEase = cc.ActionEase.create(action);
 */
cc.ActionEase.create = function (action) {
    var ret = new cc.ActionEase();
    if (ret) {
        ret.initWithAction(action);
    }
    return ret;
};

/**
 * Base class for Easing actions with rate parameters
 * @class
 * @extends cc.ActionEase
 */
cc.EaseRateAction = cc.ActionEase.extend(/** @lends cc.EaseRateAction# */{

    /** set rate value for the actions
     * @param {Number} rate
     */
    setRate:function (rate) {
        this._rate = rate;
    },

    /** get rate value for the actions
     * @return {Number}
     */
    getRate:function () {
        return this._rate;
    },

    /**
     * Initializes the action with the inner action and the rate parameter
     * @param {cc.ActionInterval} action
     * @param {Number} rate
     * @return {Boolean}
     */
    initWithAction:function (action, rate) {
        if (this._super(action)) {
            this._rate = rate;
            return true;
        }
        return false;
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.EaseRateAction.create(this._other.reverse(), 1 / this._rate);
    },

    _rate:null
});

/** Creates the action with the inner action and the rate parameter
 * @param {cc.ActionInterval} action
 * @param {Number} rate
 * @return {cc.EaseRateAction}
 * @example
 * // example
 * var moveEaseRateAction = cc.EaseRateAction.create(action, 3.0);
 */
cc.EaseRateAction.create = function (action, rate) {
    var ret = new cc.EaseRateAction();
    if (ret) {
        ret.initWithAction(action, rate);

    }
    return ret;
};

/**
 * cc.EaseIn action with a rate
 * @class
 * @extends cc.EaseRateAction
 */
cc.EaseIn = cc.EaseRateAction.extend(/** @lends cc.EaseIn# */{
    /**
     * @param {Number} time1
     */
    update:function (time1) {
        this._other.update(Math.pow(time1, this._rate));
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.EaseIn.create(this._other.reverse(), 1 / this._rate);
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }
});

/** Creates the action with the inner action and the rate parameter
 * @param {cc.ActionInterval} action
 * @param {Number} rate
 * @return {cc.EaseIn}
 * @example
 * // example
 * var moveEaseIn = cc.EaseIn.create(action, 3.0);
 */
cc.EaseIn.create = function (action, rate) {
    var ret = new cc.EaseIn();
    if (ret) {
        ret.initWithAction(action, rate);

    }
    return ret;
};
/**
 * cc.EaseOut action with a rate
 * @class
 * @extends cc.EaseRateAction
 */
cc.EaseOut = cc.EaseRateAction.extend(/** @lends cc.EaseOut# */{

    /**
     * @param {Number} time1
     */
    update:function (time1) {
        this._other.update(Math.pow(time1, 1 / this._rate));
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.EaseOut.create(this._other.reverse(), 1 / this._rate);
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }


});

/** Creates the action with the inner action and the rate parameter
 * @param {cc.ActionInterval} action
 * @param {Number} rate
 * @return {cc.EaseOut}
 * @example
 * // example
 * var moveEaseOut = cc.EaseOut.create(action, 3.0);
 */
cc.EaseOut.create = function (action, rate) {
    var ret = new cc.EaseOut();
    if (ret) {
        ret.initWithAction(action, rate);

    }
    return ret;
};

/**
 * cc.EaseInOut action with a rate
 * @class
 * @extends cc.EaseRateAction
 */
cc.EaseInOut = cc.EaseRateAction.extend(/** @lends cc.EaseInOut# */{

    /**
     * @param {Number} time1
     */
    update:function (time1) {
        time1 *= 2;
        if (time1 < 1) {
            this._other.update(0.5 * Math.pow(time1, this._rate));
        } else {
            this._other.update(1.0 - 0.5 * Math.pow(2 - time1, this._rate));
        }
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.EaseInOut.create(this._other.reverse(), this._rate);

    }


});

/** Creates the action with the inner action and the rate parameter
 * @param {cc.ActionInterval} action
 * @param {Number} rate
 * @return {cc.EaseInOut}
 * @example
 * // example
 * var moveEaseInOut = cc.EaseInOut.create(action, 3.0);
 */
cc.EaseInOut.create = function (action, rate) {
    var ret = new cc.EaseInOut();
    if (ret) {
        ret.initWithAction(action, rate);

    }
    return ret;
};
/**
 * cc.Ease Exponential In
 * @class
 * @extends cc.ActionEase
 */
cc.EaseExponentialIn = cc.ActionEase.extend(/** @lends cc.EaseExponentialIn# */{

    /**
     * @param {Number} time1
     */
    update:function (time1) {
        this._other.update(time1 == 0 ? 0 : Math.pow(2, 10 * (time1 / 1 - 1)) - 1 * 0.001);

    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.EaseExponentialOut.create(this._other.reverse());
    },
    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }


});

/** creates the action
 * @param {cc.ActionInterval} action
 * @return {cc.EaseExponentialIn}
 * @example
 * // example
 * var moveEaseExponentialIn = cc.EaseExponentialIn.create(action);
 */
cc.EaseExponentialIn.create = function (action) {
    var ret = new cc.EaseExponentialIn();
    if (ret) {
        ret.initWithAction(action);

    }
    return ret;
};
/**
 * Ease Exponential Out
 * @class
 * @extends cc.ActionEase
 */
cc.EaseExponentialOut = cc.ActionEase.extend(/** @lends cc.EaseExponentialOut# */{

    /**
     * @param {Number} time1
     */
    update:function (time1) {
        this._other.update(time1 == 1 ? 1 : (-(Math.pow(2, -10 * time1 / 1)) + 1));
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.EaseExponentialIn.create(this._other.reverse());
    },
    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }



});

/** creates the action
 * @param {cc.ActionInterval} action
 * @return {cc.EaseExponentialOut}
 * @example
 * // example
 * var moveEaseExponentialOut = cc.EaseExponentialOut.create(action);
 */
cc.EaseExponentialOut.create = function (action) {
    var ret = new cc.EaseExponentialOut();
    if (ret) {
        ret.initWithAction(action);

    }
    return ret;
};
/**
 * Ease Exponential InOut
 * @class
 * @extends cc.ActionEase
 */
cc.EaseExponentialInOut = cc.ActionEase.extend(/** @lends cc.EaseExponentialInOut# */{

    /**
     * @param {Number} time1
     */
    update:function (time1) {
        time1 /= 0.5;
        if (time1 < 1) {
            time1 = 0.5 * Math.pow(2, 10 * (time1 - 1));
        } else {
            time1 = 0.5 * (-Math.pow(2, 10 * (time1 - 1)) + 2);
        }

        this._other.update(time1);

    },

    /**
     * @return {cc.EaseExponentialInOut}
     */
    reverse:function () {
        return cc.EaseExponentialInOut.create(this._other.reverse());
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }

});


/** creates the action
 * @param {cc.ActionInterval} action
 * @return {cc.EaseExponentialInOut}
 * @example
 * // example
 * var moveEaseExponentialInOut = cc.EaseExponentialInOut.create(action);
 */
cc.EaseExponentialInOut.create = function (action) {
    var ret = new cc.EaseExponentialInOut();
    if (ret) {
        ret.initWithAction(action);

    }
    return ret;
};


/**
 * Ease Sine In
 * @class
 * @extends cc.ActionEase
 */
cc.EaseSineIn = cc.ActionEase.extend(/** @lends cc.EaseSineIn# */{
    /**
     * @param {Number} time1
     */
    update:function (time1) {
        this._other.update(-1 * Math.cos(time1 * Math.PI / 2) + 1);
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.EaseSineOut.create(this._other.reverse());
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }
});

/** creates the action
 * @param {cc.ActionInterval} action
 * @return {cc.EaseSineIn}
 * @example
 * // example
 * var moveSineIn = cc.EaseSineIn.create(action);
 */
cc.EaseSineIn.create = function (action) {
    var ret = new cc.EaseSineIn();
    if (ret) {
        ret.initWithAction(action);

    }
    return ret;
};
/**
 * Ease Sine Out
 * @class
 * @extends cc.ActionEase
 */
cc.EaseSineOut = cc.ActionEase.extend(/** @lends cc.EaseSineOut# */{
    /**
     * @param {Number} time1
     */
    update:function (time1) {
        this._other.update(Math.sin(time1 * Math.PI / 2));
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.EaseSineIn.create(this._other.reverse());
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }
});


/** creates the action
 * @param {cc.ActionInterval} action
 * @return {cc.EaseSineOut}
 * @example
 * // example
 * var moveEaseOut = cc.EaseSineOut.create(action);
 */
cc.EaseSineOut.create = function (action) {
    var ret = new cc.EaseSineOut();
    if (ret) {
        ret.initWithAction(action);

    }
    return ret;
};


/**
 * Ease Sine InOut
 * @class
 * @extends cc.ActionEase
 */
cc.EaseSineInOut = cc.ActionEase.extend(/** @lends cc.EaseSineInOut# */{

    /**
     * @param {Number} time1
     */
    update:function (time1) {
        this._other.update(-0.5 * (Math.cos(Math.PI * time1) - 1));

    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.EaseSineInOut.create(this._other.reverse());
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }

});

/** creates the action
 * @param {cc.ActionInterval} action
 * @return {cc.EaseSineInOut}
 * @example
 * // example
 * var moveEaseSineInOut = cc.EaseSineInOut.create(action);
 */
cc.EaseSineInOut.create = function (action) {
    var ret = new cc.EaseSineInOut();
    if (ret) {
        ret.initWithAction(action);

    }
    return ret;
};

/**
 * Ease Elastic abstract class
 * @class
 * @extends cc.ActionEase
 */
cc.EaseElastic = cc.ActionEase.extend(/** @lends cc.EaseElastic# */{

    /** get period of the wave in radians. default is 0.3
     * @return {Number}
     */
    getPeriod:function () {
        return this._period;
    },

    /** set period of the wave in radians.
     * @param {Number} period
     */
    setPeriod:function (period) {
        this._period = period;
    },

    /** Initializes the action with the inner action and the period in radians (default is 0.3)
     * @param {cc.ActionInterval} action
     * @param {Number} period
     * @return {Boolean}
     */
    initWithAction:function (action, period) {
        this._super(action);
        this._period = (period == null) ? 3.0 : period;
        return true;
    },

    /**
     * @return {Null}
     */
    reverse:function () {
        cc.Assert(0, "Override me");

        return null;
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    },

    _period:null
});

/** Creates the action with the inner action and the period in radians (default is 0.3)
 * @param {cc.ActionInterval} action
 * @param {Number} period
 * @return {cc.EaseElastic}
 * @example
 * // example
 * var moveEaseElastic = cc.EaseElastic.create(action, 3.0);
 */
cc.EaseElastic.create = function (action, period) {
    var ret = new cc.EaseElastic();
    if (ret) {
        if (period == null) {
            ret.initWithAction(action);
        } else {
            ret.initWithAction(action, period);
        }

    }
    return ret;
};


/**
 * Ease Elastic In action.
 * @warning This action doesn't use a bijective fucntion. Actions like Sequence might have an unexpected result when used with this action.
 * @class
 * @extends cc.EaseElastic
 */
cc.EaseElasticIn = cc.EaseElastic.extend(/** @lends cc.EaseElasticIn# */{
    /**
     * @param {Number} time1
     */
    update:function (time1) {
        var newT = 0;
        if (time1 == 0 || time1 == 1) {
            newT = time1;
        } else {
            var s = this._period / 4;
            time1 = time1 - 1;
            newT = -Math.pow(2, 10 * time1) * Math.sin((time1 - s) * Math.PI * 2 / this._period);
        }

        this._other.update(newT);
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.EaseElasticOut.create(this._other.reverse(), this._period);
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }

});


/** Creates the action with the inner action and the period in radians (default is 0.3)
 * @param {cc.ActionInterval} action
 * @param {Number} period
 * @return {cc.EaseElasticIn}
 * @example
 * // example
 * var moveEaseElasticIn = cc.EaseElasticIn.create(action, 3.0);
 */
cc.EaseElasticIn.create = function (action, period) {
    var ret = new cc.EaseElasticIn();
    if (ret) {
        if (period == null) {
            ret.initWithAction(action);
        } else {
            ret.initWithAction(action, period);
        }

    }
    return ret;
};

/**
 * Ease Elastic Out action.
 * @warning This action doesn't use a bijective fucntion. Actions like Sequence might have an unexpected result when used with this action.
 * @class
 * @extends cc.EaseElastic
 */
cc.EaseElasticOut = cc.EaseElastic.extend(/** @lends cc.EaseElasticOut# */{
    /**
     * @param {Number} time1
     */
    update:function (time1) {
        var newT = 0;
        if (time1 == 0 || time1 == 1) {
            newT = time1;
        } else {
            var s = this._period / 4;
            newT = Math.pow(2, -10 * time1) * Math.sin((time1 - s) * Math.PI * 2 / this._period) + 1;
        }

        this._other.update(newT);

    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.EaseElasticIn.create(this._other.reverse(), this._period);
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }


});


/** Creates the action with the inner action and the period in radians (default is 0.3)
 * @param {cc.ActionInterval} action
 * @param {Number} period
 * @return {cc.EaseElasticOut}
 * @example
 * // example
 * var moveEaseElasticOut = cc.EaseElasticOut.create(action, 3.0);
 */
cc.EaseElasticOut.create = function (action, period) {
    var ret = new cc.EaseElasticOut();
    if (ret) {
        if (period == null) {
            ret.initWithAction(action);
        } else {
            ret.initWithAction(action, period);
        }

    }
    return ret;
};

/**
 * Ease Elastic InOut action.
 * @warning This action doesn't use a bijective fucntion. Actions like Sequence might have an unexpected result when used with this action.
 * @class
 * @extends cc.EaseElastic
 */
cc.EaseElasticInOut = cc.EaseElastic.extend(/** @lends cc.EaseElasticInOut# */{
    /**
     * @param {Number} time1
     */
    update:function (time1) {
        var newT = 0;
        if (time1 == 0 || time1 == 1) {
            newT = time1;
        } else {
            time1 = time1 * 2;
            if (!this._period) {
                this._period = 0.3 * 1.5;
            }

            var s = this._period / 4;

            time1 = time1 - 1;
            if (time1 < 0) {
                newT = -0.5 * Math.pow(2, 10 * time1) * Math.sin((time1 - s) * Math.PI * 2 / this._period);
            } else {
                newT = Math.pow(2, -10 * time1) * Math.sin((time1 - s) * Math.PI * 2 / this._period) * 0.5 + 1;
            }
        }

        this._other.update(newT);

    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.EaseInOut.create(this._other.reverse(), this._period);
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }

});

/** Creates the action with the inner action and the period in radians (default is 0.3)
 * @param {cc.ActionInterval} action
 * @param {Number} period
 * @return {cc.EaseElasticInOut}
 * @example
 * // example
 * var moveEaseElasticInOut = cc.EaseElasticInOut.create(action, 3.0);
 */
cc.EaseElasticInOut.create = function (action, period) {
    var ret = new cc.EaseElasticInOut();
    if (ret) {
        if (period == null) {
            ret.initWithAction(action);
        } else {
            ret.initWithAction(action, period);
        }

    }
    return ret;
};

/**
 * cc.EaseBounce abstract class.
 * @class
 * @extends cc.ActionEase
 */
cc.EaseBounce = cc.ActionEase.extend(/** @lends cc.EaseBounce# */{
    /**
     * @param {Number} time1
     * @return {Number}
     */
    bounceTime:function (time1) {
        if (time1 < 1 / 2.75) {
            return 7.5625 * time1 * time1;
        } else if (time1 < 2 / 2.75) {
            time1 -= 1.5 / 2.75;
            return 7.5625 * time1 * time1 + 0.75;
        } else if (time1 < 2.5 / 2.75) {
            time1 -= 2.25 / 2.75;
            return 7.5625 * time1 * time1 + 0.9375;
        }

        time1 -= 2.625 / 2.75;
        return 7.5625 * time1 * time1 + 0.984375;
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.EaseBounce.create(this._other.reverse());
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }

});

/** creates the action
 * @param {cc.ActionInterval} action
 * @return {cc.EaseBounce}
 * @example
 * // example
 * var moveEaseBounce = cc.EaseBounce.create(action);
 */
cc.EaseBounce.create = function (action) {
    var ret = new cc.EaseBounce();
    if (ret) {
        ret.initWithAction(action);
    }
    return ret;
};

/**
 * cc.EaseBounceIn action.
 * @warning This action doesn't use a bijective function. Actions like Sequence might have an unexpected result when used with this action.
 * @class
 * @extends cc.EaseBounce
 */
cc.EaseBounceIn = cc.EaseBounce.extend(/** @lends cc.EaseBounceIn# */{
    /**
     * @param {Number} time1
     */
    update:function (time1) {
        var newT = 1 - this.bounceTime(1 - time1);
        this._other.update(newT);
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.EaseBounceOut.create(this._other.reverse());
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }


});

/** creates the action
 * @param {cc.ActionInterval} action
 * @return {cc.EaseBounceIn}
 * @example
 * // example
 * var moveEaseBounceIn = cc.EaseBounceIn.create(action);
 */
cc.EaseBounceIn.create = function (action) {
    var ret = new cc.EaseBounceIn();
    if (ret) {
        ret.initWithAction(action);
    }
    return ret;
};
/**
 * cc.EaseBounceOut action.
 * @warning This action doesn't use a bijective fucntion. Actions like Sequence might have an unexpected result when used with this action.
 * @class
 * @extends cc.EaseBounce
 */
cc.EaseBounceOut = cc.EaseBounce.extend(/** @lends cc.EaseBounceOut# */{

    /**
     * @param {Number} time1
     */
    update:function (time1) {
        var newT = this.bounceTime(time1);
        this._other.update(newT);
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.EaseBounceIn.create(this._other.reverse());
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }


});

/** creates the action
 * @param {cc.ActionInterval} action
 * @return {cc.EaseBounceOut}
 * @example
 * // example
 * var moveEaseBounceOut = cc.EaseBounceOut.create(action);
 */
cc.EaseBounceOut.create = function (action) {
    var ret = new cc.EaseBounceOut();
    if (ret) {
        ret.initWithAction(action);
    }
    return ret;
};

/**
 * cc.EaseBounceInOut action.
 * @warning This action doesn't use a bijective fucntion. Actions like Sequence might have an unexpected result when used with this action.
 * @class
 * @extends cc.EaseBounce
 */
cc.EaseBounceInOut = cc.EaseBounce.extend(/** @lends cc.EaseBounceInOut# */{

    /**
     * @param {Number} time1
     */
    update:function (time1) {
        var newT = 0;
        if (time1 < 0.5) {
            time1 = time1 * 2;
            newT = (1 - this.bounceTime(1 - time1)) * 0.5;
        } else {
            newT = this.bounceTime(time1 * 2 - 1) * 0.5 + 0.5;
        }

        this._other.update(newT);

    },


    /**
     * @return {cc.ActionInterval}
     */
    reverse:function(){
        return cc.EaseBounceInOut.create(this._other.reverse());
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }

});

/** creates the action
 * @param {cc.ActionInterval} action
 * @return {cc.EaseBounceInOut}
 * @example
 * // example
 * var moveEaseBounceInOut = cc.EaseBounceInOut.create(action);
 */
cc.EaseBounceInOut.create = function (action) {
    var ret = new cc.EaseBounceInOut();
    if (ret) {
        ret.initWithAction(action);
    }
    return ret;
};

/**
 * cc.EaseBackIn action.
 * @warning This action doesn't use a bijective fucntion. Actions like Sequence might have an unexpected result when used with this action.
 * @class
 * @extends cc.ActionEase
 */
cc.EaseBackIn = cc.ActionEase.extend(/** @lends cc.EaseBackIn# */{

    /**
     * @param {Number} time1
     */
    update:function (time1) {
        var overshoot = 1.70158;
        this._other.update(time1 * time1 * ((overshoot + 1) * time1 - overshoot));

    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.EaseBackOut.create(this._other.reverse());

    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }

});


/** creates the action
 * @param {cc.ActionInterval} action
 * @return {cc.EaseBackIn}
 * @example
 * // example
 * var moveEaseBackIn = cc.EaseBackIn.create(action);
 */
cc.EaseBackIn.create = function (action) {
    var ret = new cc.EaseBackIn();
    if (ret) {
        ret.initWithAction(action);
    }
    return ret;
};

/**
 * cc.EaseBackOut action.
 * @warning This action doesn't use a bijective fucntion. Actions like Sequence might have an unexpected result when used with this action.
 * @class
 * @extends cc.ActionEase
 */
cc.EaseBackOut = cc.ActionEase.extend(/** @lends cc.EaseBackOut# */{
    /**
     * @param {Number} time1
     */
    update:function (time1) {
        var overshoot = 1.70158;

        time1 = time1 - 1;
        this._other.update(time1 * time1 * ((overshoot + 1) * time1 + overshoot) + 1);
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function () {
        return cc.EaseBackIn.create(this._other.reverse());
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }
});

/** creates the action
 * @param {cc.ActionInterval} action
 * @return {cc.EaseBackOut}
 * @example
 * // example
 * var moveEaseBackOut = cc.EaseBackOut.create(action);
 */
cc.EaseBackOut.create = function (action) {
    var ret = new cc.EaseBackOut();
    if (ret) {
        ret.initWithAction(action);
    }
    return ret;
};

/**
 * cc.EaseBackInOut action.
 * @warning This action doesn't use a bijective fucntion. Actions like Sequence might have an unexpected result when used with this action.
 * @class
 * @extends cc.ActionEase
 */
cc.EaseBackInOut = cc.ActionEase.extend(/** @lends cc.EaseBackInOut# */{
    /**
     * @param {Number} time1
     */
    update:function (time1) {
        var overshoot = 1.70158 * 1.525;

        time1 = time1 * 2;
        if (time1 < 1) {
            this._other.update((time1 * time1 * ((overshoot + 1) * time1 - overshoot)) / 2);
        } else {
            time1 = time1 - 2;
            this._other.update((time1 * time1 * ((overshoot + 1) * time1 + overshoot)) / 2 + 1);
        }
    },

    /**
     * @return {cc.ActionInterval}
     */
    reverse:function(){
        return cc.EaseBackInOut.create(this._other.reverse());
    },

    /**
     * @deprecated It is not needed anymore.
     * @param zone
     */
    copyWithZone:function (zone) {

    }

});


/** creates the action
 * @param {cc.ActionInterval} action
 * @return {cc.EaseBackInOut}
 * @example
 * // example
 * var moveEaseBackInOut = cc.EaseBackInOut.create(action);
 */
cc.EaseBackInOut.create = function (action) {
    var ret = new cc.EaseBackInOut();
    if (ret) {
        ret.initWithAction(action);
    }
    return ret;
};

/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

var cc = cc = cc || {};

/** @brief Base class for Grid actions */
cc.GridAction = cc.ActionInterval.extend({
    _gridSize:null,
    startWithTarget:function (target) {
        this._super(target);
        var newgrid = this.getGrid();
        var t = this._target;
        var targetGrid = t.getGrid();
        if (targetGrid && targetGrid.getReuseGrid() > 0) {
            if (targetGrid.isActive() && targetGrid.getGridSize().x == this._gridSize.x && targetGrid.getGridSize().y == this._gridSize.y) {
                targetGrid.reuse();
            }
            else {
                cc.Assert(0, "");
            }
        }
        else {
            if (targetGrid && targetGrid.isActive()) {
                targetGrid.setActive(false);
            }
            t.setGrid(newgrid);
            t.getGrid().setActive(true);
        }
    },

    reverse:function () {
        return cc.ReverseTime.create(this);
    },

    /** initializes the action with size and duration */
    initWithSize:function (gridSize, duration) {
        if (this.initWithDuration(duration)) {
            this._gridSize = gridSize;
            return true;
        }
        return false;
    },

    /** returns the grid */
    getGrid:function () {
        // Abstract class needs implementation
        cc.Assert(0, "");
        return null;
    }
});

/** creates the action with size and duration */
cc.GridAction.create = function (gridSize, duration) {
    var action = new cc.GridAction();
    action.initWithSize(gridSize, duration)
    return action;
},

/**
 @brief Base class for cc.Grid3D actions.
 Grid3D actions can modify a non-tiled grid.
 */
    cc.Grid3DAction = cc.GridAction.extend({
        /** returns the grid */
        getGrid:function () {
            return cc.Grid3D.create(this._gridSize);
        },

        /** returns the vertex than belongs to certain position in the grid */
        vertex:function (pos) {
            var g = this._target.getGrid();
            return g.vertex(pos);
        },

        /** returns the non-transformed vertex than belongs to certain position in the grid */
        originalVertex:function (pos) {
            var g = this._target.getGrid();
            return g.originalVertex(pos);
        },

        /** sets a new vertex to a certain position of the grid */
        setVertex:function (pos, vertex) {
            var g = this._target.getGrid();
            g.setVertex(pos, vertex);
        }
    });
/** creates the action with size and duration */
cc.Grid3DAction.create = function () {

};
/** @brief Base class for cc.TiledGrid3D actions */
cc.TiledGrid3DAction = cc.GridAction.extend({
    /** returns the tile that belongs to a certain position of the grid */
    tile:function (pos) {
        var g = this._target.getGrid();
        return g.tile(pos);
    },

    /** returns the non-transformed tile that belongs to a certain position of the grid */
    originalTile:function (pos) {
        var g = this._target.getGrid();
        return g.originalTile(pos);
    },

    /** sets a new tile to a certain position of the grid */
    setTile:function (pos, coords) {
        var g = this._target.getGrid();
        return g.setTile(pos, coords);
    },

    /** returns the grid */
    getGrid:function () {
        return cc.TiledGrid3D.create(this._gridSize);
    }
});

/** creates the action with size and duration */
cc.TiledGrid3DAction.create = function (gridSize, duration) {

};

/** @brief cc.AccelDeccelAmplitude action */
cc.AccelDeccelAmplitude = cc.ActionInterval.extend({
    _rate:null,
    _other:null,
    /** initializes the action with an inner action that has the amplitude property, and a duration time */
    initWithAction:function (action, duration) {
        if (cc.ActionInterval.initWithDuration(duration)) {
            this._rate = 1.0;
            this._other = action;
            return true;
        }
        return false;
    },

    startWithTarget:function (target) {
        cc.ActionInterval.startWithTarget(target);
        this._other.startWithTarget(target);
    },

    update:function (time) {
        var f = time * 2;
        if (f > 1) {
            f -= 1;
            f = 1 - f;
        }
        this._other.setAmplitudeRate(Math.pow(f, this._rate));
    },

    reverse:function () {
        return cc.AccelDeccelAmplitude.create(this._other.reverse(), this._duration);
    },

    /** get amplitude rate */
    getRate:function () {
        return this._rate;
    },

    /** set amplitude rate */
    setRate:function (rate) {
        this._rate = rate;
    }
});

/** creates the action with an inner action that has the amplitude property, and a duration time */
cc.AccelDeccelAmplitude.create = function (action, duration) {
    var ret = new cc.AccelDeccelAmplitude();
    return ret;
};

/** @brief cc.AccelAmplitude action */
cc.AccelAmplitude = cc.ActionInterval.extend({
    _rate:null,
    _other:null,
    /** initializes the action with an inner action that has the amplitude property, and a duration time */
    initWithAction:function (action, duration) {
        if (cc.ActionInterval.initWithDuration(duration)) {
            this._rate = 1.0;
            this._other = action;

            return true;
        }
        return false;
    },

    /** get amplitude rate */
    getRate:function () {
        return this._rate;
    },

    /** set amplitude rate */
    setRate:function (rate) {
        this._rate = rate;
    },

    startWithTarget:function (target) {
        cc.ActionInterval.startWithTarget(target);
        this._other.startWithTarget(target);
    },

    update:function (time) {

        this._other.setAmplitudeRate(Math.pow(time, this._rate));
        this._other.update(time);
    },

    reverse:function () {
        return cc.AccelAmplitude.create(this._other.reverse(), this._duration);
    }
});

/** creates the action with an inner action that has the amplitude property, and a duration time */
cc.AccelAmplitude.create = function (action, duration) {
    var ret = new cc.AccelAmplitude();
    return ret;
};

/** @brief cc.DeccelAmplitude action */
cc.DeccelAmplitude = cc.ActionInterval.extend({
    _rate:null,
    _other:null,
    /** initializes the action with an inner action that has the amplitude property, and a duration time */
    initWithAction:function (action, duration) {
        if (cc.ActionInterval.initWithDuration(duration)) {
            this._rate = 1.0;
            this._other = action;
            return true;
        }

        return false;
    },

    /** get amplitude rate */
    getRate:function () {
        return this._rate;
    },

    /** set amplitude rate */
    setRate:function (rate) {
        this._rate = rate;
    },

    startWithTarget:function (target) {
        cc.ActionInterval.startWithTarget(target);
        this._other.startWithTarget(target);
    },

    update:function (time) {
        this._other.setAmplitudeRate(Math.pow((1 - time), this._rate));
        this._other.update(time);
    },

    reverse:function () {
        return cc.DeccelAmplitude.create(this._other.reverse(), this._duration);
    }
});

/** creates the action with an inner action that has the amplitude property, and a duration time */
cc.DeccelAmplitude.create = function (action, duration) {
    var ret = new cc.DeccelAmplitude();
    return ret;
};

/** @brief cc.StopGrid action.
 @warning Don't call this action if another grid action is active.
 Call if you want to remove the the grid effect. Example:
 cc.Sequence.create(Lens.action(...), cc.StopGrid.create(...), null);
 */
cc.StopGrid = cc.ActionInstant.extend({
    startWithTarget:function (target) {
        this._super(target);
        var grid = this._target.getGrid();
        if (grid && grid.isActive()) {
            grid.setActive(false);
        }
    }
});

/** Allocates and initializes the action */
cc.StopGrid.create = function () {
    var action = new cc.StopGrid();
    return action;
};

/** @brief cc.ReuseGrid action */
cc.ReuseGrid = cc.ActionInstant.extend({
    _times:null,
    /** initializes an action with the number of times that the current grid will be reused */
    initWithTimes:function (times) {
        this._times = times;

        return true;
    },

    startWithTarget:function (target) {
        cc.ActionInstant.startWithTarget(target);

        if (this._target.getGrid() && this._target.getGrid().isActive()) {
            this._target.getGrid().setReuseGrid(this._target.getGrid().getReuseGrid() + this._times);
        }
    }

});

/** creates an action with the number of times that the current grid will be reused */
cc.ReuseGrid.create = function (times) {
    var action = new cc.ReuseGrid();
    return action;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/** cc.TurnOffTiles action.<br/>
 * Turn off the files in random order
 * @class
 * @extends cc.TiledGrid3DAction
 */
cc.TurnOffTiles = cc.TiledGrid3DAction.extend(/** @lends cc.TurnOffTiles# */{
    _seed:null,
    _tilesCount:0,
    _tilesOrder:[],

    /** initializes the action with a random seed, the grid size and the duration
     * @param {cc.GridSize} gridSize
     * @param {Number} duration
     * @param {Number} seed
     * @return {Boolean}
     */
    initWithSeed:function ( gridSize, duration, seed) {
        if (this.initWithSize(gridSize, duration)) {
            this._seed = seed;
            this._tilesOrder = null;

            return true;
        }

        return false;
    },

    /**
     * @param {Array} array
     * @param {Number} len
     */
    shuffle:function (array, len) {
        var i;
        for (i = len - 1; i >= 0; i--) {
            var j = parseInt(Math.random() * (i + 1));
            var v = array[i];
            array[i] = array[j];
            array[j] = v;
        }
    },

    /**
     * @param {cc.GridSize} pos
     */
    turnOnTile:function (pos) {
        this.setTile(pos, this.originalTile(pos));
    },

    /**
     * @param {cc.GridSize}pos
     */
    turnOffTile:function (pos) {
        var coords = new cc.Quad3();
        this.setTile(pos, coords);
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        var i;

        this._super(target);

        if (this._seed != -1) {
            parseInt(Math.random() * this._seed);
        }
        this._tilesCount = this._gridSize.x * this._gridSize.y;
        this._tilesOrder = [];

        for (i = 0; i < this._tilesCount; ++i) {
            this._tilesOrder[i] = i;
        }

        this.shuffle(this._tilesOrder, this._tilesCount);
    },

    /**
     * @param {Number} time
     */
    update:function (time) {
        var i, l, t;

        l = time * this._tilesCount;

        for (i = 0; i < this._tilesCount; i++) {
            t = this._tilesOrder[i];
            var tilePos = cc.g(t / this._gridSize.y, t % this._gridSize.y);

            if (i < l) {
                this.turnOffTile(tilePos);
            }
            else {
                this.turnOnTile(tilePos);
            }
        }
    }

});

/**
 * @param {cc.GridSize}gridSize
 * @param {Number} duration
 * @param {Number|Null} seed
 * @return {cc.TurnOffTiles}
 * @example
 * // example
 * // turnOffTiles without seed
 * var toff = cc.TurnOffTiles.create(cc.g(x, y), this._duration);
 *
 * // turnOffTiles with seed
 * var toff = cc.TurnOffTiles.create(cc.g(x, y), this._duration, 0);
 */
cc.TurnOffTiles.create = function (gridSize, duration, seed) {
    var action = new cc.TurnOffTiles();
    if(arguments.length == 2) {
        /** creates the action with the grid size and the duration */
        action.initWithSize(gridSize, duration);
    } else if (arguments.length == 3) {
        /** creates the action with the grid size, the duration and a random seed */
        action.initWithSeed(gridSize, duration, seed);
    }
    return action;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.
 Copyright (c) 2008 Radu Gruian
 Copyright (c) 2011 Vit Valentin

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.

 Orignal code by Radu Gruian: http://www.codeproject.com/Articles/30838/Overhauser-Catmull-Rom-Splines-for-Camera-Animatio.So

 Adapted to cocos2d-x by Vit Valentin

 Adapted from cocos2d-x to cocos2d-iphone by Ricardo Quesada
 ****************************************************************************/

/**
 * <p>Returns the Cardinal Spline position for a given set of control points, tension and time CatmullRom Spline formula: <br/>
 *   s(-ttt + 2tt - t)P1 + s(-ttt + tt)P2 + (2ttt - 3tt + 1)P2 + s(ttt - 2tt + t)P3 + (-2ttt + 3tt)P3 + s(ttt - tt)P4
 * </p>
 * @function
 * @param {cc.Point} p0
 * @param {cc.Point} p1
 * @param {cc.Point} p2
 * @param {cc.Point} p3
 * @param {Number} tension
 * @param {Number} t
 * @return {cc.Point}
 */
 cc.CardinalSplineAt = function (p0, p1, p2, p3, tension, t) {
    var t2 = t * t;
    var t3 = t2 * t;

    /*
     * Formula: s(-ttt + 2tt - t)P1 + s(-ttt + tt)P2 + (2ttt - 3tt + 1)P2 + s(ttt - 2tt + t)P3 + (-2ttt + 3tt)P3 + s(ttt - tt)P4
     */
    var s = (1 - tension) / 2;

    var b1 = s * ((-t3 + (2 * t2)) - t);                      // s(-t3 + 2 t2 - t)P1
    var b2 = s * (-t3 + t2) + (2 * t3 - 3 * t2 + 1);          // s(-t3 + t2)P2 + (2 t3 - 3 t2 + 1)P2
    var b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2);      // s(t3 - 2 t2 + t)P3 + (-2 t3 + 3 t2)P3
    var b4 = s * (t3 - t2);                                   // s(t3 - t2)P4

    var x = (p0.x * b1 + p1.x * b2 + p2.x * b3 + p3.x * b4);
    var y = (p0.y * b1 + p1.y * b2 + p2.y * b3 + p3.y * b4);
    return cc.p(x, y);
};

/**
 * An Array that contain control points. Used by cc.CardinalSplineTo and (By) and cc.CatmullRomTo (and By) actions.
 * @class
 * @extends cc.Node
 *
 * @example
 * //create a PointArray
 *  var array = cc.PointArray.create();
 *
 *  //add some points to this PointArray
 *  array.addControlPoint(cc.p(0, 0));
 *  array.addControlPoint(cc.p(winSize.width / 2 - 30, 0));
 *  array.addControlPoint(cc.p(winSize.width / 2 - 30, winSize.height - 80));
 *  array.addControlPoint(cc.p(0, winSize.height - 80));
 *  array.addControlPoint(cc.p(0, 0));
 */
cc.PointArray = cc.Node.extend(/** @lends cc.PointArray# */{
    /** Array that contains the control points */
    _controlPoints:null,

    /**
     * Constructor
     */
    ctor:function () {
        this._controlPoints = [];
    },

    /**
     * appends a control point
     * @param {cc.Point} controlPoint
     */
    addControlPoint:function (controlPoint) {
        // should create a new object of cc.Point
        // because developer always use this function like this
        // addControlPoint(ccp(x, y))
        // passing controlPoint is a temple object
        var temp = cc.p(controlPoint.x, controlPoint.y);
        this._controlPoints.push(temp);
    },

    /**
     * inserts a controlPoint at index
     * @param {cc.Point} controlPoint
     * @param {Number} index
     */
    insertControlPoint:function (controlPoint, index) {
        // should create a new object of cc.Point
        // because developer always use this function like this
        // insertControlPoint(ccp(x, y))
        // passing controlPoint is a temple object
        var temp = cc.p(controlPoint.x, controlPoint.y);
        this._controlPoints = cc.ArrayAppendObjectToIndex(this._controlPoints, temp, index);
    },

    /**
     * replaces an existing controlPoint at index
     * @param {cc.Point} controlPoint
     * @param {Number} index
     */
    replaceControlPoint:function (controlPoint, index) {
        // should create a new object of cc.Point
        // because developer always use this function like this
        // replaceControlPoint(ccp(x, y))
        // passing controlPoint is a temple object
        this._controlPoints[index] = cc.p(controlPoint.x, controlPoint.y);
    },

    /**
     * get the value of a controlPoint at a given index
     * @param {Number} index
     * @return {cc.Point}
     */
    getControlPointAtIndex:function (index) {
        if (!this._controlPoints) {
            return null;
        }
        index = index < 0 ? 0 : index;
        index = index > this._controlPoints.length - 1 ? this._controlPoints.length - 1 : index;
        return this._controlPoints[index];
    },

    /**
     * deletes a control point at a given index
     * @param {Number} index
     */
    removeControlPointAtIndex:function (index) {
        cc.ArrayRemoveObjectAtIndex(this._controlPoints, index);
    },

    /**
     * returns the number of objects of the control point array
     * @return {Number}
     */
    count:function () {
        return this._controlPoints.length;
    },

    /**
     * returns a new copy of the array reversed. User is responsible for releasing this copy
     * @return {cc.PointArray}
     */
    reverse:function () {
        var newArray = [];
        for (var i = this._controlPoints.length - 1; i >= 0; i--) {
            newArray.push(cc.p(this._controlPoints[i].x, this._controlPoints[i].y));
        }
        var config = new cc.PointArray();
        config.setControlPoints(newArray);
        return config;
    },

    /**
     * reverse the current control point array inline, without generating a new one
     */
    reverseInline:function () {
        var len = this._controlPoints.length;
        var mid = 0 | (len / 2);
        for (var i = 0; i < mid; ++i) {
            var temp = this._controlPoints[i];
            this._controlPoints[i] = this._controlPoints[len - i - 1];
            this._controlPoints[len - i - 1] = temp;
        }
    },

    /**
     * copy a new PointArray
     * @return {cc.PointArray}
     */
    copyWithZone:function () {
        var newArray = [];
        var newPoints = new cc.PointArray();
        for (var i = 0; i < this._controlPoints.length; i++) {
            newArray.push(cc.p(this._controlPoints[i].x, this._controlPoints[i].y));
        }
        newPoints.setControlPoints(newArray);
        return newPoints;
    },

    /**
     * get control points
     * @return {Array}
     */
    getControlPoints:function () {
        return this._controlPoints;
    },

    /**
     * set control points
     * @param {Array} controlPoints
     */
    setControlPoints:function (controlPoints) {
        this._controlPoints = controlPoints;
    }
});

/**
 * creates and initializes a Points array with capacity
 * @function
 * @return {cc.PointArray}
 */
cc.PointArray.create = function () {
    return new cc.PointArray();
};

/**
 * Cardinal Spline path. http://en.wikipedia.org/wiki/Cubic_Hermite_spline#Cardinal_spline
 * @class
 * @extends cc.ActionInterval
 *
 * @example
 * //create a cc.CardinalSplineTo
 * var action1 = cc.CardinalSplineTo.create(3, array, 0);
 */
cc.CardinalSplineTo = cc.ActionInterval.extend(/** @lends cc.CardinalSplineTo# */{
    /** Array of control points */
    _points:null,
    _deltaT:0,
    _tension:0,

    /**
     * Constructor
     */
    ctor:function () {
        this._points = new cc.PointArray();
    },

    /**
     * initializes the action with a duration and an array of points
     * @param {Number} duration
     * @param {cc.PointArray} points
     * @param {Number} tension
     * @return {Boolean}
     */
    initWithDuration:function (duration, points, tension) {
        cc.Assert(points.count() > 0, "Invalid configuration. It must at least have one control point");
        if (this._super(duration)) {
            this.setPoints(points);
            this._tension = tension;
            return true;
        }
        return false;
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super(target);
        this._deltaT = 1 / this._points.count();
    },

    /**
     * @param {Number} time
     */
    update:function (time) {
        var p, lt;

        // border
        if (time == 1) {
            p = this._points.count() - 1;
            lt = 1;
        } else {
            p = 0 | (time / this._deltaT);
            lt = (time - this._deltaT * p) / this._deltaT;
        }

        var newPos = cc.CardinalSplineAt(this._points.getControlPointAtIndex(p - 1), this._points.getControlPointAtIndex(p + 0),
            this._points.getControlPointAtIndex(p + 1), this._points.getControlPointAtIndex(p + 2), this._tension, lt);
        this.updatePosition(newPos);
    },

    /**
     * reverse a new cc.CardinalSplineTo
     * @return {cc.CardinalSplineTo}
     */
    reverse:function () {
        var reversePoints = this._points.reverse();
        return cc.CardinalSplineTo.create(this._duration, reversePoints, this._tension);
    },

    /**
     * update position of target
     * @param {cc.Point} newPos
     */
    updatePosition:function (newPos) {
        this._target.setPosition(newPos);
    },

    /**
     * Points getter
     * @return {cc.PointArray}
     */
    getPoints:function () {
        return this._points;
    },

    /**
     * Points setter
     * @param {cc.PointArray} points
     */
    setPoints:function (points) {
        this._points = points;
    }
});

/**
 * creates an action with a Cardinal Spline array of points and tension
 * @function
 * @param {Number} duration
 * @param {cc.PointArray} points
 * @param {Number} tension
 * @return {cc.CardinalSplineTo}
 *
 * @example
 * //create a cc.CardinalSplineTo
 * var action1 = cc.CardinalSplineTo.create(3, array, 0);
 */
cc.CardinalSplineTo.create = function (duration, points, tension) {
    var ret = new cc.CardinalSplineTo();
    if (ret.initWithDuration(duration, points, tension)) {
        return ret;
    }
    return null;
};

/**
 * Cardinal Spline path.  http://en.wikipedia.org/wiki/Cubic_Hermite_spline#Cardinal_spline
 * @class
 * @extends cc.CardinalSplineTo
 *
 * @example
 * //create a cc.CardinalSplineBy
 * var action1 = cc.CardinalSplineBy.create(3, array, 0);
 */
cc.CardinalSplineBy = cc.CardinalSplineTo.extend(/** @lends cc.CardinalSplineBy# */{
    _startPosition:null,

    /**
     * Constructor
     */
    ctor:function () {
        this._startPosition = cc.p(0, 0);
    },

    /**
     * @param {cc.Node} target
     */
    startWithTarget:function (target) {
        this._super(target);
        this._startPosition = target.getPosition();
    },

    /**
     * reverse a new cc.CardinalSplineBy
     * @return {cc.CardinalSplineBy}
     */
    reverse:function () {
        var copyConfig = this._points.copyWithZone(null);
        var current;
        //
        // convert "absolutes" to "diffs"
        //
        var p = copyConfig.getControlPointAtIndex(0);
        for (var i = 1; i < copyConfig.count(); ++i) {
            current = copyConfig.getControlPointAtIndex(i);
            var diff = cc.pSub(current, p);
            copyConfig.replaceControlPoint(diff, i);
            p = current;
        }

        // convert to "diffs" to "reverse absolute"
        var reverseArray = copyConfig.reverse();

        // 1st element (which should be 0,0) should be here too
        p = reverseArray.getControlPointAtIndex(reverseArray.count() - 1);
        reverseArray.removeControlPointAtIndex(reverseArray.count() - 1);

        p = cc.pNeg(p);
        reverseArray.insertControlPoint(p, 0);
        for (i = 1; i < reverseArray.count(); ++i) {
            current = reverseArray.getControlPointAtIndex(i);
            current = cc.pNeg(current);
            var abs = cc.pAdd(current, p);
            reverseArray.replaceControlPoint(abs, i);
            p = abs;
        }
        return cc.CardinalSplineBy.create(this._duration, reverseArray, this._tension);
    },

    /**
     * update position of target
     * @param {cc.Point} newPos
     */
    updatePosition:function (newPos) {
        this._target.setPosition(cc.pAdd(newPos, this._startPosition));
    }
});

/**
 * creates an action with a Cardinal Spline array of points and tension
 * @function
 * @param {Number} duration
 * @param {cc.PointArray} points
 * @param {Number} tension
 * @return {cc.CardinalSplineBy}
 */
cc.CardinalSplineBy.create = function (duration, points, tension) {
    var ret = new cc.CardinalSplineBy();
    if (ret.initWithDuration(duration, points, tension))
        return ret;
    return null;
};

/**
 * <p>
 *   An action that moves the target with a CatmullRom curve to a destination point.<br/>
 *   A Catmull Rom is a Cardinal Spline with a tension of 0.5.  <br/>
 *   http://en.wikipedia.org/wiki/Cubic_Hermite_spline#Catmull.E2.80.93Rom_spline
 * </p>
 * @class
 * @extends cc.CardinalSplineTo
 *
 * @example
 * var action1 = cc.CatmullRomTo.create(3, array);
 */
cc.CatmullRomTo = cc.CardinalSplineTo.extend(/** @lends cc.CatmullRomTo# */{
    /**
     *  initializes the action with a duration and an array of points
     */
    initWithDuration:function (dt, points) {
        return this._super(dt, points, 0.5);
    }
});

/**
 * creates an action with a Cardinal Spline array of points and tension
 * @param {Number} dt
 * @param {cc.PointArray} points
 * @return {cc.CatmullRomTo}
 *
 * @example
 * var action1 = cc.CatmullRomTo.create(3, array);
 */
cc.CatmullRomTo.create = function (dt, points) {
    var ret = new cc.CatmullRomTo();
    if (ret.initWithDuration(dt, points))
        return ret;
    return null;
};

/**
 * <p>
 *   An action that moves the target with a CatmullRom curve by a certain distance.  <br/>
 *   A Catmull Rom is a Cardinal Spline with a tension of 0.5.<br/>
 *   http://en.wikipedia.org/wiki/Cubic_Hermite_spline#Catmull.E2.80.93Rom_spline
 * </p>
 * @class
 * @extends cc.CardinalSplineBy
 *
 * @example
 * var action1 = cc.CatmullRomBy.create(3, array);
 */
cc.CatmullRomBy = cc.CardinalSplineBy.extend({
    /** initializes the action with a duration and an array of points */
    initWithDuration:function (dt, points) {
        return this._super(dt, points, 0.5);
    }
});

/**
 * creates an action with a Cardinal Spline array of points and tension
 *
 * @example
 * var action1 = cc.CatmullRomBy.create(3, array);
 */
cc.CatmullRomBy.create = function (dt, points) {
    var ret = new cc.CatmullRomBy();
    if (ret.initWithDuration(dt, points))
        return ret;
    return null;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/


/**
 * <p>cc.Scene is a subclass of cc.Node that is used only as an abstract concept.</p>
 *  <p>cc.Scene an cc.Node are almost identical with the difference that cc.Scene has it's
 * anchor point (by default) at the center of the screen.</p>
 *
 * <p>For the moment cc.Scene has no other logic than that, but in future releases it might have
 * additional logic.</p>
 *
 * <p>It is a good practice to use and cc.Scene as the parent of all your nodes.</p>
 * @class
 * @extends cc.Node
 */
cc.Scene = cc.Node.extend(/** @lends cc.Scene# */{
    /**
     * Constructor
     */
    ctor:function () {
        this._super();
        this._ignoreAnchorPointForPosition = true;
        this.setAnchorPoint(cc.p(0.5, 0.5));

        this.setContentSize(cc.Director.getInstance().getWinSize());
    },

    /**
     * Initialize
     * @return {Boolean}
     */
    init:function () {
        this.setContentSize(cc.Director.getInstance().getWinSize());
        return true;
    }
});
/**
 * creates a scene
 * @return {cc.Scene}
 * @example
 * // Example
 * var aScene = cc.Scene.create();
 * //OR
 * var aScene = new cc.Scene();
 */
cc.Scene.create = function () {
    return new cc.Scene();
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/** cc.Layer is a subclass of cc.Node that implements the TouchEventsDelegate protocol.<br/>
 * All features from cc.Node are valid, plus the following new features:<br/>
 * It can receive iPhone Touches<br/>
 * It can receive Accelerometer input
 * @class
 * @extends cc.Node
 */
cc.Layer = cc.Node.extend(/** @lends cc.Layer# */{
    _isTouchEnabled:false,
    _isAccelerometerEnabled:false,
    _isKeyboardEnabled:false,

    /**
     * Constructor
     * @return {Boolean} return false if director fails
     */
    ctor:function () {
        this._super();
        this.setAnchorPoint(cc.p(0.5, 0.5));
        this._ignoreAnchorPointForPosition = true;

        //this.initLayer();
        var director = cc.Director.getInstance();
        this.setContentSize(director.getWinSize());
        this._isTouchEnabled = false;
        this._isAccelerometerEnabled = false;
    },

    /**
     *
     * @return {Boolean}
     */
    init:function () {
        /*var director = cc.Director.getInstance();
         if (!director) {
         return false;
         }
         this.setContentSize(director.getWinSize());
         this._isTouchEnabled = false;*/

        // success
        return true;
    },

    /**
     * If isTouchEnabled, this method is called onEnter. Override it to change the<br/>
     * way CCLayer receives touch events.<br/>
     */
    registerWithTouchDispatcher:function () {
        cc.Director.getInstance().getTouchDispatcher().addStandardDelegate(this, 0);
    },

    /**
     * whether or not it will receive Touch events.<br/>
     * You can enable / disable touch events with this property.<br/>
     * Only the touches of this node will be affected. This "method" is not propagated to it's children.<br/>
     * @return {Boolean}
     */
    isTouchEnabled:function () {
        return this._isTouchEnabled;
    },

    /**
     * Enable touch events
     * @param {Boolean} enabled
     */
    setTouchEnabled:function (enabled) {
        if (this._isTouchEnabled != enabled) {
            this._isTouchEnabled = enabled;

            if (this._isRunning) {
                if (enabled) {
                    this.registerWithTouchDispatcher();
                } else {
                    // have problems?
                    cc.Director.getInstance().getTouchDispatcher().removeDelegate(this);
                }
            }
        }
    },

    /**
     * whether or not it will receive Accelerometer events<br/>
     * You can enable / disable accelerometer events with this property.
     * @return {Boolean}
     */
    isAccelerometerEnabled:function () {
        return this._isAccelerometerEnabled;
    },

    /**
     * isAccelerometerEnabled setter
     * @param enabled
     */
    setAccelerometerEnabled:function (enabled) {
        if (enabled != this._isAccelerometerEnabled) {
            this._isAccelerometerEnabled = enabled;

            if (this._isRunning) {
                var director = cc.Director.getInstance();
                if (enabled) {
                    director.getAccelerometer().setDelegate(this);
                } else {
                    director.getAccelerometer().setDelegate(null);
                }
            }
        }
    },

    /**
     * whether or not it will receive keyboard events<br/>
     * You can enable / disable accelerometer events with this property.<br/>
     * it's new in cocos2d-x
     * @return {Boolean}
     */
    isKeyboardEnabled:function () {
        return this._isKeyboardEnabled;
    },

    /**
     * Enable Keyboard interaction
     * @param {Boolean} enabled
     */
    setKeyboardEnabled:function (enabled) {
        if (enabled != this._isKeyboardEnabled) {
            this._isKeyboardEnabled = enabled;
            if (this._isRunning) {
                var director = cc.Director.getInstance();
                if (enabled) {
                    director.getKeyboardDispatcher().addDelegate(this);
                } else {
                    director.getKeyboardDispatcher().removeDelegate(this);
                }
            }
        }
    },

    /**
     * This is run when ever a layer just become visible
     */
    onEnter:function () {
        var director = cc.Director.getInstance();
        // register 'parent' nodes first
        // since events are propagated in reverse order
        if (this._isTouchEnabled) {
            this.registerWithTouchDispatcher();
        }

        // then iterate over all the children
        this._super();

        // add this layer to concern the Accelerometer Sensor
        if (this._isAccelerometerEnabled) {
            director.getAccelerometer().setDelegate(this);
        }

        // add this layer to concern the kaypad msg
        if (this._isKeyboardEnabled) {
            director.getKeyboardDispatcher().addDelegate(this);
        }
    },

    /**
     * @function
     */
    onExit:function () {
        var director = cc.Director.getInstance();
        if (this._isTouchEnabled) {
            director.getTouchDispatcher().removeDelegate(this);
        }

        // remove this layer from the delegates who concern Accelerometer Sensor
        if (this._isAccelerometerEnabled) {
            director.getAccelerometer().setDelegate(null);
        }

        // remove this layer from the delegates who concern the kaypad msg
        if (this._isKeyboardEnabled) {
            director.getKeyboardDispatcher().removeDelegate(this);
        }

        this._super();
    },

    /**
     * this is called when ever a layer is a child of a scene that just finished a transition
     */
    onEnterTransitionDidFinish:function () {
        if (this._isAccelerometerEnabled) {
            cc.Director.getInstance().getAccelerometer().setDelegate(this);
        }
        this._super();
    },

    /**
     * default implements are used to call script callback if exist<br/>
     * you must override these touch functions if you wish to utilize them
     * @param {cc.Touch} touch
     * @param {event} event
     * @return {Boolean}
     */
    onTouchBegan:function (touch, event) {
        cc.Assert(false, "Layer#onTouchBegan override me");
        return true;
    },

    /**
     * callback when a touch event moved
     * @param {cc.Touch} touch
     * @param {event} event
     */
    onTouchMoved:function (touch, event) {
    },

    /**
     * callback when a touch event finished
     * @param {cc.Touch} touch
     * @param {event} event
     */
    onTouchEnded:function (touch, event) {
    },

    /**
     * @param {cc.Touch} touch
     * @param {event} event
     */
    onTouchCancelled:function (touch, event) {
    },

    /**
     * Touches is the same as Touch, except this one can handle multi-touch
     * @param {cc.Touch} touch
     * @param {event} event
     */
    onTouchesBegan:function (touch, event) {
    },

    /**
     * when a touch moved
     * @param {cc.Touch} touch
     * @param {event} event
     */
    onTouchesMoved:function (touch, event) {
    },

    /**
     * when a touch finished
     * @param {cc.Touch} touch
     * @param {event} event
     */
    onTouchesEnded:function (touch, event) {
    },

    /**
     * @param touch
     * @param event
     */
    onTouchesCancelled:function (touch, event) {
    },

    didAccelerate:function (pAccelerationValue) {
    }
});

/**
 * creates a layer
 * @example
 * // Example
 * var myLayer = cc.Layer.create();
 * //Yes! it's that simple
 * @return {cc.Layer|Null}
 */
cc.Layer.create = function () {
    var ret = new cc.Layer();
    if (ret && ret.init()) {
        return ret;
    }
    return null;
};


/**
 * CCLayerColor is a subclass of CCLayer that implements the CCRGBAProtocol protocol.<br/>
 *  All features from CCLayer are valid, plus the following new features:<br/>
 * <ul><li>opacity</li>
 * <li>RGB colors</li></ul>
 * @class
 * @extends cc.Layer
 */
cc.LayerColor = cc.Layer.extend(/** @lends cc.LayerColor# */{
    RGBAProtocol:true,
    _squareVertices:[],
    _squareColors:[],
    _opacity:0,
    _color:new cc.Color3B(255, 255, 255),
    _blendFunc:new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST),

    /**
     * Constructor
     */
    ctor:function () {
        this._squareVertices = [new cc.Vertex2F(0, 0), new cc.Vertex2F(0, 0), new cc.Vertex2F(0, 0), new cc.Vertex2F(0, 0)];
        this._squareColors = [new cc.Color4F(0, 0, 0, 1), new cc.Color4F(0, 0, 0, 1), new cc.Color4F(0, 0, 0, 1), new cc.Color4F(0, 0, 0, 1)];
        this._color = new cc.Color4B(0, 0, 0, 0);
        this._super();
    },

    /**
     * opacity getter
     * @return {Number}
     */
    getOpacity:function () {
        return this._opacity;
    },

    /**
     * opacity setter
     * @param {Number} Var a number between 0 and 255, 0 is totally transparent
     */
    setOpacity:function (Var) {
        this._opacity = Var;
        this._updateColor();

        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());
        this.setNodeDirty();
    },

    /**
     * color getter
     * @return {cc.Color3B}
     */
    getColor:function () {
        return this._color;
    },

    /**
     * color setter
     * @param {cc.Color3B} Var
     */
    setColor:function (Var) {
        this._color = Var;
        this._updateColor();

        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());
        this.setNodeDirty();
    },

    /**
     * blendFunc getter
     * @return {cc.BlendFunc}
     */
    getBlendFunc:function () {
        return this._blendFunc;
    },

    /**
     * blendFunc setter
     * @param {Number} src
     * @param {Number} dst
    */
    setBlendFunc:function (src, dst) {
        this._blendFunc = {src:src, dst:dst};
    },

    /**
     * @param color
     * @return {Boolean}
     */
    initWithColor:function (color, width, height) {
        var winSize = cc.Director.getInstance().getWinSize();

        width = width || winSize.width;
        height = height || winSize.height;

        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;

        this._color = new cc.Color3B(color.r, color.g, color.b);
        this._opacity = color.a;

        for (var i = 0; i < this._squareVertices.length; i++) {
            this._squareVertices[i].x = 0.0;
            this._squareVertices[i].y = 0.0;
        }
        this._updateColor();

        this.setContentSize(cc.size(width, height));
        //this.setShaderProgram(cc.ShaderCache.getInstance().programForKey(kCCShader_PositionColor));

        return true;
    },

    /**
     * override contentSize
     * @param {cc.Size} size
     */
    setContentSize:function (size) {
        this._squareVertices[1].x = size.width;
        this._squareVertices[2].y = size.height;
        this._squareVertices[3].x = size.width;
        this._squareVertices[3].y = size.height;
        this._super(size);
    },

    /**
     * change width and height in Points
     * @param {Number} w width
     * @param {Number} h height
     */
    changeWidthAndHeight:function (w, h) {
        this.setContentSize(cc.size(w, h));
    },

    /**
     * change width in Points
     * @param {Number} w width
     */
    changeWidth:function (w) {
        this.setContentSize(cc.size(w, this._contentSize.height));
    },

    /**
     * change height in Points
     * @param {Number} h height
     */
    changeHeight:function (h) {
        this.setContentSize(cc.size(this._contentSize.width, h));
    },

    _updateColor:function () {
        for (var i = 0; i < 4; i++) {
            this._squareColors[i].r = this._color.r / 255;
            this._squareColors[i].g = this._color.g / 255;
            this._squareColors[i].b = this._color.b / 255;
            this._squareColors[i].a = this._opacity / 255;
        }
    },

    /**
     * set OpacityModifyRGB of cc.LayerColor
     * @param {Boolean}  value
     */
    setOpacityModifyRGB:function (value) {
    },

    /**
     * is OpacityModifyRGB
     * @return {Boolean}
     */
    isOpacityModifyRGB:function () {
        return false;
    },

    /**
     * renders the layer
     * @param {CanvasContext|Null} ctx
     */
    draw:function (ctx) {
        var context = ctx || cc.renderContext;

        if (cc.renderContextType == cc.CANVAS) {
            //context.globalAlpha = this.getOpacity() / 255;
            var tWidth = this.getContentSize().width;
            var tHeight = this.getContentSize().height;
            var apip = this.getAnchorPointInPoints();
            var tGradient = context.createLinearGradient(-apip.x, apip.y,
                -apip.x + tWidth, -(apip.y + tHeight));

            tGradient.addColorStop(0, "rgba(" + Math.round(this._squareColors[0].r * 255) + "," + Math.round(this._squareColors[0].g * 255) + ","
                + Math.round(this._squareColors[0].b * 255) + "," + this._squareColors[0].a.toFixed(4) + ")");
            tGradient.addColorStop(1, "rgba(" + Math.round(this._squareColors[3].r * 255) + "," + Math.round(this._squareColors[3].g * 255) + ","
                + Math.round(this._squareColors[3].b * 255) + "," + this._squareColors[3].a.toFixed(4) + ")");

            context.fillStyle = tGradient;
            context.fillRect(-apip.x, apip.y, tWidth, -tHeight);
        } else {
            /*cc.NODE_DRAW_SETUP();
             ccGLEnableVertexAttribs( kCCVertexAttribFlag_Position | kCCVertexAttribFlag_Color );

             //
             // Attributes
             //
             glVertexAttribPointer(kCCVertexAttrib_Position, 2, GL_FLOAT, GL_FALSE, 0, m_pSquareVertices);
             glVertexAttribPointer(kCCVertexAttrib_Color, 4, GL_FLOAT, GL_FALSE, 0, m_pSquareColors);
             ccGLBlendFunc( m_tBlendFunc.src, m_tBlendFunc.dst );
             glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);   */
        }
        this._super(context);

        cc.INCREMENT_GL_DRAWS(1);
    }
});

/**
 * creates a cc.Layer with color, width and height in Points
 * @param {cc.Color4B} color
 * @param {Number|Null} width
 * @param {Number|Null} height
 * @return {cc.LayerColor}
 * @example
 * // Example
 * //Create a yellow color layer as background
 * var yellowBackground = cc.LayerColor.create(cc.c4b(255,255,0,255));
 * //If you didnt pass in width and height, it defaults to the same size as the canvas
 *
 * //create a yellow box, 200 by 200 in size
 * var yellowBox = cc.LayerColor.create(cc.c3b(255,255,0,255), 200, 200);
 */
cc.LayerColor.create = function (color, width, height) {
    var ret = new cc.LayerColor();
    switch (arguments.length) {
        case 0:
            ret.init();
            break;
        case 1:
            ret.initWithColor(color);
            break;
        case 3:
            ret.initWithColor(color, width, height);
            break;
        default :
            ret.init();
            break;
    }
    return ret;
};


/**
 * CCLayerGradient is a subclass of cc.LayerColor that draws gradients across<br/>
 * the background.<br/>
 *<br/>
 * All features from cc.LayerColor are valid, plus the following new features:<br/>
 * <ul><li>direction</li>
 * <li>final color</li>
 * <li>interpolation mode</li></ul>
 * <br/>
 * Color is interpolated between the startColor and endColor along the given<br/>
 * vector (starting at the origin, ending at the terminus).  If no vector is<br/>
 * supplied, it defaults to (0, -1) -- a fade from top to bottom.<br/>
 * <br/>
 * If 'compressedInterpolation' is disabled, you will not see either the start or end color for<br/>
 * non-cardinal vectors; a smooth gradient implying both end points will be still<br/>
 * be drawn, however.<br/>
 *<br/>
 * If ' compressedInterpolation' is enabled (default mode) you will see both the start and end colors of the gradient.
 * @class
 * @extends cc.LayerColor
 */
cc.LayerGradient = cc.LayerColor.extend(/** @lends cc.LayerGradient# */{
    _startColor:new cc.Color3B(0, 0, 0),
    _endColor:new cc.Color3B(0, 0, 0),
    _startOpacity:null,
    _endOpacity:null,
    _alongVector:null,
    _compressedInterpolation:false,

    /**
     * Constructor
     * @function
     */
    ctor:function () {
        this._startColor = new cc.Color3B(0, 0, 0);
        this._endColor = new cc.Color3B(0, 0, 0);
        this._super();
    },

    /**
     * get the starting color
     * @return {cc.Color3B}
     */
    getStartColor:function () {
        return this._color;
    },

    /**
     * set the starting color
     * @param {cc.Color3B} color
     * @example
     * // Example
     * myGradientLayer.setStartColor(cc.c3b(255,0,0));
     * //set the starting gradient to red
     */
    setStartColor:function (color) {
        this.setColor(color);
    },

    /**
     * set the end gradient color
     * @param {cc.Color3B} color
     * @example
     * // Example
     * myGradientLayer.setEndColor(cc.c3b(255,0,0));
     * //set the ending gradient to red
     */
    setEndColor:function (color) {
        this._endColor = color;
        this._updateColor();
    },

    /**
     * get the end color
     * @return {cc.Color3B}
     */
    getEndColor:function () {
        return this._endColor;
    },

    /**
     * set starting gradient opacity
     * @param {Number} o from 0 to 255, 0 is transparent
     */
    setStartOpacity:function (o) {
        this._startOpacity = o;
        this._updateColor();
    },

    /**
     * get the starting gradient opacity
     * @return {Number}
     */
    getStartOpacity:function () {
        return this._startOpacity;
    },

    /**
     * set the end gradient opacity
     * @param {Number} o
     */
    setEndOpacity:function (o) {
        this._endOpacity = o;
        this._updateColor();
    },

    /**
     * get the end gradient opacity
     * @return {Number}
     */
    getEndOpacity:function () {
        return this._endOpacity;
    },

    /**
     * set vector
     * @param {cc.Point} Var
     */
    setVector:function (Var) {
        this.alongVector = Var;
        this._updateColor();
    },

    /**
     * @return {cc.Point}
     */
    getVector:function () {
        return this.alongVector;
    },

    /** is Compressed Interpolation
     * @return {Boolean}
     */
    isCompressedInterpolation:function () {
        return this._compressedInterpolation;
    },

    /**
     * @param {Boolean} compress
     */
    setCompressedInterpolation:function (compress) {
        this._compressedInterpolation = compress;
        this._updateColor();
    },

    /**
     * @param {cc.Color3B} start starting color
     * @param {cc.Color3B} end
     * @param {cc.Point|Null} v
     * @return {Boolean}
     */
    initWithColor:function (start, end, v) {
        var argnum = arguments.length;
        if (argnum == 2) {
            // Initializes the CCLayer with a gradient between start and end.
            v = cc.p(0, -1);
        }

        // Initializes the CCLayer with a gradient between start and end in the direction of v.
        this._startColor.r = start.r;
        this._startColor.g = start.g;
        this._startColor.b = start.b;
        this._startOpacity = start.a;

        this._endColor.r = end.r;
        this._endColor.g = end.g;
        this._endColor.b = end.b;
        this._endOpacity = end.a;

        this.alongVector = v;

        this._compressedInterpolation = true;

        return this._super(cc.c4b(start.r, start.g, start.b, 255));
    },

    _updateColor:function () {
        //todo need fixed for webGL
        this._super();
        /*
         this._squareColors[0].r = Math.round(this._startColor.r);
         this._squareColors[0].g = Math.round(this._startColor.g);
         this._squareColors[0].b = Math.round(this._startColor.b);
         this._squareColors[0].a = Math.round(this._startColor.a);

         this._squareColors[3].r = Math.round(this._endColor.r);
         this._squareColors[3].g = Math.round(this._endColor.g);
         this._squareColors[3].b = Math.round(this._endColor.b);
         this._squareColors[3].a = Math.round(this._endColor.a);
         return;
         */


        var h = cc.pLength(this.alongVector);
        if (h == 0)
            return;

        var c = Math.sqrt(2.0);
        var u = cc.p(this.alongVector.x / h, this.alongVector.y / h);

        // Compressed Interpolation mode
        if (this._compressedInterpolation) {
            var h2 = 1 / ( Math.abs(u.x) + Math.abs(u.y) );
            u = cc.pMult(u, h2 * c);
        }

        var opacityf = this._opacity / 255.0;

        var S = new cc.Color4F(this._startColor.r / 255, this._startColor.g / 255, this._startColor.b / 255, (this._startOpacity * opacityf) / 255);

        var E = new cc.Color4F(this._endColor.r / 255, this._endColor.g / 255, this._endColor.b / 255, (this._endOpacity * opacityf) / 255);

        // (-1, -1)
        this._squareColors[0].r = parseInt((E.r + (S.r - E.r) * ((c + u.x + u.y) / (2.0 * c))));
        this._squareColors[0].g = parseInt((E.g + (S.g - E.g) * ((c + u.x + u.y) / (2.0 * c))));
        this._squareColors[0].b = parseInt((E.b + (S.b - E.b) * ((c + u.x + u.y) / (2.0 * c))));
        this._squareColors[0].a = parseInt((E.a + (S.a - E.a) * ((c + u.x + u.y) / (2.0 * c))));
        // (1, -1)
        this._squareColors[1].r = parseInt((E.r + (S.r - E.r) * ((c - u.x + u.y) / (2.0 * c))));
        this._squareColors[1].g = parseInt((E.g + (S.g - E.g) * ((c - u.x + u.y) / (2.0 * c))));
        this._squareColors[1].b = parseInt((E.b + (S.b - E.b) * ((c - u.x + u.y) / (2.0 * c))));
        this._squareColors[1].a = parseInt((E.a + (S.a - E.a) * ((c - u.x + u.y) / (2.0 * c))));
        // (-1, 1)
        this._squareColors[2].r = parseInt((E.r + (S.r - E.r) * ((c + u.x - u.y) / (2.0 * c))));
        this._squareColors[2].g = parseInt((E.g + (S.g - E.g) * ((c + u.x - u.y) / (2.0 * c))));
        this._squareColors[2].b = parseInt((E.b + (S.b - E.b) * ((c + u.x - u.y) / (2.0 * c))));
        this._squareColors[2].a = parseInt((E.a + (S.a - E.a) * ((c + u.x - u.y) / (2.0 * c))));
        // (1, 1)
        this._squareColors[3].r = parseInt((E.r + (S.r - E.r) * ((c - u.x - u.y) / (2.0 * c))));
        this._squareColors[3].g = parseInt((E.g + (S.g - E.g) * ((c - u.x - u.y) / (2.0 * c))));
        this._squareColors[3].b = parseInt((E.b + (S.b - E.b) * ((c - u.x - u.y) / (2.0 * c))));
        this._squareColors[3].a = parseInt((E.a + (S.a - E.a) * ((c - u.x - u.y) / (2.0 * c))));
    }
});

/**
 * creates a gradient layer
 * @param {cc.Color3B} start starting color
 * @param {cc.Color3B} end ending color
 * @param {cc.Point|Null} v
 * @return {cc.LayerGradient}
 */
cc.LayerGradient.create = function (start, end, v) {
    var layer = new cc.LayerGradient();
    switch (arguments.length) {
        case 2:
            /** Creates a full-screen CCLayer with a gradient between start and end. */
            if (layer && layer.initWithColor(start, end)) {
                return layer;
            }
            break;
        case 3:
            /** Creates a full-screen CCLayer with a gradient between start and end in the direction of v. */
            if (layer && layer.initWithColor(start, end, v)) {
                return layer;
            }
            break;
        case 0:
            layer.init();
            break;
        default:
            throw "Arguments error ";
            break;
    }
    return null;
};


/**
 * CCMultipleLayer is a CCLayer with the ability to multiplex it's children.<br/>
 * Features:<br/>
 *  <ul><li>- It supports one or more children</li>
 *  <li>- Only one children will be active a time</li></ul>
 *  @class
 *  @extends cc.Layer
 */
cc.LayerMultiplex = cc.Layer.extend(/** @lends cc.LayerMultiplex# */{
    _enabledLayer:0,
    _layers:null,

    /**
     * Constructor
     */
    ctor:function () {
        this._super();
    },

    /**
     * @param {cc.Layer} layer
     * @deprecated merged with initWithLayers
     * @return {Boolean}
     */
    initWithLayer:function (layer) {
        this._layers = [];
        this._layers.push(layer);
        this._enabledLayer = 0;
        this.addChild(layer);
        return true;
    },

    /**
     * @param {Array} args an array of cc.Layer
     * @return {Boolean}
     */
    initWithLayers:function (args) {
        this._layers = args;
        this._enabledLayer = 0;
        this.addChild(this._layers[this._enabledLayer]);
        return true;
    },

    /**
     * switches to a certain layer indexed by n.<br/>
     * The current (old) layer will be removed from it's parent with 'cleanup:YES'.
     * @param {Number} n the layer index to switch to
     */
    switchTo:function (n) {
        cc.Assert(n < this._layers.length, "Invalid index in MultiplexLayer switchTo message");

        this.removeChild(this._layers[this._enabledLayer], true);

        this._enabledLayer = n;

        this.addChild(this._layers[n]);
    },

    /** release the current layer and switches to another layer indexed by n.<br/>
     * The current (old) layer will be removed from it's parent with 'cleanup:YES'.
     * @param {Number} n the layer index to switch to
     */
    switchToAndReleaseMe:function (n) {
        cc.Assert(n < this._layers.count(), "Invalid index in MultiplexLayer switchTo message");

        this.removeChild(this._layers[this._enabledLayer], true);

        //[layers replaceObjectAtIndex:_enabledLayer withObject:[NSNull null]];
        this._layers[this._enabledLayer] = null;

        this._enabledLayer = n;

        this.addChild(this._layers[n]);
    },

    /**
     * @param {cc.Layer} layer
     */
    addLayer:function (layer) {
        cc.Assert(this._layers, "cc.Layer addLayer");
        this._layers.push(layer);
    }
});


/**
 * creates a cc.LayerMultiplex with one or more layers using a variable argument list.
 * @return {cc.LayerMultiplex|Null}
 * @example
 * // Example
 * var multiLayer = cc.LayerMultiple.create(layer1, layer2, layer3);//any number of layers
 */
cc.LayerMultiplex.create = function (/*Multiple Arguments*/) {
    var multiplexLayer = new cc.LayerMultiplex();
    if (multiplexLayer.initWithLayers(arguments)) {
        return multiplexLayer;
    }
    return null;
};


/**
 * a layer that does not get redraw if not needed, and its always gets placed on the bottom layer
 * @class
 * @extends cc.Node
 * @example
 * // Example
 * var veryLazy = new cc.LazyLayer();
 * veryLazy.addChild(mySprite);
 */
cc.LazyLayer = cc.Node.extend(/** @lends cc.LazyLayer# */{
    _layerCanvas:null,
    _layerContext:null,
    _isNeedUpdate:false,
    _canvasZOrder:-10,
    _layerId:"",

    /**
     * Constructor
     */
    ctor:function () {
        this._super();
        this.setAnchorPoint(cc.p(0, 0));
        //setup html
        this._setupHtml();
    },

    /**
     * @param {Number} zOrder
     */
    setLayerZOrder:function (zOrder) {
        if (zOrder >= 0) {
            throw "LazyLayer zOrder must Less than Zero.Because LazyLayer is a background Layer!";
        }
        this._canvasZOrder = zOrder;
        this._layerCanvas.style.zIndex = this._canvasZOrder;
    },

    /**
     *
     * @return {Number}
     */
    getLayerZOrder:function () {
        return this._canvasZOrder;
    },

    _setupHtml:function () {
        this._layerCanvas = document.createElement("canvas");
        this._layerCanvas.width = cc.canvas.width;
        this._layerCanvas.height = cc.canvas.height;
        this._layerId = "lazyCanvas" + Date.now();
        this._layerCanvas.id = this._layerId;
        this._layerCanvas.style.zIndex = this._canvasZOrder;
        this._layerCanvas.style.position = "absolute";
        this._layerCanvas.style.top = "0";
        this._layerCanvas.style.left = "0";
        this._layerContext = this._layerCanvas.getContext("2d");
        this._layerContext.fillStyle = "rgba(0,0,0,1)";
        this._layerContext.translate(0, this._layerCanvas.height);
        cc.container.appendChild(this._layerCanvas);
        var selfPointer = this;
        window.addEventListener("resize", function (event) {
            selfPointer.adjustSizeForCanvas();
        });
    },

    /**
     * make it the same size as canvas, in case canvas resized
     */
    adjustSizeForCanvas:function () {
        this._isNeedUpdate = true;
        this._layerCanvas.width = cc.canvas.width;
        this._layerCanvas.height = cc.canvas.height;
        var xScale = cc.canvas.width / cc.originalCanvasSize.width;
        var yScale = cc.canvas.height / cc.originalCanvasSize.height;
        if (xScale > yScale) {
            xScale = yScale;
        }
        this._layerContext.translate(0, this._layerCanvas.height);
        this._layerContext.scale(xScale, xScale);
    },

    /**
     * return lazylayer's canvas
     * @return {HTMLCanvasElement}
     */
    getLayerCanvas:function () {
        return this._layerCanvas;
    },

    /**
     * same as cc.Node
     * @param {cc.Node} child
     * @param {Number|Null} zOrder
     * @param {Number|Null} tag
     */
    addChild:function (child, zOrder, tag) {
        this._isNeedUpdate = true;
        this._super(child, zOrder, tag);
    },

    /**
     * @param {cc.Node} child
     * @param {Boolean} cleanup
     */
    removeChild:function (child, cleanup) {
        this._isNeedUpdate = true;
        this._super(child, cleanup);
    },

    /**
     * stuff gets drawn in here
     */
    visit:function () {
        // quick return if not visible
        if (!this._isVisible) {
            return;
        }
        if (!this._isNeedUpdate) {
            return;
        }

        this._isNeedUpdate = false;
        var context = this._layerContext;
        context.save();
        context.clearRect(0, 0, this._layerCanvas.width, -this._layerCanvas.height);

        if (this._children && this._children.length > 0) {
            this.sortAllChildren();
            // draw children zOrder < 0
            for (var i = 0; i < this._children.length; i++) {
                this._children[i].visit(context);
            }
        }

        context.restore();
    },

    /**
     * override onExit of cc.Node
     * @override
     */
    onExit:function () {
        this._super();

        //clear canvas element from parent element
        if (this._layerCanvas.parentNode) {
            this._layerCanvas.parentNode.removeChild(this._layerCanvas);
        }
    },

    _setNodeDirtyForCache:function () {
        this._isCacheDirty = true;
        this._isNeedUpdate = true;
    }
});
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
/**
 * A tag constant for identifying fade scenes
 * @constant
 * @type Number
 */
cc.SCENE_FADE = 4208917214;

/**
 * cc.TransitionEaseScene can ease the actions of the scene protocol.
 * @class
 * @extends cc.Class
 */
cc.TransitionEaseScene = cc.Class.extend(/** @lends cc.TransitionEaseScene# */{
    /**
     * returns the Ease action that will be performed on a linear action.
     */
    easeActionWithAction:function () {
    }
});

/**
 * horizontal orientation Type where the Left is nearer
 * @constant
 * @type Number
 */
cc.ORIENTATION_LEFT_OVER = 0;
/**
 * horizontal orientation type where the Right is nearer
 * @constant
 * @type Number
 */
cc.ORIENTATION_RIGHT_OVER = 1;
/**
 * vertical orientation type where the Up is nearer
 * @constant
 * @type Number
 */
cc.ORIENTATION_UP_OVER = 0;
/**
 * vertical orientation type where the Bottom is nearer
 * @constant
 * @type Number
 */
cc.ORIENTATION_DOWN_OVER = 1;

/**
 * @class
 * @extends cc.Scene
 */
cc.TransitionScene = cc.Scene.extend(/** @lends cc.TransitionScene# */{
    _inScene:null,
    _outScene:null,
    _duration:null,
    _isInSceneOnTop:false,
    _isSendCleanupToScene:false,

    //private
    _setNewScene:function (dt) {
        // [self unschedule:_cmd];
        // "_cmd" is a local variable automatically defined in a method
        // that contains the selector for the method
        this.unschedule(this._setNewScene);
        var director = cc.Director.getInstance();
        // Before replacing, save the "send cleanup to scene"
        this._isSendCleanupToScene = director.isSendCleanupToScene();
        director.replaceScene(this._inScene);

        // enable events while transitions
        director.getTouchDispatcher().setDispatchEvents(true);
        // issue #267
        this._outScene.setVisible(true);
    },

    //protected
    _sceneOrder:function () {
        this._isInSceneOnTop = true;
    },

    /**
     * stuff gets drawn here
     */
    draw:function () {
        this._super();

        if (this._isInSceneOnTop) {
            this._outScene.visit();
            this._inScene.visit();
        } else {
            this._inScene.visit();
            this._outScene.visit();
        }
    },

    /**
     * custom onEnter
     */
    onEnter:function () {
        this._super();
        this._inScene.onEnter();
    },

    /**
     * custom onExit
     */
    onExit:function () {
        this._super();
        this._outScene.onExit();

        // inScene should not receive the onExit callback
        // only the onEnterTransitionDidFinish
        this._inScene.onEnterTransitionDidFinish();
    },

    /**
     * custom cleanup
     */
    cleanup:function () {
        this._super();

        if (this._isSendCleanupToScene)
            this._outScene.cleanup();
    },

    /**
     * initializes a transition with duration and incoming scene
     * @param {Number} t time in seconds
     * @param {cc.Scene} scene a scene to transit to
     * @return {Boolean} return false if error
     */
    initWithDuration:function (t, scene) {
        cc.Assert(scene != null, "CCTransitionScene.initWithDuration() Argument scene must be non-nil");

        if (this.init()) {
            this._duration = t;
            this.setAnchorPoint(cc.p(0, 0));
            this.setPosition(cc.p(0, 0));
            // retain
            this._inScene = scene;
            this._outScene = cc.Director.getInstance().getRunningScene();
            if (!this._outScene) {
                this._outScene = cc.Scene.create();
                this._outScene.init();
            }

            cc.Assert(this._inScene != this._outScene, "CCTransitionScene.initWithDuration() Incoming scene must be different from the outgoing scene");

            // disable events while transitions
            cc.Director.getInstance().getTouchDispatcher().setDispatchEvents(false);
            this._sceneOrder();

            return true;
        } else {
            return false;
        }
    },

    /**
     * called after the transition finishes
     */
    finish:function () {
        // clean up
        this._inScene.setVisible(true);
        this._inScene.setPosition(cc.p(0, 0));
        this._inScene.setScale(1.0);
        this._inScene.setRotation(0.0);
        this._inScene.getCamera().restore();

        this._outScene.setVisible(false);
        this._outScene.setPosition(cc.p(0, 0));
        this._outScene.setScale(1.0);
        this._outScene.setRotation(0.0);
        this._outScene.getCamera().restore();

        //[self schedule:@selector(setNewScene:) interval:0];
        this.schedule(this._setNewScene, 0);
    },

    /**
     * set hide the out scene and show in scene
     */
    hideOutShowIn:function () {
        this._inScene.setVisible(true);
        this._outScene.setVisible(false);
    }
});
/**
 * creates a base transition with duration and incoming scene
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene the scene to transit with
 * @return {cc.TransitionScene|Null}
 */
cc.TransitionScene.create = function (t, scene) {
    var tempScene = new cc.TransitionScene();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 * A cc.Transition that supports orientation like.<br/>
 * Possible orientation: LeftOver, RightOver, UpOver, DownOver<br/>
 * useful for when you want to make a transition happen between 2 orientations
 * @class
 * @extends cc.TransitionScene
 */
cc.TransitionSceneOriented = cc.TransitionScene.extend(/** @lends cc.TransitionSceneOriented# */{
    _orientation:0,

    /**
     * initialize the transition
     * @param {Number} t time in seconds
     * @param {cc.Scene} scene
     * @param {cc.ORIENTATION_LEFT_OVER|cc.ORIENTATION_RIGHT_OVER|cc.ORIENTATION_UP_OVER|cc.ORIENTATION_DOWN_OVER} orientation
     * @return {Boolean}
     */
    initWithDuration:function (t, scene, orientation) {
        if (this._super(t, scene)) {
            this._orientation = orientation;
        }
        return true;
    }
});

/**
 * creates a base transition with duration and incoming scene
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @param {cc.ORIENTATION_LEFT_OVER|cc.ORIENTATION_RIGHT_OVER|cc.ORIENTATION_UP_OVER|cc.ORIENTATION_DOWN_OVER} orientation
 * @return {cc.TransitionSceneOriented}
 * @example
 * // Example
 * var goHorizontal = cc.TransitionSceneOriented.create(0.5, thisScene, cc.ORIENTATION_LEFT_OVER)
 */
cc.TransitionSceneOriented.create = function (t, scene, orientation) {
    var tempScene = new cc.TransitionSceneOriented();
    tempScene.initWithDuration(t, scene, orientation);

    return tempScene;
};

/**
 *  Rotate and zoom out the outgoing scene, and then rotate and zoom in the incoming
 * @class
 * @extends cc.TransitionScene
 */
cc.TransitionRotoZoom = cc.TransitionScene.extend(/** @lends cc.TransitionRotoZoom# */{
    /**
     * Constructor
     */
    ctor:function () {
    },

    /**
     * Custom On Enter callback
     * @override
     */
    onEnter:function () {
        this._super();

        this._inScene.setScale(0.001);
        this._outScene.setScale(1.0);

        this._inScene.setAnchorPoint(cc.p(0.5, 0.5));
        this._outScene.setAnchorPoint(cc.p(0.5, 0.5));

        var rotozoom = cc.Sequence.create(
            cc.Spawn.create(cc.ScaleBy.create(this._duration / 2, 0.001),
                cc.RotateBy.create(this._duration / 2, 360 * 2)),
            cc.DelayTime.create(this._duration / 2));

        this._outScene.runAction(rotozoom);
        this._inScene.runAction(
            cc.Sequence.create(rotozoom.reverse(),
                cc.CallFunc.create(this, this.finish)));
    }
});

/**
 * Creates a Transtion rotation and zoom
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene the scene to work with
 * @return {cc.TransitionRotoZoom}
 * @example
 * // Example
 * var RotoZoomTrans = cc.TransitionRotoZoom.create(2, nextScene);
 */
cc.TransitionRotoZoom.create = function (t, scene) {
    var tempScene = new cc.TransitionRotoZoom();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 * Zoom out and jump the outgoing scene, and then jump and zoom in the incoming
 * @class
 * @extends cc.TransitionScene
 */
cc.TransitionJumpZoom = cc.TransitionScene.extend(/** @lends cc.TransitionJumpZoom# */{
    /**
     * Custom on enter
     */
    onEnter:function () {
        this._super();

        var s = cc.Director.getInstance().getWinSize();

        this._inScene.setScale(0.5);
        this._inScene.setPosition(cc.p(s.width, 0));
        this._inScene.setAnchorPoint(cc.p(0.5, 0.5));
        this._outScene.setAnchorPoint(cc.p(0.5, 0.5));

        //TODO
        var jump = cc.JumpBy.create(this._duration / 4, cc.p(-s.width, 0), s.width / 4, 2);
        var scaleIn = cc.ScaleTo.create(this._duration / 4, 1.0);
        var scaleOut = cc.ScaleTo.create(this._duration / 4, 0.5);

        var jumpZoomOut = cc.Sequence.create(scaleOut, jump);
        var jumpZoomIn = cc.Sequence.create(jump, scaleIn);

        var delay = cc.DelayTime.create(this._duration / 2);
        this._outScene.runAction(jumpZoomOut);
        this._inScene.runAction(cc.Sequence.create(delay, jumpZoomIn,
            cc.CallFunc.create(this, this.finish)));
    }
});

/**
 * creates a scene transition that zooms then jump across the screen, the same for the incoming scene
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionJumpZoom}
 */
cc.TransitionJumpZoom.create = function (t, scene) {
    var tempScene = new cc.TransitionJumpZoom();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 * Move in from to the left the incoming scene.
 * @class
 * @extends cc.TransitionScene
 */
cc.TransitionMoveInL = cc.TransitionScene.extend(/** @lends cc.TransitionMoveInL# */{

    /**
     * Custom on enter
     */
    onEnter:function () {
        this._super();
        this.initScenes();

        var a = this.action();

        this._inScene.runAction(
            cc.Sequence.create
                (
                    this.easeActionWithAction(a),
                    cc.CallFunc.create(this, this.finish),
                    null
                )
        );
    },

    /**
     * initializes the scenes
     */
    initScenes:function () {
        this._inScene.setPosition(cc.p(-cc.Director.getInstance().getWinSize().width, 0));
    },

    /**
     * returns the action that will be performed
     */
    action:function () {
        return cc.MoveTo.create(this._duration, cc.p(0, 0));
    },

    /**
     * creates an ease action from action
     * @param {cc.ActionInterval} action
     * @return {cc.EaseOut}
     */
    easeActionWithAction:function (action) {
        //TODO need implement
        return cc.EaseOut.create(action, 2.0);
    }
});

/**
 * creates an action that  Move in from to the left the incoming scene.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionMoveInL}
 * @example
 * // Example
 * var MoveInLeft = cc.TransitionMoveInL.create(1, nextScene)
 */
cc.TransitionMoveInL.create = function (t, scene) {
    var tempScene = new cc.TransitionMoveInL();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 * Move in from to the right the incoming scene.
 * @class
 * @extends cc.TransitionMoveInL
 */
cc.TransitionMoveInR = cc.TransitionMoveInL.extend(/** @lends cc.TransitionMoveInR# */{

    /**
     * Init
     */
    initScenes:function () {
        var s = cc.Director.getInstance().getWinSize();
        this._inScene.setPosition(cc.p(s.width, 0));
    }
});

/**
 * create a scene transition that Move in from to the right the incoming scene.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionMoveInR}
 * @example
 * // Example
 * var MoveInRight = cc.TransitionMoveInR.create(1, nextScene)
 */
cc.TransitionMoveInR.create = function (t, scene) {
    var tempScene = new cc.TransitionMoveInR();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 * Move in from to the top the incoming scene.
 * @class
 * @extends cc.TransitionMoveInL
 */
cc.TransitionMoveInT = cc.TransitionMoveInL.extend(/** @lends cc.TransitionMoveInT# */{

    /**
     * init
     */
    initScenes:function () {
        var s = cc.Director.getInstance().getWinSize();
        this._inScene.setPosition(cc.p(s.height, 0));
    }
});

/**
 * Move in from to the top the incoming scene.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionMoveInT}
 * @example
 * // Example
 * var MoveInTop = cc.TransitionMoveInT.create(1, nextScene)
 */
cc.TransitionMoveInT.create = function (t, scene) {
    var tempScene = new cc.TransitionMoveInT();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 *  Move in from to the bottom the incoming scene.
 * @class
 * @extends cc.TransitionMoveInL
 */
cc.TransitionMoveInB = cc.TransitionMoveInL.extend(/** @lends cc.TransitionMoveInB# */{

    /**
     * init
     */
    initScenes:function () {
        var s = cc.Director.getInstance().getWinSize();
        this._inScene.setPosition(cc.p(0, -s.height));
    }
});

/**
 * create a scene transition that Move in from to the bottom the incoming scene.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionMoveInB}
 * @example
 * // Example
 * var MoveinB = cc.TransitionMoveInB.create(1, nextScene)
 */
cc.TransitionMoveInB.create = function (t, scene) {
    var tempScene = new cc.TransitionMoveInB();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 * The adjust factor is needed to prevent issue #442<br/>
 * One solution is to use DONT_RENDER_IN_SUBPIXELS images, but NO<br/>
 * The other issue is that in some transitions (and I don't know why)<br/>
 * the order should be reversed (In in top of Out or vice-versa).
 * @constant
 * @type Number
 */
cc.ADJUST_FACTOR = 0.5;

/**
 * a transition that a new scene is slided from left
 * @class
 * @extends cc.TransitionScene
 */
cc.TransitionSlideInL = cc.TransitionScene.extend(/** @lends cc.TransitionSlideInL# */{
    _sceneOrder:function () {
        this._isInSceneOnTop = false;
    },

    /**
     * Constructor
     */
    ctor:function () {
    },

    /**
     * custom on enter
     */
    onEnter:function () {
        this._super();
        this.initScenes();

        var inA = this.action();
        var outA = this.action();

        var inAction = this.easeActionWithAction(inA);
        var outAction = cc.Sequence.create
            (
                this.easeActionWithAction(outA),
                cc.CallFunc.create(this, this.finish),
                null
            );
        this._inScene.runAction(inAction);
        this._outScene.runAction(outAction);
    },

    /**
     * initializes the scenes
     */
    initScenes:function () {
        var s = cc.Director.getInstance().getWinSize();
        this._inScene.setPosition(cc.p(-(s.width - cc.ADJUST_FACTOR), 0));
    },
    /**
     * returns the action that will be performed by the incomming and outgoing scene
     * @return {cc.MoveBy}
     */
    action:function () {
        var s = cc.Director.getInstance().getWinSize();
        return cc.MoveBy.create(this._duration, cc.p(s.width - cc.ADJUST_FACTOR, 0));
    },

    /**
     * @param {cc.ActionInterval} action
     * @return {*}
     */
    easeActionWithAction:function (action) {
        return cc.EaseOut.create(action, 2.0);
    }
});

/**
 * create a transition that a new scene is slided from left
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionSlideInL}
 * @example
 * // Example
 * var myTransition = cc.TransitionSlideInL.create(1.5, nextScene)
 */
cc.TransitionSlideInL.create = function (t, scene) {
    var tempScene = new cc.TransitionSlideInL();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 *  Slide in the incoming scene from the right border.
 * @class
 * @extends cc.TransitionSlideInL
 */
cc.TransitionSlideInR = cc.TransitionSlideInL.extend(/** @lends cc.TransitionSlideInR# */{
    _sceneOrder:function () {
        this._isInSceneOnTop = true;
    },
    /**
     * initializes the scenes
     */
    initScenes:function () {
        var s = cc.Director.getInstance().getWinSize();
        this._inScene.setPosition(cc.p(s.width - cc.ADJUST_FACTOR, 0));
    },
    /**
     *  returns the action that will be performed by the incomming and outgoing scene
     * @return {cc.MoveBy}
     */
    action:function () {
        var s = cc.Director.getInstance().getWinSize();
        return cc.MoveBy.create(this._duration, cc.p(-(s.width - cc.ADJUST_FACTOR), 0));
    }
});

/**
 * create Slide in the incoming scene from the right border.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionSlideInR}
 * @example
 * // Example
 * var myTransition = cc.TransitionSlideInR.create(1.5, nextScene)
 */
cc.TransitionSlideInR.create = function (t, scene) {
    var tempScene = new cc.TransitionSlideInR();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 * Slide in the incoming scene from the bottom border.
 * @class
 * @extends cc.TransitionSlideInL
 */
cc.TransitionSlideInB = cc.TransitionSlideInL.extend(/** @lends cc.TransitionSlideInB# */{
    _sceneOrder:function () {
        this._isInSceneOnTop = false;
    },

    /**
     * initializes the scenes
     */
    initScenes:function () {
        var s = cc.Director.getInstance().getWinSize();
        this._inScene.setPosition(cc.p(0, s.height - cc.ADJUST_FACTOR));
    },

    /**
     * returns the action that will be performed by the incomming and outgoing scene
     * @return {cc.MoveBy}
     */
    action:function () {
        var s = cc.Director.getInstance().getWinSize();
        return cc.MoveBy.create(this._duration, cc.p(0, -(s.height - cc.ADJUST_FACTOR)));
    }
});

/**
 * create a Slide in the incoming scene from the bottom border.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionSlideInB}
 * @example
 * // Example
 * var myTransition = cc.TransitionSlideInB.create(1.5, nextScene)
 */
cc.TransitionSlideInB.create = function (t, scene) {
    var tempScene = new cc.TransitionSlideInB();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 *  Slide in the incoming scene from the top border.
 *  @class
 *  @extends cc.TransitionSlideInL
 */
cc.TransitionSlideInT = cc.TransitionSlideInL.extend(/** @lends cc.TransitionSlideInT# */{
    _sceneOrder:function () {
        this._isInSceneOnTop = true;
    },

    /**
     * initializes the scenes
     */
    initScenes:function () {
        var s = cc.Director.getInstance().getWinSize();
        this._inScene.setPosition(cc.p(0, -(s.height - cc.ADJUST_FACTOR)));
    },

    /**
     * returns the action that will be performed by the incomming and outgoing scene
     * @return {cc.MoveBy}
     */
    action:function () {
        var s = cc.Director.getInstance().getWinSize();
        return cc.MoveBy.create(this._duration, cc.p(0, s.height - cc.ADJUST_FACTOR));
    }
});

/**
 * create a Slide in the incoming scene from the top border.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionSlideInT}
 * @example
 * // Example
 * var myTransition = cc.TransitionSlideInT.create(1.5, nextScene)
 */
cc.TransitionSlideInT.create = function (t, scene) {
    var tempScene = new cc.TransitionSlideInT();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 * Shrink the outgoing scene while grow the incoming scene
 * @class
 * @extends cc.TransitionScene
 */
cc.TransitionShrinkGrow = cc.TransitionScene.extend(/** @lends cc.TransitionShrinkGrow# */{

    /**
     * Custom on enter
     */
    onEnter:function () {
        this._super();

        this._inScene.setScale(0.001);
        this._outScene.setScale(1.0);

        this._inScene.setAnchorPoint(cc.p(2 / 3.0, 0.5));
        this._outScene.setAnchorPoint(cc.p(1 / 3.0, 0.5));

        var scaleOut = cc.ScaleTo.create(this._duration, 0.01);
        var scaleIn = cc.ScaleTo.create(this._duration, 1.0);

        this._inScene.runAction(this.easeActionWithAction(scaleIn));
        this._outScene.runAction(
            cc.Sequence.create(
                this.easeActionWithAction(scaleOut),
                cc.CallFunc.create(this, this.finish)
            )
        );
    },

    /**
     * @param action
     * @return {cc.EaseOut}
     */
    easeActionWithAction:function (action) {
        //TODO
        return cc.EaseOut.create(action, 2.0);
    }
});

/**
 * Shrink the outgoing scene while grow the incoming scene
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionShrinkGrow}
 * @example
 * // Example
 * var myTransition = cc.TransitionShrinkGrow.create(1.5, nextScene)
 */
cc.TransitionShrinkGrow.create = function (t, scene) {
    var tempScene = new cc.TransitionShrinkGrow();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 *  Flips the screen horizontally.<br/>
 * The front face is the outgoing scene and the back face is the incoming scene.
 * @class
 * @extends cc.TransitionSceneOriented
 */
cc.TransitionFlipX = cc.TransitionSceneOriented.extend(/** @lends cc.TransitionFlipX# */{

    /**
     * custom on enter
     */
    onEnter:function () {
        this._super();

        var inA, outA;
        this._inScene.setVisible(false);

        var inDeltaZ, inAngleZ;
        var outDeltaZ, outAngleZ;

        if (this._orientation == cc.ORIENTATION_RIGHT_OVER) {
            inDeltaZ = 90;
            inAngleZ = 270;
            outDeltaZ = 90;
            outAngleZ = 0;
        } else {
            inDeltaZ = -90;
            inAngleZ = 90;
            outDeltaZ = -90;
            outAngleZ = 0;
        }

        inA = cc.Sequence.create
            (
                cc.DelayTime.create(this._duration / 2),
                cc.Show.create(),
                //TODO
                cc.OrbitCamera.create(this._duration / 2, 1, 0, inAngleZ, inDeltaZ, 0, 0),
                cc.CallFunc.create(this, this.finish)
            );

        outA = cc.Sequence.create
            (
                cc.OrbitCamera.create(this._duration / 2, 1, 0, outAngleZ, outDeltaZ, 0, 0),
                cc.Hide.create(),
                cc.DelayTime.create(this._duration / 2)
            );

        this._inScene.runAction(inA);
        this._outScene.runAction(outA);
    }
});

/**
 * Flips the screen horizontally.<br/>
 * The front face is the outgoing scene and the back face is the incoming scene.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @param {cc.ORIENTATION_LEFT_OVER|cc.ORIENTATION_RIGHT_OVER|cc.ORIENTATION_UP_OVER|cc.ORIENTATION_DOWN_OVER} o
 * @return {cc.TransitionFlipX}
 * @example
 * // Example
 * var myTransition = cc.TransitionFlipX.create(1.5, nextScene) //default is cc.ORIENTATION_RIGHT_OVER
 *
 * //OR
 * var myTransition = cc.TransitionFlipX.create(1.5, nextScene, cc.ORIENTATION_UP_OVER)
 */
cc.TransitionFlipX.create = function (t, scene, o) {
    if (o == null)
        o = cc.ORIENTATION_RIGHT_OVER;

    var tempScene = new cc.TransitionFlipX();
    tempScene.initWithDuration(t, scene, o);

    return tempScene;
};

/**
 * Flips the screen vertically.<br/>
 * The front face is the outgoing scene and the back face is the incoming scene.
 * @class
 * @extends cc.TransitionSceneOriented
 */
cc.TransitionFlipY = cc.TransitionSceneOriented.extend(/** @lends cc.TransitionFlipY# */{

    /**
     * custom on enter
     */
    onEnter:function () {
        this._super();

        var inA, outA;
        this._inScene.setVisible(false);

        var inDeltaZ, inAngleZ;
        var outDeltaZ, outAngleZ;

        if (this._orientation == cc.ORIENTATION_UP_OVER) {
            inDeltaZ = 90;
            inAngleZ = 270;
            outDeltaZ = 90;
            outAngleZ = 0;
        } else {
            inDeltaZ = -90;
            inAngleZ = 90;
            outDeltaZ = -90;
            outAngleZ = 0;
        }

        //TODO
        inA = cc.Sequence.create
            (
                cc.DelayTime.create(this._duration / 2),
                cc.Show.create(),
                cc.OrbitCamera.create(this._duration / 2, 1, 0, inAngleZ, inDeltaZ, 90, 0),
                cc.CallFunc.create(this, this.finish)
            );
        outA = cc.Sequence.create
            (
                cc.OrbitCamera.create(this._duration / 2, 1, 0, outAngleZ, outDeltaZ, 90, 0),
                cc.Hide.create(),
                cc.DelayTime.create(this._duration / 2)
            );

        this._inScene.runAction(inA);
        this._outScene.runAction(outA);
    }
});

/**
 * Flips the screen vertically.<br/>
 * The front face is the outgoing scene and the back face is the incoming scene.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @param {cc.ORIENTATION_LEFT_OVER|cc.ORIENTATION_RIGHT_OVER|cc.ORIENTATION_UP_OVER|cc.ORIENTATION_DOWN_OVER} o
 * @return {cc.TransitionFlipY}
 * @example
 * // Example
 * var myTransition = cc.TransitionFlipY.create(1.5, nextScene)//default is cc.ORIENTATION_UP_OVER
 *
 * //OR
 * var myTransition = cc.TransitionFlipY.create(1.5, nextScene, cc.ORIENTATION_RIGHT_OVER)
 */
cc.TransitionFlipY.create = function (t, scene, o) {
    if (o == null)
        o = cc.ORIENTATION_UP_OVER;

    var tempScene = new cc.TransitionFlipY();
    tempScene.initWithDuration(t, scene, o);

    return tempScene;
};

/**
 * Flips the screen half horizontally and half vertically.<br/>
 * The front face is the outgoing scene and the back face is the incoming scene.
 * @class
 * @extends cc.TransitionSceneOriented
 */
cc.TransitionFlipAngular = cc.TransitionSceneOriented.extend(/** @lends cc.TransitionFlipAngular# */{
    /**
     * custom on enter
     */
    onEnter:function () {
        this._super();

        var inA, outA;
        this._inScene.setVisible(false);

        var inDeltaZ, inAngleZ;
        var outDeltaZ, outAngleZ;

        if (this._orientation == cc.ORIENTATION_RIGHT_OVER) {
            inDeltaZ = 90;
            inAngleZ = 270;
            outDeltaZ = 90;
            outAngleZ = 0;
        } else {
            inDeltaZ = -90;
            inAngleZ = 90;
            outDeltaZ = -90;
            outAngleZ = 0;
        }

        //TODO
        inA = cc.Sequence.create
            (
                cc.DelayTime.create(this._duration / 2),
                cc.Show.create(),
                cc.OrbitCamera.create(this._duration / 2, 1, 0, inAngleZ, inDeltaZ, -45, 0),
                cc.CallFunc.create(this, this.finish)
            );
        outA = cc.Sequence.create
            (
                cc.OrbitCamera.create(this._duration / 2, 1, 0, outAngleZ, outDeltaZ, 45, 0),
                cc.Hide.create(),
                cc.DelayTime.create(this._duration / 2)
            );

        this._inScene.runAction(inA);
        this._outScene.runAction(outA);
    }
});

/**
 * Flips the screen half horizontally and half vertically.<br/>
 * The front face is the outgoing scene and the back face is the incoming scene.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @param {cc.ORIENTATION_LEFT_OVER|cc.ORIENTATION_RIGHT_OVER|cc.ORIENTATION_UP_OVER|cc.ORIENTATION_DOWN_OVER} o
 * @return {cc.TransitionFlipAngular}
 * @example
 * // Example
 * var myTransition = cc.TransitionFlipAngular.create(1.5, nextScene)//default is cc.ORIENTATION_RIGHT_OVER
 *
 * //or
 * var myTransition = cc.TransitionFlipAngular.create(1.5, nextScene, cc.ORIENTATION_DOWN_OVER)
 */
cc.TransitionFlipAngular.create = function (t, scene, o) {
    if (o == null)
        o = cc.ORIENTATION_RIGHT_OVER;

    var tempScene = new cc.TransitionFlipAngular();
    tempScene.initWithDuration(t, scene, o);

    return tempScene;
};

/**
 *  Flips the screen horizontally doing a zoom out/in<br/>
 * The front face is the outgoing scene and the back face is the incoming scene.
 * @class
 * @extends cc.TransitionSceneOriented
 */
cc.TransitionZoomFlipX = cc.TransitionSceneOriented.extend(/** @lends cc.TransitionZoomFlipX# */{

    /**
     * custom on enter
     */
    onEnter:function () {
        this._super();

        var inA, outA;
        this._inScene.setVisible(false);

        var inDeltaZ, inAngleZ;
        var outDeltaZ, outAngleZ;

        if (this._orientation == cc.ORIENTATION_RIGHT_OVER) {
            inDeltaZ = 90;
            inAngleZ = 270;
            outDeltaZ = 90;
            outAngleZ = 0;
        } else {
            inDeltaZ = -90;
            inAngleZ = 90;
            outDeltaZ = -90;
            outAngleZ = 0;
        }
        //TODO
        inA = cc.Sequence.create(
            cc.DelayTime.create(this._duration / 2),
            cc.Spawn.create(
                cc.OrbitCamera.create(this._duration / 2, 1, 0, inAngleZ, inDeltaZ, 0, 0),
                cc.ScaleTo.create(this._duration / 2, 1),
                cc.Show.create()),
            cc.CallFunc.create(this, this.finish)
        );
        outA = cc.Sequence.create(
            cc.Spawn.create(
                cc.OrbitCamera.create(this._duration / 2, 1, 0, outAngleZ, outDeltaZ, 0, 0),
                cc.ScaleTo.create(this._duration / 2, 0.5)),
            cc.Hide.create(),
            cc.DelayTime.create(this._duration / 2)
        );

        this._inScene.setScale(0.5);
        this._inScene.runAction(inA);
        this._outScene.runAction(outA);
    }
});

/**
 * Flips the screen horizontally doing a zoom out/in<br/>
 * The front face is the outgoing scene and the back face is the incoming scene.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @param {cc.ORIENTATION_LEFT_OVER|cc.ORIENTATION_RIGHT_OVER|cc.ORIENTATION_UP_OVER|cc.ORIENTATION_DOWN_OVER} o
 * @return {cc.TransitionZoomFlipX}
 * @example
 * // Example
 * var myTransition = cc.TransitionZoomFlipX.create(1.5, nextScene)//default is cc.ORIENTATION_RIGHT_OVER
 *
 * //OR
 * var myTransition = cc.TransitionZoomFlipX.create(1.5, nextScene, cc.ORIENTATION_DOWN_OVER)
 */
cc.TransitionZoomFlipX.create = function (t, scene, o) {
    if (o == null)
        o = cc.ORIENTATION_RIGHT_OVER;

    var tempScene = new cc.TransitionZoomFlipX();
    tempScene.initWithDuration(t, scene, o);

    return tempScene;
};

/**
 * Flips the screen vertically doing a little zooming out/in<br/>
 * The front face is the outgoing scene and the back face is the incoming scene.
 * @class
 * @extends cc.TransitionSceneOriented
 */
cc.TransitionZoomFlipY = cc.TransitionSceneOriented.extend(/** @lends cc.TransitionZoomFlipY# */{

    /**
     * custom on enter
     */
    onEnter:function () {
        this._super();

        var inA, outA;
        this._inScene.setVisible(false);

        var inDeltaZ, inAngleZ;
        var outDeltaZ, outAngleZ;

        if (this._orientation == cc.ORIENTATION_UP_OVER) {
            inDeltaZ = 90;
            inAngleZ = 270;
            outDeltaZ = 90;
            outAngleZ = 0;
        } else {
            inDeltaZ = -90;
            inAngleZ = 90;
            outDeltaZ = -90;
            outAngleZ = 0;
        }

        //TODO
        inA = cc.Sequence.create(
            cc.DelayTime.create(this._duration / 2),
            cc.Spawn.create(
                cc.OrbitCamera.create(this._duration / 2, 1, 0, inAngleZ, inDeltaZ, 90, 0),
                cc.ScaleTo.create(this._duration / 2, 1),
                cc.Show.create()),
            cc.CallFunc.create(this, this.finish));

        outA = cc.Sequence.create(
            cc.Spawn.create(
                cc.OrbitCamera.create(this._duration / 2, 1, 0, outAngleZ, outDeltaZ, 90, 0),
                cc.ScaleTo.create(this._duration / 2, 0.5)),
            cc.Hide.create(),
            cc.DelayTime.create(this._duration / 2));

        this._inScene.setScale(0.5);
        this._inScene.runAction(inA);
        this._outScene.runAction(outA);
    }
});

/**
 * Flips the screen vertically doing a little zooming out/in<br/>
 * The front face is the outgoing scene and the back face is the incoming scene.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @param {cc.ORIENTATION_LEFT_OVER|cc.ORIENTATION_RIGHT_OVER|cc.ORIENTATION_UP_OVER|cc.ORIENTATION_DOWN_OVER} o
 * @return {cc.TransitionZoomFlipY}
 * @example
 * // Example
 * var myTransition = cc.TransitionZoomFlipY.create(1.5, nextScene)//default is cc.ORIENTATION_UP_OVER
 *
 * //OR
 * var myTransition = cc.TransitionZoomFlipY.create(1.5, nextScene, cc.ORIENTATION_DOWN_OVER)
 */
cc.TransitionZoomFlipY.create = function (t, scene, o) {
    if (o == null)
        o = cc.ORIENTATION_UP_OVER;

    var tempScene = new cc.TransitionZoomFlipY();
    tempScene.initWithDuration(t, scene, o);

    return tempScene;
};

/**
 *  Flips the screen half horizontally and half vertically doing a little zooming out/in.<br/>
 * The front face is the outgoing scene and the back face is the incoming scene.
 * @class
 * @extends cc.TransitionSceneOriented
 */
cc.TransitionZoomFlipAngular = cc.TransitionSceneOriented.extend(/** @lends cc.TransitionZoomFlipAngular# */{

    /**
     * custom on enter
     */
    onEnter:function () {
        this._super();

        var inA, outA;
        this._inScene.setVisible(false);

        var inDeltaZ, inAngleZ;
        var outDeltaZ, outAngleZ;

        if (this._orientation == cc.ORIENTATION_RIGHT_OVER) {
            inDeltaZ = 90;
            inAngleZ = 270;
            outDeltaZ = 90;
            outAngleZ = 0;
        } else {
            inDeltaZ = -90;
            inAngleZ = 90;
            outDeltaZ = -90;
            outAngleZ = 0;
        }

        //TODO
        inA = cc.Sequence.create(
            cc.DelayTime.create(this._duration / 2),
            cc.Spawn.create(
                cc.OrbitCamera.create(this._duration / 2, 1, 0, inAngleZ, inDeltaZ, -45, 0),
                cc.ScaleTo.create(this._duration / 2, 1),
                cc.Show.create()),
            cc.Show.create(),
            cc.CallFunc.create(this, this.finish));
        outA = cc.Sequence.create(
            cc.Spawn.create(
                cc.OrbitCamera.create(this._duration / 2, 1, 0, outAngleZ, outDeltaZ, 45, 0),
                cc.ScaleTo.create(this._duration / 2, 0.5)),
            cc.Hide.create(),
            cc.DelayTime.create(this._duration / 2));

        this._inScene.setScale(0.5);
        this._inScene.runAction(inA);
        this._outScene.runAction(outA);
    }
});

/**
 *  Flips the screen half horizontally and half vertically doing a little zooming out/in.<br/>
 * The front face is the outgoing scene and the back face is the incoming scene.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @param {cc.ORIENTATION_LEFT_OVER|cc.ORIENTATION_RIGHT_OVER|cc.ORIENTATION_UP_OVER|cc.ORIENTATION_DOWN_OVER} o
 * @return {cc.TransitionZoomFlipAngular}
 * @example
 * // Example
 * var myTransition = cc.TransitionZoomFlipAngular.create(1.5, nextScene)//default is cc.ORIENTATION_RIGHT_OVER
 *
 * //OR
 * var myTransition = cc.TransitionZoomFlipAngular.create(1.5, nextScene, cc.ORIENTATION_DOWN_OVER)
 */
cc.TransitionZoomFlipAngular.create = function (t, scene, o) {
    if (o == null)
        o = cc.ORIENTATION_RIGHT_OVER;

    var tempScene = new cc.TransitionZoomFlipAngular();
    tempScene.initWithDuration(t, scene, o);

    return tempScene;
};

/**
 * Fade out the outgoing scene and then fade in the incoming scene.
 * @class
 * @extends cc.TransitionScene
 */
cc.TransitionFade = cc.TransitionScene.extend(/** @lends cc.TransitionFade# */{
    _color:new cc.Color3B(),

    /**
     * Constructor
     */
    ctor:function () {
    },

    /**
     * custom on enter
     */
    onEnter:function () {
        this._super();

        var l = cc.LayerColor.create(this._color);
        this._inScene.setVisible(false);

        this.addChild(l, 2, cc.SCENE_FADE);
        var f = this.getChildByTag(cc.SCENE_FADE);

        //TODO
        var a = cc.Sequence.create(
            cc.FadeIn.create(this._duration / 2),
            cc.CallFunc.create(this, this.hideOutShowIn), //CCCallFunc.actionWithTarget:self selector:@selector(hideOutShowIn)],
            cc.FadeOut.create(this._duration / 2),
            cc.CallFunc.create(this, this.finish) //:self selector:@selector(finish)],
        );
        f.runAction(a);
    },

    /**
     * custom on exit
     */
    onExit:function () {
        this._super();
        this.removeChildByTag(cc.SCENE_FADE, false);
    },

    /**
     * initializes the transition with a duration and with an RGB color
     * @param {Number} t time in seconds
     * @param {cc.Scene} scene
     * @param {cc.Color3B} color
     * @return {Boolean}
     */
    initWithDuration:function (t, scene, color) {
        if ((color == 'undefined') || (color == null)) {
            color = cc.black();
        }

        if (this._super(t, scene)) {
            this._color.r = color.r;
            this._color.g = color.g;
            this._color.b = color.b;
            this._color.a = 0;
        }
        return true;
    }
});


/**
 * Fade out the outgoing scene and then fade in the incoming scene.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @param {cc.Color3B} color
 * @return {cc.TransitionFade}
 * @example
 * // Example
 * var myTransition = cc.TransitionFade.create(1.5, nextScene, cc.c3b(255,0,0))//fade to red
 */
cc.TransitionFade.create = function (t, scene, color) {
    var transition = new cc.TransitionFade();
    transition.initWithDuration(t, scene, color);

    return transition;
};

/**
 * Cross fades two scenes using the cc.RenderTexture object.
 * @class
 * @extends cc.TransitionScene
 */
cc.TransitionCrossFade = cc.TransitionScene.extend(/** @lends cc.TransitionCrossFade# */{

    /**
     * custom on enter
     */
    onEnter:function () {
        this._super();

        // create a transparent color layer
        // in which we are going to add our rendertextures
        var color = new cc.Color4B(0, 0, 0, 0);
        var size = cc.Director.getInstance().getWinSize();
        var layer = cc.LayerColor.create(color);

        // create the first render texture for inScene
        var inTexture = cc.RenderTexture.create(size.width, size.height);

        if (null == inTexture) {
            return;
        }

        inTexture.getSprite().setAnchorPoint(cc.p(0.5, 0.5));
        inTexture.setPosition(cc.p(size.width / 2, size.height / 2));
        inTexture.setAnchorPoint(cc.p(0.5, 0.5));

        // render inScene to its texturebuffer
        inTexture.begin();
        this._inScene.visit();
        inTexture.end();

        // create the second render texture for outScene
        var outTexture = cc.RenderTexture.create(size.width, size.height);
        outTexture.getSprite().setAnchorPoint(cc.p(0.5, 0.5));
        outTexture.setPosition(cc.p(size.width / 2, size.height / 2));
        outTexture.setAnchorPoint(cc.p(0.5, 0.5));

        // render outScene to its texturebuffer
        outTexture.begin();
        this._outScene.visit();
        outTexture.end();

        // inScene will lay on background and will not be used with alpha
        inTexture.getSprite().setBlendFunc(gl.ONE, gl.ONE);
        // we are going to blend outScene via alpha
        outTexture.getSprite().setBlendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        // add render textures to the layer
        layer.addChild(inTexture);
        layer.addChild(outTexture);

        // initial opacity:
        inTexture.getSprite().setOpacity(255);
        outTexture.getSprite().setOpacity(255);

        // create the blend action
        //TODO
        var layerAction = cc.Sequence.create(
            cc.FadeTo.create(this._duration, 0),
            cc.CallFunc.create(this, this.hideOutShowIn),
            cc.CallFunc.create(this, this.finish)
        );

        // run the blend action
        outTexture.getSprite().runAction(layerAction);

        // add the layer (which contains our two rendertextures) to the scene
        this.addChild(layer, 2, cc.SCENE_FADE);
    },

    /**
     * custom on exit
     */
    onExit:function () {
        this.removeChildByTag(cc.SCENE_FADE, false);
        this._super();
    },

    /**
     * overide draw
     */
    draw:function () {
        // override draw since both scenes (textures) are rendered in 1 scene
    }
});

/**
 * Cross fades two scenes using the cc.RenderTexture object.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionCrossFade}
 * @example
 * // Example
 * var myTransition = cc.TransitionCrossFade.create(1.5, nextScene)
 */
cc.TransitionCrossFade.create = function (t, scene) {
    var Transition = new cc.TransitionCrossFade();
    Transition.initWithDuration(t, scene);
    return Transition;
};

/**
 *  Turn off the tiles of the outgoing scene in random order
 * @class
 * @extends cc.TransitionScene
 */
cc.TransitionTurnOffTiles = cc.TransitionScene.extend(/** @lends cc.TransitionTurnOffTiles# */{
    _sceneOrder:function () {
        this._isInSceneOnTop = false;
    },

    /**
     * custom on enter
     */
    onEnter:function () {
        this._super();
        var s = cc.Director.getInstance().getWinSize();
        var aspect = s.width / s.height;
        var x = 12 * aspect;
        var y = 12;
        var toff = cc.TurnOffTiles.create(cc.g(x, y), this._duration);
        var action = this.easeActionWithAction(toff);
        //TODO
        this._outScene.runAction(cc.Sequence.create(action, cc.CallFunc.create(this, this.finish), cc.StopGrid.create()));
    },

    /**
     * @param {cc.ActionInterval} action
     * @return {cc.ActionInterval}
     */
    easeActionWithAction:function (action) {
        return action;
    }
});

/**
 *  Turn off the tiles of the outgoing scene in random order
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionTurnOffTiles}
 * @example
 * // Example
 * var myTransition = cc.TransitionTurnOffTiles.create(1.5, nextScene)
 */
cc.TransitionTurnOffTiles.create = function (t, scene) {
    var tempScene = new cc.TransitionTurnOffTiles();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 *  The odd columns goes upwards while the even columns goes downwards.
 * @class
 * @extends cc.TransitionScene
 */
cc.TransitionSplitCols = cc.TransitionScene.extend(/** @lends cc.TransitionSplitCols# */{

    /**
     * custom on enter
     */
    onEnter:function () {
        this._super();
        this._inScene.setVisible(false);

        var split = this.action();
        //TODO
        var seq = cc.Sequence.create(
            split,
            cc.CallFunc.create(this, this.hideOutShowIn),
            split.reverse());

        this.runAction(
            cc.Sequence.create(
                this.easeActionWithAction(seq),
                cc.CallFunc.create(this, this.finish),
                cc.StopGrid.create()
            ));
    },

    /**
     * @param {cc.ActionInterval} action
     * @return {cc.EaseInOut}
     */
    easeActionWithAction:function (action) {
        return cc.EaseInOut.create(action, 3.0);
    },

    /**
     * @return {*}
     */
    action:function () {
        //TODO
        return cc.SplitCols.create(3, this._duration / 2.0);
    }
});

/**
 * The odd columns goes upwards while the even columns goes downwards.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionSplitCols}
 * @example
 * // Example
 * var myTransition = cc.TransitionSplitCols.create(1.5, nextScene)
 */
cc.TransitionSplitCols.create = function (t, scene) {
    var tempScene = new cc.TransitionSplitCols();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 *  The odd rows goes to the left while the even rows goes to the right.
 * @class
 * @extends cc.TransitionSplitCols
 */
cc.TransitionSplitRows = cc.TransitionSplitCols.extend(/** @lends cc.TransitionSplitRows# */{

    /**
     * @return {*}
     */
    action:function () {
        return cc.SplitRows.actionWithRows(3, this._duration / 2.0);
    }
});

/**
 * The odd rows goes to the left while the even rows goes to the right.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionSplitRows}
 * @example
 * // Example
 * var myTransition = cc.TransitionSplitRows.create(1.5, nextScene)
 */
cc.TransitionSplitRows.create = function (t, scene) {
    var tempScene = new cc.TransitionSplitRows();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 *  Fade the tiles of the outgoing scene from the left-bottom corner the to top-right corner.
 * @class
 * @extends cc.TransitionScene
 */
cc.TransitionFadeTR = cc.TransitionScene.extend(/** @lends cc.TransitionFadeTR# */{
    _sceneOrder:function () {
        this._isInSceneOnTop = false;
    },

    /**
     * Custom on enter
     */
    onEnter:function () {
        this._super();

        var s = cc.Director.getInstance().getWinSize();
        var aspect = s.width / s.height;
        var x = (12 * aspect);
        var y = 12;

        var action = this.actionWithSize(cc.g(x, y));

        this._outScene.runAction(
            cc.Sequence.create(
                this.easeActionWithAction(action),
                cc.CallFunc.create(this, this.finish),
                cc.StopGrid.create())
        );
    },

    /**
     * @param {cc.ActionInterval} action
     * @return {cc.ActionInterval}
     */
    easeActionWithAction:function (action) {
        return action;
    },

    /**
     * @param {cc.Size} size
     * @return {*}
     */
    actionWithSize:function (size) {
        return cc.FadeOutTRTiles.create(size, this._duration);
    }
});

/**
 *  Fade the tiles of the outgoing scene from the left-bottom corner the to top-right corner.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionFadeTR}
 * @example
 * // Example
 * var myTransition = cc.TransitionFadeTR.create(1.5, nextScene)
 */
cc.TransitionFadeTR.create = function (t, scene) {
    var tempScene = new cc.TransitionFadeTR();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 *  Fade the tiles of the outgoing scene from the top-right corner to the bottom-left corner.
 * @class
 * @extends cc.TransitionFadeTR
 */
cc.TransitionFadeBL = cc.TransitionFadeTR.extend(/** @lends cc.TransitionFadeBL# */{

    /**
     * @param {cc.Size} size
     * @return {*}
     */
    actionWithSize:function (size) {
        return cc.FadeOutBLTiles.create(size, this._duration);
    }
});

/**
 * Fade the tiles of the outgoing scene from the top-right corner to the bottom-left corner.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionFadeBL}
 * @example
 * // Example
 * var myTransition = cc.TransitionFadeBL.create(1.5, nextScene)
 */
cc.TransitionFadeBL.create = function (t, scene) {
    var tempScene = new cc.TransitionFadeBL();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 * Fade the tiles of the outgoing scene from the top-right corner to the bottom-left corner.
 * @class
 * @extends cc.TransitionFadeTR
 */
cc.TransitionFadeUp = cc.TransitionFadeTR.extend(/** @lends cc.TransitionFadeUp# */{

    /**
     * @param {cc.Size} size
     * @return {*}
     */
    actionWithSize:function (size) {
        return cc.FadeOutUpTiles.create(size, this._duration);
    }
});

/**
 * Fade the tiles of the outgoing scene from the top-right corner to the bottom-left corner.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionFadeUp}
 * @example
 * // Example
 * var myTransition = cc.TransitionFadeUp.create(1.5, nextScene)
 */
cc.TransitionFadeUp.create = function (t, scene) {
    var tempScene = new cc.TransitionFadeUp();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 * Fade the tiles of the outgoing scene from the top to the bottom.
 * @class
 * @extends cc.TransitionFadeTR
 */
cc.TransitionFadeDown = cc.TransitionFadeTR.extend(/** @lends cc.TransitionFadeDown# */{

    /**
     * @param {cc.Size} size
     * @return {*}
     */
    actionWithSize:function (size) {
        return cc.FadeOutDownTiles.create(size, this._duration);
    }
});

/**
 * Fade the tiles of the outgoing scene from the top to the bottom.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @return {cc.TransitionFadeDown}
 * @example
 * // Example
 * var myTransition = cc.TransitionFadeDown.create(1.5, nextScene)
 */
cc.TransitionFadeDown.create = function (t, scene) {
    var tempScene = new cc.TransitionFadeDown();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * tag for scene redial
 * @constant
 * @type Number
 */
cc.SCENE_RADIAL = 0xc001;

/**
 * cc.TransitionProgress transition.
 * @class
 * @extends cc.TransitionScene
 */
cc.TransitionProgress = cc.TransitionScene.extend(/** @lends cc.TransitionProgress# */{
    _to:0,
    _from:0,
    _sceneToBeModified:null,

    /**
     * @override
     */
    onEnter:function () {
        this._super();

        this._setupTransition();

        // create a transparent color layer
        // in which we are going to add our rendertextures
        var winSize = cc.Director.getInstance().getWinSize();

        // create the second render texture for outScene
        var texture = cc.RenderTexture.create(winSize.width, winSize.height);
        texture.getSprite().setAnchorPoint(cc.p(0.5, 0.5));
        texture.setPosition(cc.p(winSize.width / 2, winSize.height / 2));
        texture.setAnchorPoint(cc.p(0.5, 0.5));

        if (cc.renderContextType == cc.CANVAS) {
            // render outScene to its texturebuffer
            texture.clear();
            this._sceneToBeModified.visit(texture.context);
        } else {
            // render outScene to its texturebuffer
            texture.clear(0, 0, 0, 1);
            texture.begin();
            this._sceneToBeModified.visit();
            texture.end();
        }
        //    Since we've passed the outScene to the texture we don't need it.
        if (this._sceneToBeModified == this._outScene) {
            this.hideOutShowIn();
        }
        //    We need the texture in RenderTexture.
        var pNode = this._progressTimerNodeWithRenderTexture(texture);

        // create the blend action
        var layerAction = cc.Sequence.create(
            cc.ProgressFromTo.create(this._duration, this._from, this._to),
            cc.CallFunc.create(this, this.finish));
        // run the blend action
        pNode.runAction(layerAction);

        // add the layer (which contains our two rendertextures) to the scene
        this.addChild(pNode, 2, cc.SCENE_RADIAL);

    },

    /**
     * @override
     */
    onExit:function () {
        // remove our layer and release all containing objects
        this.removeChildByTag(cc.SCENE_RADIAL, false);
        this._super();
    },

    _setupTransition:function () {
        this._sceneToBeModified = this._outScene;
        this._from = 100;
        this._to = 0;
    },

    _progressTimerNodeWithRenderTexture:function (texture) {
        cc.Assert(false, "override me - abstract class");
        return null;
    },

    _sceneOrder:function () {
        this._isInSceneOnTop = false;
    }
});

/**
 * create a cc.TransitionProgress object
 * @function
 * @param {Number} t time
 * @param {cc.Scene} scene
 * @return {cc.TransitionProgress}
 */
cc.TransitionProgress.create = function (t, scene) {
    var tempScene = new cc.TransitionProgress();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 *  cc.TransitionRadialCCW transition.<br/>
 *  A counter colock-wise radial transition to the next scene
 * @class
 * @extends cc.TransitionProgress
 */
cc.TransitionProgressRadialCCW = cc.TransitionProgress.extend(/** @lends cc.TransitionProgressRadialCCW# */{
    _progressTimerNodeWithRenderTexture:function (texture) {
        var size = cc.Director.getInstance().getWinSize();

        var pNode = cc.ProgressTimer.create(texture.getSprite());

        // but it is flipped upside down so we flip the sprite
        if (cc.renderContextType == cc.WEBGL)
            pNode.getSprite().setFlipY(true);
        pNode.setType(cc.PROGRESS_TIMER_TYPE_RADIAL);

        //    Return the radial type that we want to use
        pNode.setReverseDirection(false);
        pNode.setPercentage(100);
        pNode.setPosition(cc.p(size.width / 2, size.height / 2));
        pNode.setAnchorPoint(cc.p(0.5, 0.5));

        return pNode;
    }
});

/**
 * create a cc.TransitionProgressRadialCCW object
 * @function
 * @param {Number} t time
 * @param {cc.Scene} scene
 * @return {cc.TransitionProgressRadialCCW}
 */
cc.TransitionProgressRadialCCW.create = function (t, scene) {
    var tempScene = new cc.TransitionProgressRadialCCW();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 * cc.TransitionRadialCW transition.<br/>
 * A counter colock-wise radial transition to the next scene
 * @class
 * @extends cc.TransitionProgress
 */
cc.TransitionProgressRadialCW = cc.TransitionProgress.extend(/** @lends cc.TransitionProgressRadialCW# */{
    _progressTimerNodeWithRenderTexture:function (texture) {
        var size = cc.Director.getInstance().getWinSize();

        var pNode = cc.ProgressTimer.create(texture.getSprite());

        // but it is flipped upside down so we flip the sprite
        if (cc.renderContextType == cc.WEBGL)
            pNode.getSprite().setFlipY(true);
        pNode.setType(cc.PROGRESS_TIMER_TYPE_RADIAL);

        //    Return the radial type that we want to use
        pNode.setReverseDirection(true);
        pNode.setPercentage(100);
        pNode.setPosition(cc.p(size.width / 2, size.height / 2));
        pNode.setAnchorPoint(cc.p(0.5, 0.5));

        return pNode;
    }
});

/**
 * create a cc.TransitionProgressRadialCW object
 * @function
 * @param {Number} t time
 * @param {cc.Scene} scene
 * @return {cc.TransitionProgressRadialCW}
 */
cc.TransitionProgressRadialCW.create = function (t, scene) {
    var tempScene = new cc.TransitionProgressRadialCW();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 * cc.TransitionProgressHorizontal transition.<br/>
 * A  colock-wise radial transition to the next scene
 * @class
 * @extends cc.TransitionProgress
 */
cc.TransitionProgressHorizontal = cc.TransitionProgress.extend(/** @lends cc.TransitionProgressHorizontal# */{
    _progressTimerNodeWithRenderTexture:function (texture) {
        var size = cc.Director.getInstance().getWinSize();

        var pNode = cc.ProgressTimer.create(texture.getSprite());

        // but it is flipped upside down so we flip the sprite
        if (cc.renderContextType == cc.WEBGL)
            pNode.getSprite().setFlipY(true);
        pNode.setType(cc.PROGRESS_TIMER_TYPE_BAR);

        pNode.setMidpoint(cc.p(1, 0));
        pNode.setBarChangeRate(cc.p(1, 0));

        pNode.setPercentage(100);
        pNode.setPosition(cc.p(size.width / 2, size.height / 2));
        pNode.setAnchorPoint(cc.p(0.5, 0.5));

        return pNode;
    }
});

/**
 * create a cc.TransitionProgressHorizontal object
 * @function
 * @param {Number} t time
 * @param {cc.Scene} scene
 * @return {cc.TransitionProgressHorizontal}
 */
cc.TransitionProgressHorizontal.create = function (t, scene) {
    var tempScene = new cc.TransitionProgressHorizontal();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 * cc.TransitionProgressVertical transition.
 * @class
 * @extends cc.TransitionProgress
 */
cc.TransitionProgressVertical = cc.TransitionProgress.extend(/** @lends cc.TransitionProgressVertical# */{
    _progressTimerNodeWithRenderTexture:function (texture) {
        var size = cc.Director.getInstance().getWinSize();

        var pNode = cc.ProgressTimer.create(texture.getSprite());

        // but it is flipped upside down so we flip the sprite
        if (cc.renderContextType == cc.WEBGL)
            pNode.getSprite().setFlipY(true);
        pNode.setType(cc.PROGRESS_TIMER_TYPE_BAR);

        pNode.setMidpoint(cc.p(0, 0));
        pNode.setBarChangeRate(cc.p(0, 1));

        pNode.setPercentage(100);
        pNode.setPosition(cc.p(size.width / 2, size.height / 2));
        pNode.setAnchorPoint(cc.p(0.5, 0.5));

        return pNode;
    }
});

/**
 * create a cc.TransitionProgressVertical object
 * @function
 * @param {Number} t time
 * @param {cc.Scene} scene
 * @return {cc.TransitionProgressVertical}
 */
cc.TransitionProgressVertical.create = function (t, scene) {
    var tempScene = new cc.TransitionProgressVertical();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 * cc.TransitionProgressInOut transition.
 * @class
 * @extends cc.TransitionProgress
 */
cc.TransitionProgressInOut = cc.TransitionProgress.extend(/** @lends cc.TransitionProgressInOut# */{
    _progressTimerNodeWithRenderTexture:function (texture) {
        var size = cc.Director.getInstance().getWinSize();
        var pNode = cc.ProgressTimer.create(texture.getSprite());

        // but it is flipped upside down so we flip the sprite
        if (cc.renderContextType == cc.WEBGL)
            pNode.getSprite().setFlipY(true);
        pNode.setType(cc.PROGRESS_TIMER_TYPE_BAR);

        pNode.setMidpoint(cc.p(0.5, 0.5));
        pNode.setBarChangeRate(cc.p(1, 1));

        pNode.setPercentage(0);
        pNode.setPosition(cc.p(size.width / 2, size.height / 2));
        pNode.setAnchorPoint(cc.p(0.5, 0.5));

        return pNode;
    },
    _sceneOrder:function () {
        this._isInSceneOnTop = false;
    },
    _setupTransition:function () {
        this._sceneToBeModified = this._inScene;
        this._from = 0;
        this._to = 100;
    }
});

/**
 * create a cc.TransitionProgressInOut object
 * @function
 * @param {Number} t time
 * @param {cc.Scene} scene
 * @return {cc.TransitionProgressInOut}
 */
cc.TransitionProgressInOut.create = function (t, scene) {
    var tempScene = new cc.TransitionProgressInOut();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};

/**
 * cc.TransitionProgressOutIn transition.
 * @class
 * @extends cc.TransitionProgress
 */
cc.TransitionProgressOutIn = cc.TransitionProgress.extend(/** @lends cc.TransitionProgressOutIn# */{
    _progressTimerNodeWithRenderTexture:function (texture) {
        var size = cc.Director.getInstance().getWinSize();
        var pNode = cc.ProgressTimer.create(texture.getSprite());

        // but it is flipped upside down so we flip the sprite
        if (cc.renderContextType == cc.WEBGL)
            pNode.getSprite().setFlipY(true);
        pNode.setType(cc.PROGRESS_TIMER_TYPE_BAR);

        pNode.setMidpoint(cc.p(0.5, 0.5));
        pNode.setBarChangeRate(cc.p(1, 1));

        pNode.setPercentage(100);
        pNode.setPosition(cc.p(size.width / 2, size.height / 2));
        pNode.setAnchorPoint(cc.p(0.5, 0.5));

        return pNode;
    }
});

/**
 * create a cc.TransitionProgressOutIn object
 * @function
 * @param {Number} t time
 * @param {cc.Scene} scene
 * @return {cc.TransitionProgressOutIn}
 */
cc.TransitionProgressOutIn.create = function (t, scene) {
    var tempScene = new cc.TransitionProgressOutIn();
    if ((tempScene != null) && (tempScene.initWithDuration(t, scene))) {
        return tempScene;
    }
    return null;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 *<p> A transition which peels back the bottom right hand corner of a scene<br/>
 * to transition to the scene beneath it simulating a page turn.<br/></p>
 *
 * <p>This uses a 3DAction so it's strongly recommended that depth buffering<br/>
 * is turned on in cc.Director using:</p>
 *
 * <p>cc.Director.getInstance().setDepthBufferFormat(kDepthBuffer16);</p>
 * @class
 * @extends cc.TransitionScene
 */
cc.TransitionPageTurn = cc.TransitionScene.extend(/** @lends cc.TransitionPageTurn# */{
    /**
     * @type Boolean
     */
    _back:true,

    /**
     * Creates a base transition with duration and incoming scene.<br/>
     * If back is true then the effect is reversed to appear as if the incoming<br/>
     * scene is being turned from left over the outgoing scene.
     * @param {Number} t time in seconds
     * @param {cc.Scene} scene
     * @param {Boolean} backwards
     * @return {Boolean}
     */
    initWithDuration:function (t, scene, backwards) {
        // XXX: needed before [super init]
        this._back = backwards;

        if (this._super(t, scene)) {
            // do something
        }
        return true;
    },

    /**
     * @param {cc.GridSiz} vector
     * @return {cc.ReverseTime|cc.TransitionScene}
     */
    actionWithSize:function (vector) {
        if (this._back) {
            // Get hold of the PageTurn3DAction
            return cc.ReverseTime.create(this._super(vector, this._duration));
        } else {
            // Get hold of the PageTurn3DAction
            return this._super(vector, this._duration);
        }
    },

    /**
     * custom on enter
     */
    onEnter:function () {
        this._super();
        var s = cc.Director.getInstance().getWinSize();
        var x, y;
        if (s.width > s.height) {
            x = 16;
            y = 12;
        } else {
            x = 12;
            y = 16;
        }

        var action = this.actionWithSize(cc.g(x, y));

        if (!this._back) {
            this._outScene.runAction(cc.Sequence.create(action,
                cc.CallFunc.create(this, cc.TransitionScene.finish),
                cc.StopGrid.create()));
        } else {
            // to prevent initial flicker
            this._inScene.setVisible(false);
            this._inScene.runAction(cc.Sequence.create(cc.Show.create(),
                action,
                cc.CallFunc.create(this, cc.TransitionScene.finish),
                cc.StopGrid.create()));
        }
    },
    _sceneOrder:function () {
        this.isInSceneOnTop = this._back;
    }
});

/**
 * Creates a base transition with duration and incoming scene.<br/>
 * If back is true then the effect is reversed to appear as if the incoming<br/>
 * scene is being turned from left over the outgoing scene.
 * @param {Number} t time in seconds
 * @param {cc.Scene} scene
 * @param {Boolean} backwards
 * @return {cc.TransitionPageTurn}
 * @example
 * // Example
 * var myTransition = cc.TransitionPageTurn.create(1.5, nextScene, true)//true means backwards
 */
cc.TransitionPageTurn.create = function (t, scene, backwards) {
    var transition = new cc.TransitionPageTurn();
    transition.initWithDuration(t, scene, backwards);
    return transition;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * cc.Sprite invalid index on the cc.SpriteBatchode
 * @constant
 * @type Number
 */
cc.SPRITE_INDEX_NOT_INITIALIZED = "0xffffffff";

/**
 * generate texture's cache for texture tint
 * @function
 * @param {HTMLImageElement} texture
 * @return {Array}
 */
cc.generateTextureCacheForColor = function (texture) {
    var w = texture.width;
    var h = texture.height;
    var textureCache = [];

    var canvas = document.createElement("canvas");
    canvas.width = w;
    canvas.height = h;

    var ctx = canvas.getContext("2d");
    ctx.drawImage(texture, 0, 0);

    var tempCanvas = document.createElement("canvas");
    tempCanvas.width = w;
    tempCanvas.height = h;
    var tempCtx = tempCanvas.getContext('2d');

    var pixels = ctx.getImageData(0, 0, w, h).data;

    for (var rgbI = 0; rgbI < 3; rgbI++) {
        var cacheCanvas = document.createElement("canvas");
        cacheCanvas.width = w;
        cacheCanvas.height = h;
        var cacheCtx = cacheCanvas.getContext('2d');

        tempCtx.drawImage(texture, 0, 0);
        var to = tempCtx.getImageData(0, 0, w, h);
        var toData = to.data;

        for (var i = 0; i < pixels.length; i += 4) {
            toData[i  ] = (rgbI === 0) ? pixels[i  ] : 0;
            toData[i + 1] = (rgbI === 1) ? pixels[i + 1] : 0;
            toData[i + 2] = (rgbI === 2) ? pixels[i + 2] : 0;
            toData[i + 3] = pixels[i + 3];
        }
        cacheCtx.putImageData(to, 0, 0);
        textureCache.push(cacheCanvas);
    }
    return textureCache;
};

cc.generateTintImage2 = function (texture, color, rect) {
    if (!rect) {
        rect = cc.rect(0, 0, texture.width, texture.height);
    }
    var selColor;
    if (color instanceof cc.Color4F) {
        selColor = cc.c4b(color.r * 255, color.g * 255, color.b * 255, color.a * 255);
    } else {
        selColor = cc.c4b(color.r, color.g, color.b, 50);//color;
    }

    var buff = document.createElement("canvas");
    var ctx = buff.getContext("2d");

    if (buff.width != rect.size.width) buff.width = rect.size.width;
    if (buff.height != rect.size.height) buff.height = rect.size.height;
    ctx.save();

    ctx.drawImage(texture, rect.origin.x, rect.origin.y, rect.size.width, rect.size.height, 0, 0, rect.size.width, rect.size.height);

    ctx.globalCompositeOperation = "source-in";
    ctx.globalAlpha = selColor.a / 255.0;
    ctx.fillStyle = "rgb(" + selColor.r + "," + selColor.g + "," + selColor.b + ")";
    ctx.fillRect(0, 0, rect.size.width, rect.size.height);
    ctx.restore();

    return buff;
};

/**
 * generate tinted texture
 * @function
 * @param {HTMLImageElement} texture
 * @param {Array} tintedImgCache
 * @param {cc.Color3B|cc.Color4F} color
 * @param {cc.Rect} rect
 * @return {HTMLCanvasElement}
 */
cc.generateTintImage = function (texture, tintedImgCache, color, rect, renderCanvas) {
    if (!rect) {
        rect = cc.rect(0, 0, texture.width, texture.height);
    }
    var selColor;
    if (color instanceof cc.Color4F) {
        selColor = cc.c3b(color.r * 255, color.g * 255, color.b * 255);
    } else {
        selColor = color;
    }
    var buff = renderCanvas || document.createElement("canvas");
    buff.width = rect.size.width;
    buff.height = rect.size.height;
    var ctx = buff.getContext("2d");

    ctx.globalCompositeOperation = 'lighter';
    if (selColor.r > 0) {
        ctx.globalAlpha = selColor.r / 255.0;
        ctx.drawImage(tintedImgCache[0], rect.origin.x, rect.origin.y, rect.size.width, rect.size.height, 0, 0, rect.size.width, rect.size.height);
    }
    if (selColor.g > 0) {
        ctx.globalAlpha = selColor.g / 255.0;
        ctx.drawImage(tintedImgCache[1], rect.origin.x, rect.origin.y, rect.size.width, rect.size.height, 0, 0, rect.size.width, rect.size.height);
    }
    if (selColor.b > 0) {
        ctx.globalAlpha = selColor.b / 255.0;
        ctx.drawImage(tintedImgCache[2], rect.origin.x, rect.origin.y, rect.size.width, rect.size.height, 0, 0, rect.size.width, rect.size.height);
    }
    return buff;
};

cc.cutRotateImageToCanvas = function (texture, rect) {
    if (!texture)
        return null;

    if (!rect)
        return texture;

    var nCanvas = document.createElement("canvas");
    nCanvas.width = rect.size.width;
    nCanvas.height = rect.size.height;

    var ctx = nCanvas.getContext("2d");
    ctx.translate(nCanvas.width / 2, nCanvas.height / 2);
    ctx.rotate(-1.5707963267948966);
    ctx.drawImage(texture, rect.origin.x, rect.origin.y, rect.size.height, rect.size.width, -rect.size.height / 2, -rect.size.width / 2, rect.size.height, rect.size.width);
    var img = new Image();
    img.src = nCanvas.toDataURL();
    return nCanvas;
};


/**
 * a Values object for transform
 * @Class
 * @Construct
 * @param {cc.Point} pos position x and y
 * @param {cc.Point} scale scale x and y
 * @param {Number} rotation
 * @param {cc.Point} skew skew x and y
 * @param {cc.Point} ap anchor point in pixels
 * @param {Boolean} visible
 */
cc.TransformValues = function (pos, scale, rotation, skew, ap, visible) {
    this.pos = pos;		// position x and y
    this.scale = scale;		// scale x and y
    this.rotation = rotation;
    this.skew = skew;		// skew x and y
    this.ap = ap;			// anchor point in pixels
    this.visible = visible;
};

cc.RENDER_IN_SUBPIXEL = function (A) {
    if (cc.SPRITEBATCHNODE_RENDER_SUBPIXEL) {
        return A;
    } else {
        return parseInt(A);
    }
};

/**
 * <p>cc.Sprite is a 2d image ( http://en.wikipedia.org/wiki/Sprite_(computer_graphics) ) <br/>
 *
 * cc.Sprite can be created with an image, or with a sub-rectangle of an image.  <br/>
 *
 * If the parent or any of its ancestors is a cc.SpriteBatchNode then the following features/limitations are valid   <br/>
 *    - Features when the parent is a cc.BatchNode: <br/>
 *        - MUCH faster rendering, specially if the cc.SpriteBatchNode has many children. All the children will be drawn in a single batch.  <br/>
 *
 *    - Limitations   <br/>
 *        - Camera is not supported yet (eg: CCOrbitCamera action doesn't work)  <br/>
 *        - GridBase actions are not supported (eg: CCLens, CCRipple, CCTwirl) <br/>
 *        - The Alias/Antialias property belongs to CCSpriteBatchNode, so you can't individually set the aliased property.  <br/>
 *        - The Blending function property belongs to CCSpriteBatchNode, so you can't individually set the blending function property. <br/>
 *        - Parallax scroller is not supported, but can be simulated with a "proxy" sprite.        <br/>
 *
 *  If the parent is an standard cc.Node, then cc.Sprite behaves like any other cc.Node:      <br/>
 *    - It supports blending functions    <br/>
 *    - It supports aliasing / antialiasing    <br/>
 *    - But the rendering will be slower: 1 draw per children.   <br/>
 *
 * The default anchorPoint in cc.Sprite is (0.5, 0.5). </p>
 * @class
 * @extends cc.Node
 *
 * @example
 * var aSprite = new cc.Sprite();
 * aSprite.initWithFile("HelloHTML5World.png",cc.rect(0,0,480,320));
 */
cc.Sprite = cc.Node.extend(/** @lends cc.Sprite# */{
    RGBAProtocol:true,
    //
    // Data used when the sprite is rendered using a CCSpriteSheet
    //
    _textureAtlas:null,
    _atlasIndex:0,
    _batchNode:null,
    _dirty:null, // Sprite needs to be updated
    _recursiveDirty:null,
    _hasChildren:null,
    _shouldBeHidden:false, //should not be drawn because one of the ancestors is not visible
    _transformToBatch:null,

    //
    // Data used when the sprite is self-rendered
    //
    _blendFunc: {src:cc.BLEND_SRC, dst:cc.BLEND_DST},
    _texture:null,
    _originalTexture:null,
    _color:cc.white(),
    //
    // Shared data
    //
    // texture
    _rect:cc.rect(0, 0, 0, 0),
    _rectRotated:null,

    // Offset Position (used by Zwoptex)
    _offsetPosition:cc.p(0, 0), // absolute
    _unflippedOffsetPositionFromCenter:cc.PointZero(),

    // vertex coords, texture coords and color info
    _quad:cc.V3F_C4B_T2F_QuadZero(),

    // opacity and RGB protocol
    colorUnmodified:null,
    _opacityModifyRGB:null,

    // image is flipped
    _flipX:null,
    _flipY:null,

    _opacity:255,

    /**
     * Constructor
     * @param {String|cc.SpriteFrame|cc.SpriteBatchNode|HTMLImageElement|cc.Texture2D} fileName sprite construct parameter
     */
    ctor:function (fileName) {
        this._super();
        this._shouldBeHidden = false;
        this._offsetPosition = cc.p(0, 0);
        this._unflippedOffsetPositionFromCenter = cc.p(0, 0);

        if (fileName) {
            if (typeof(fileName) == "string") {
                var frame = cc.SpriteFrameCache.getInstance().getSpriteFrame(fileName);
                this.initWithSpriteFrame(frame);
            } else if (typeof(fileName) == "object") {
                if (fileName instanceof cc.SpriteFrame) {
                    this.initWithSpriteFrame(fileName);
                } else if (fileName instanceof cc.SpriteBatchNode) {
                    if (arguments.length > 1) {
                        var rect = arguments[1];
                        if (rect instanceof cc.Rect) {
                            this.initWithBatchNode(fileName, rect);
                        }
                    }
                } else if ((fileName instanceof HTMLImageElement) || (fileName instanceof HTMLCanvasElement)) {
                    this.initWithTexture(fileName)
                } else if (fileName instanceof cc.Texture2D) {
                    this.initWithTexture(fileName)
                }
            }
        }
    },

    /**
     * whether or not the Sprite needs to be updated in the Atlas
     * @return {Boolean}
     */
    isDirty:function () {
        return this._dirty;
    },

    /**
     * make the Sprite to be updated in the Atlas.
     * @param {Boolean} bDirty
     */
    setDirty:function (bDirty) {
        this._dirty = bDirty;
    },

    /**
     * get the quad (tex coords, vertex coords and color) information
     * @return {cc.V3F_C4B_T2F_Quad}
     */
    getQuad:function () {
        return this._quad;
    },

    /**
     * returns whether or not the texture rectangle is rotated
     * @return {Boolean}
     */
    isTextureRectRotated:function () {
        return this._rectRotated;
    },

    /**
     * Set the index used on the TextureAtlas.
     * @return {Number}
     */
    getAtlasIndex:function () {
        return this._atlasIndex;
    },

    /**
     * Set the index used on the TextureAtlas.
     * @warning Don't modify this value unless you know what you are doing
     * @param {Number} atlasIndex
     */
    setAtlasIndex:function (atlasIndex) {
        this._atlasIndex = atlasIndex;
    },

    /**
     * returns the rect of the cc.Sprite in points
     * @return {cc.Rect}
     */
    getTextureRect:function () {
        r = this._rect;
        return cc.rect(r.origin.x, r.origin.y, r.size.width, r.size.height);
    },

    /**
     * return the TextureAtlas of the cc.Sprite
     * @param {Boolean} pobTextureAtlas
     * @return {cc.TextureAtlas}
     */
    getTextureAtlas:function (pobTextureAtlas) {
        return this._textureAtlas;
    },

    /**
     * set the TextureAtlas of the cc.Sprite
     * @param {cc.TextureAtlas} textureAtlas
     */
    setTextureAtlas:function (textureAtlas) {
        this._textureAtlas = textureAtlas;
    },

    /**
     * return the SpriteBatchNode of the cc.Sprite
     * @return {cc.SpriteBatchNode}
     */
    getSpriteBatchNode:function () {
        return this._batchNode;
    },

    /**
     * set the SpriteBatchNode of the cc.Sprite
     * @param {cc.SpriteBatchNode} spriteBatchNode
     */
    setSpriteBatchNode:function (spriteBatchNode) {
        this._batchNode = spriteBatchNode;
    },

    /**
     * Get offset position of the sprite. Calculated automatically by editors like Zwoptex.
     * @return {cc.Point}
     */
    getOffsetPosition:function () {
        return cc.p(this._offsetPosition.x, this._offsetPosition.y);
    },

    /**
     * conforms to cc.TextureProtocol protocol
     * @return {cc.BlendFunc}
     */
    getBlendFunc:function () {
        return this._blendFunc;
    },

    _isLighterMode:false,
    /**
     * conforms to cc.TextureProtocol protocol
     * @param {Number} src
     * @param {Number} dst
    */
    setBlendFunc:function (src, dst) {
        this._blendFunc = {src:src, dst:dst};

        this._isLighterMode = (this._blendFunc && (this._blendFunc.src == gl.SRC_ALPHA) && (this._blendFunc.dst == gl.ONE));
    },

    /**
     * Initializes a sprite
     * @return {Boolean}
     */
    init:function () {
        this._dirty = this._recursiveDirty = false;

        this._opacityModifyRGB = true;
        this._opacity = 255;
        this._color = cc.white();
        this._colorUnmodified = cc.white();

        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;

        // update texture (calls _updateBlendFunc)
        this.setTexture(null);

        this._flipX = this._flipY = false;

        // default transform anchor: center
        this.setAnchorPoint(cc.p(0.5, 0.5));

        // zwoptex default values
        this._offsetPosition = cc.PointZero();
        this._hasChildren = false;

        // Atlas: Color
        var tmpColor = new cc.Color4B(255, 255, 255, 255);
        this._quad.bl.colors = tmpColor;
        this._quad.br.colors = tmpColor;
        this._quad.tl.colors = tmpColor;
        this._quad.tr.colors = tmpColor;


        // updated in "useSelfRender"
        // Atlas: TexCoords
        this.setTextureRect(cc.RectZero(), false, cc.SizeZero());

        return true;
    },

    /**
     * Initializes a sprite with a texture and a rect in texture
     * @param {cc.Texture2D|HTMLImageElement|HTMLCanvasElement} texture
     * @param {cc.Rect} rect
     * @return {Boolean}
     * @example
     * var img =cc.TextureCache.getInstance().addImage("HelloHTML5World.png");
     * var mySprite = new cc.Sprite();
     * mySprite.initWithTexture(img,cc.rect(0,0,480,320));
     */
    initWithTexture:function (texture, rect, rotated) {
        var argnum = arguments.length;
        if (argnum == 0)
            throw "Sprite.initWithTexture(): Argument must be non-nil ";

        rotated = rotated || false;

        this._batchNode = null;
        //this.setShaderProgram(CCShaderCache::getInstance()->programForKey(kCCShader_PositionTextureColor));

        this._recursiveDirty = false;
        this.setDirty(false);
        this._opacityModifyRGB = true;
        this._opacity = 255;
        this._color = cc.white();
        this._colorUnmodified = cc.white();

        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;

        this._flipX = this._flipY = false;

        // default transform anchor: center
        this.setAnchorPoint(cc.p(0.5, 0.5));

        // zwoptex default values
        this._offsetPosition = cc.p(0, 0);
        this._hasChildren = false;

        // Atlas: Color
        var tmpColor = new cc.Color4B(255, 255, 255, 255);
        this._quad.bl.colors = tmpColor;
        this._quad.br.colors = tmpColor;
        this._quad.tl.colors = tmpColor;
        this._quad.tr.colors = tmpColor;

        if (!rect) {
            rect = cc.rect(0, 0, 0, 0);
            if (texture instanceof cc.Texture2D) {
                rect.size = texture.getContentSize();
            } else if ((texture instanceof HTMLImageElement) || (texture instanceof HTMLCanvasElement))
                rect.size = cc.size(texture.width, texture.height);
        }

        if (cc.renderContextType == cc.CANVAS) {
            this._originalTexture = texture;
        }

        this.setTexture(texture);
        this.setTextureRect(rect, rotated, rect.size);

        // by default use "Self Render".
        // if the sprite is added to a batchnode, then it will automatically switch to "batchnode Render"
        this.setBatchNode(null);
        return true;
    },

    /**
     * Initializes a sprite with a texture's filename and a rect in texture
     * @param {String} filename
     * @param {cc.Rect} rect
     * @return {Boolean}
     * @example
     * var mySprite = new cc.Sprite();
     * mySprite.initWithFile("HelloHTML5World.png",cc.rect(0,0,480,320));
     */
    initWithFile:function (filename, rect) {
        cc.Assert(filename != null, "Sprite#initWithFile():Invalid filename for sprite");
        var selfPointer = this;

        var texture = cc.TextureCache.getInstance().textureForKey(filename);
        if (!texture) {
            //texture = cc.TextureCache.getInstance().addImage(filename);
            this._isVisible = false;
            var loadImg = new Image();
            loadImg.addEventListener("load", function () {
                if (!rect) {
                    rect = cc.rect(0, 0, loadImg.width, loadImg.height);
                }
                selfPointer.initWithTexture(loadImg, rect);
                cc.TextureCache.getInstance().cacheImage(filename, loadImg);
                selfPointer._isVisible = true;
            });
            loadImg.addEventListener("error", function () {
                cc.log("load failure:" + filename);
            });
            loadImg.src = filename;
            return true;
        } else {
            if (texture) {
                if (!rect) {
                    rect = cc.rect(0, 0, 0, 0);
                    if (texture instanceof cc.Texture2D)
                        rect.size = texture.getContentSize();
                    else if ((texture instanceof HTMLImageElement) || (texture instanceof HTMLCanvasElement))
                        rect.size = cc.size(texture.width, texture.height);
                }
                return this.initWithTexture(texture, rect);
            }
        }
        return false;
    },

    /**
     * Initializes a sprite with a sprite frame.
     * @param {cc.SpriteFrame} spriteFrame
     * @return {Boolean}
     * @example
     * var spriteFrame = cc.SpriteFrameCache.getInstance().getSpriteFrame("grossini_dance_01.png");
     * var sprite = new cc.Sprite();
     * sprite.initWithSpriteFrame(spriteFrame);
     */
    initWithSpriteFrame:function (spriteFrame) {
        cc.Assert(spriteFrame != null, "");
        var ret = this.initWithTexture(spriteFrame.getTexture(), spriteFrame.getRect());
        this.setDisplayFrame(spriteFrame);

        return ret;
    },

    /**
     * Initializes a sprite with a sprite frame name. <br/>
     * A cc.SpriteFrame will be fetched from the cc.SpriteFrameCache by name.  <br/>
     * If the cc.SpriteFrame doesn't exist it will raise an exception. <br/>
     * @param {String} spriteFrameName
     * @return {Boolean}
     * @example
     * var sprite = new cc.Sprite();
     * sprite.initWithSpriteFrameName("grossini_dance_01.png");
     */
    initWithSpriteFrameName:function (spriteFrameName) {
        cc.Assert(spriteFrameName != null, "");
        var frame = cc.SpriteFrameCache.getInstance().getSpriteFrame(spriteFrameName);
        return this.initWithSpriteFrame(frame);
    },

    /**
     * tell the sprite to use batch node render.
     * @param {cc.SpriteBatchNode} batchNode
     */
    useBatchNode:function (batchNode) {
        this._textureAtlas = batchNode.getTextureAtlas(); // weak ref
        this._batchNode = batchNode;
    },

    /**
     * updates the texture rect of the CCSprite in points.
     * @param {cc.Rect} rect a rect of texture
     * @param {Boolean} rotated
     * @param {cc.Size} untrimmedSize
     */
    setTextureRect:function (rect, rotated, untrimmedSize) {
        this._rectRotated = rotated || false;
        untrimmedSize = untrimmedSize || rect.size;

        this.setContentSize(untrimmedSize);
        this.setVertexRect(rect);
        this._setTextureCoords(rect);

        var relativeOffset = this._unflippedOffsetPositionFromCenter;

        /* WEBGL Code
         if (this._flipX) {
         //relativeOffset.x = -relativeOffset.x;
         }
         if (this._flipY) {
         //relativeOffset.y = -relativeOffset.y;
         }
         */

        this._offsetPosition.x = relativeOffset.x + (this._contentSize.width - this._rect.size.width) / 2;
        this._offsetPosition.y = relativeOffset.y + (this._contentSize.height - this._rect.size.height) / 2;

        // rendering using batch node
        if (this._batchNode) {
            // update dirty_, don't update recursiveDirty_
            //this.setDirty(true);
            this._dirty = true;
        } else {
            // self rendering

            // Atlas: Vertex
            var x1 = 0 + this._offsetPosition.x;
            var y1 = 0 + this._offsetPosition.y;
            var x2 = x1 + this._rect.size.width;
            var y2 = y1 + this._rect.size.height;

            // Don't update Z.
            this._quad.bl.vertices = cc.vertex3(x1, y1, 0);
            this._quad.br.vertices = cc.vertex3(x2, y1, 0);
            this._quad.tl.vertices = cc.vertex3(x1, y2, 0);
            this._quad.tr.vertices = cc.vertex3(x2, y2, 0);
        }
    },

    /**
     * <p>
     *    set the vertex rect.<br/>
     *    It will be called internally by setTextureRect. Useful if you want to create 2x images from SD images in Retina Display.  <br/>
     *    Do not call it manually. Use setTextureRect instead.  <br/>
     *    (override this method to generate "double scale" sprites)
     * </p>
     * @param rect
     */
    setVertexRect:function (rect) {
        this._rect = rect;
    },

    _setTextureCoords:function (rect) {
        if (cc.renderContextType == cc.WEBGL) {
            rect = cc.RECT_POINTS_TO_PIXELS(rect);

            var tex = this._batchNode ? this._textureAtlas.getTexture() : this._texture;
            if (!tex) {
                return;
            }

            var atlasWidth = tex.getPixelsWide();
            var atlasHeight = tex.getPixelsHigh();

            var left, right, top, bottom;

            if (this._rectRotated) {
                if (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL) {
                    left = (2 * rect.origin.x + 1) / (2 * atlasWidth);
                    right = left + (rect.size.height * 2 - 2) / (2 * atlasWidth);
                    top = (2 * rect.origin.y + 1) / (2 * atlasHeight);
                    bottom = top + (rect.size.width * 2 - 2) / (2 * atlasHeight);
                } else {
                    left = rect.origin.x / atlasWidth;
                    right = (rect.origin.x + rect.size.height) / atlasWidth;
                    top = rect.origin.y / atlasHeight;
                    bottom = (rect.origin.y + rect.size.width) / atlasHeight;
                }// CC_FIX_ARTIFACTS_BY_STRECHING_TEXEL


                if (this._flipX) {
                    cc.SWAP(top, bottom);
                }

                if (this._flipY) {
                    cc.SWAP(left, right);
                }

                this._quad.bl.texCoords.u = left;
                this._quad.bl.texCoords.v = top;
                this._quad.br.texCoords.u = left;
                this._quad.br.texCoords.v = bottom;
                this._quad.tl.texCoords.u = right;
                this._quad.tl.texCoords.v = top;
                this._quad.tr.texCoords.u = right;
                this._quad.tr.texCoords.v = bottom;
            } else {
                if (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL) {
                    left = (2 * rect.origin.x + 1) / (2 * atlasWidth);
                    right = left + (rect.size.width * 2 - 2) / (2 * atlasWidth);
                    top = (2 * rect.origin.y + 1) / (2 * atlasHeight);
                    bottom = top + (rect.size.height * 2 - 2) / (2 * atlasHeight);
                }
                else {
                    left = rect.origin.x / atlasWidth;
                    right = (rect.origin.x + rect.size.width) / atlasWidth;
                    top = rect.origin.y / atlasHeight;
                    bottom = (rect.origin.y + rect.size.height) / atlasHeight;
                } // ! CC_FIX_ARTIFACTS_BY_STRECHING_TEXEL

                if (this._flipX) {
                    cc.SWAP(left, right);
                }

                if (this._flipY) {
                    cc.SWAP(top, bottom);
                }

                this._quad.bl.texCoords.u = left;
                this._quad.bl.texCoords.v = bottom;
                this._quad.br.texCoords.u = right;
                this._quad.br.texCoords.v = bottom;
                this._quad.tl.texCoords.u = left;
                this._quad.tl.texCoords.v = top;
                this._quad.tr.texCoords.u = right;
                this._quad.tr.texCoords.v = top;
            }
        }
    },

    // BatchNode methods
    /**
     * updates the quad according the the rotation, position, scale values.
     */
    updateTransform:function () {
        cc.Assert(this._batchNode, "updateTransform is only valid when cc.Sprite is being rendered using an cc.SpriteBatchNode");

        // recaculate matrix only if it is dirty
        if (this.isDirty()) {

            // If it is not visible, or one of its ancestors is not visible, then do nothing:
            if (!this._isVisible || ( this._parent && this._parent != this._batchNode && this._parent._shouldBeHidden)) {
                this._quad.br.vertices = this._quad.tl.vertices = this._quad.tr.vertices = this._quad.bl.vertices = cc.vertex3(0, 0, 0);
                this._shouldBeHidden = true;
            } else {
                this._shouldBeHidden = false;

                if (!this._parent || this._parent == this._batchNode) {
                    this._transformToBatch = this.nodeToParentTransform();
                } else {
                    cc.Assert(this._parent instanceof cc.Sprite, "Logic error in CCSprite. Parent must be a CCSprite");
                    this._transformToBatch = cc.AffineTransformConcat(this.nodeToParentTransform(), this._parent._transformToBatch);
                }

                //
                // calculate the Quad based on the Affine Matrix
                //
                var size = this._rect.size;

                var x1 = this._offsetPosition.x;
                var y1 = this._offsetPosition.y;

                var x2 = x1 + size.width;
                var y2 = y1 + size.height;
                var x = this._transformToBatch.tx;
                var y = this._transformToBatch.ty;

                var cr = this._transformToBatch.a;
                var sr = this._transformToBatch.b;
                var cr2 = this._transformToBatch.d;
                var sr2 = -this._transformToBatch.c;
                var ax = x1 * cr - y1 * sr2 + x;
                var ay = x1 * sr + y1 * cr2 + y;

                var bx = x2 * cr - y1 * sr2 + x;
                var by = x2 * sr + y1 * cr2 + y;

                var cx = x2 * cr - y2 * sr2 + x;
                var cy = x2 * sr + y2 * cr2 + y;

                var dx = x1 * cr - y2 * sr2 + x;
                var dy = x1 * sr + y2 * cr2 + y;

                this._quad.bl.vertices = cc.vertex3(cc.RENDER_IN_SUBPIXEL(ax), cc.RENDER_IN_SUBPIXEL(ay), this._vertexZ);
                this._quad.br.vertices = cc.vertex3(cc.RENDER_IN_SUBPIXEL(bx), cc.RENDER_IN_SUBPIXEL(by), this._vertexZ);
                this._quad.tl.vertices = cc.vertex3(cc.RENDER_IN_SUBPIXEL(dx), cc.RENDER_IN_SUBPIXEL(dy), this._vertexZ);
                this._quad.tr.vertices = cc.vertex3(cc.RENDER_IN_SUBPIXEL(cx), cc.RENDER_IN_SUBPIXEL(cy), this._vertexZ);
            }

            this._textureAtlas.updateQuad(this._quad, this._atlasIndex);
            this._recursiveDirty = false;
            this.setDirty(false);
        }

        // recursively iterate over children
        if (this._hasChildren) {
            this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.updateTransform);
        }

        if (cc.SPRITE_DEBUG_DRAW) {
            // draw bounding box
            var vertices = [
                cc.p(this._quad.bl.vertices.x, this._quad.bl.vertices.y),
                cc.p(this._quad.br.vertices.x, this._quad.br.vertices.y),
                cc.p(this._quad.tr.vertices.x, this._quad.tr.vertices.y),
                cc.p(this._quad.tl.vertices.x, this._quad.tl.vertices.y)
            ];
            cc.drawingUtil.drawPoly(vertices, 4, true);
        }
    },

    /**
     * <p>Optimization: instead of calling 5 times the parent sprite to obtain: position, scale.x, scale.y, anchorpoint and rotation,<br/>
     * this fuction return the 5 values in 1 single call <p/>
     * @param {cc.TransformValues} tv
     * @return {cc.TransformValues}
     * @private
     */
    //TODO
    _getTransformValues:function (tv) {
        tv.pos = this._position;
        tv.scale.x = this._scaleX;
        tv.scale.y = this._scaleY;
        tv.rotation = this._rotation;
        tv.skew.x = this._skewX;
        tv.skew.y = this._skewY;
        tv.ap = this._anchorPointInPoints;
        tv.visible = this._isVisible;
        return tv
    },

    /**
     * draw sprite to canvas
     * @param {CanvasContext} ctx 2d context of canvas
     */
    draw:function (ctx) {
        //this._super();

        //cc.PROFILER_START_CATEGORY(kCCProfilerCategorySprite, "cc.Sprite - draw");
        var context = ctx || cc.renderContext;
        if (cc.renderContextType == cc.CANVAS) {
            if (this._isLighterMode) {
                context.globalCompositeOperation = 'lighter';
            }

            context.globalAlpha = this._opacity / 255;
            var mpX = 0, mpY = 0;
            if (this._flipX) {
                mpX = 0 | (this._contentSize.width / 2 - this._anchorPointInPoints.x);
                context.translate(mpX, 0);
                context.scale(-1, 1);
            }
            if (this._flipY) {
                mpY = -(0 | (this._contentSize.height / 2 - this._anchorPointInPoints.y));
                context.translate(0, mpY);
                context.scale(1, -1);
            }

            var posX = 0 | ( -this._anchorPointInPoints.x - mpX + this._offsetPosition.x);
            var posY = 0 | ( -this._anchorPointInPoints.y + mpY + this._offsetPosition.y);

            if (this._texture) {
                if (this._texture instanceof HTMLImageElement) {
                    if ((this._contentSize.width == 0) && (this._contentSize.height == 0)) {
                        this.setContentSize(cc.size(this._texture.width, this._texture.height));
                        this._rect.size.width = this._texture.width;
                        this._rect.size.height = this._texture.height;
                        context.drawImage(this._texture, posX, -(posY + this._texture.height));
                    } else {
                        context.drawImage(this._texture,
                            this._rect.origin.x, this._rect.origin.y,
                            this._rect.size.width, this._rect.size.height,
                            posX, -(posY + this._rect.size.height),
                            this._rect.size.width, this._rect.size.height);
                    }
                } else {
                    if ((this._contentSize.width == 0) && (this._contentSize.height == 0)) {
                        this.setContentSize(cc.size(this._texture.width, this._texture.height));
                        this._rect.size.width = this._texture.width;
                        this._rect.size.height = this._texture.height;
                        context.drawImage(this._texture, posX, -(posY + this._texture.height));
                    } else {
                        context.drawImage(this._texture,
                            0, 0,
                            this._rect.size.width, this._rect.size.height,
                            posX, -(posY + this._rect.size.height),
                            this._rect.size.width, this._rect.size.height);
                    }
                }
            } else {
                context.fillStyle = "rgba(" + this._color.r + "," + this._color.g + "," + this._color.b + ",1)";
                context.fillRect(posX, posY, this._contentSize.width, this._contentSize.height);
            }

            if (cc.SPRITE_DEBUG_DRAW == 1) {
                // draw bounding box
                context.strokeStyle = "rgba(0,255,0,1)";
                var vertices1 = [cc.p(posX, posY), cc.p(posX + this._rect.size.width, posY), cc.p(posX + this._rect.size.width, posY + this._rect.size.height),
                    cc.p(posX, posY + this._rect.size.height)];
                cc.drawingUtil.drawPoly(vertices1, 4, true);
            } else if (cc.SPRITE_DEBUG_DRAW == 2) {
                // draw texture box
                context.strokeStyle = "rgba(0,255,0,1)";
                var drawSize = this._rect.size;
                var offsetPix = this.getOffsetPosition();
                var vertices2 = [cc.p(offsetPix.x, offsetPix.y), cc.p(offsetPix.x + drawSize.width, offsetPix.y),
                    cc.p(offsetPix.x + drawSize.width, offsetPix.y + drawSize.height), cc.p(offsetPix.x, offsetPix.y + drawSize.height)];
                cc.drawingUtil.drawPoly(vertices2, 4, true);
            }
        } else {
            //TODO  WebGL Draw of sprite
            cc.Assert(!this._batchNode, "If cc.Sprite is being rendered by cc.SpriteBatchNode, cc.Sprite#draw SHOULD NOT be called");

            cc.NODE_DRAW_SETUP(this);

            //ccGLBlendFunc( m_sBlendFunc.src, m_sBlendFunc.dst );

            if (this._texture) {
                //ccGLBindTexture2D(this._texture.getName());
            } else {
                //ccGLBindTexture2D(0);
            }

            //
            // Attributes
            //
            //ccGLEnableVertexAttribs( kCCVertexAttribFlag_PosColorTex );

            //#define kQuadSize  sizeof(this._quad.bl)
            var offset = this._quad;

            // vertex
            //int diff = offsetof( ccV3F_C4B_T2F, vertices);
            //glVertexAttribPointer(kCCVertexAttrib_Position, 3, GL_FLOAT, GL_FALSE, kQuadSize, (void*) (offset + diff));

            // texCoods
            //diff = offsetof( ccV3F_C4B_T2F, texCoords);
            //glVertexAttribPointer(kCCVertexAttrib_TexCoords, 2, GL_FLOAT, GL_FALSE, kQuadSize, (void*)(offset + diff));

            // color
            //diff = offsetof( ccV3F_C4B_T2F, colors);
            //glVertexAttribPointer(kCCVertexAttrib_Color, 4, GL_UNSIGNED_BYTE, GL_TRUE, kQuadSize, (void*)(offset + diff));

            //glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);

            //CHECK_GL_ERROR_DEBUG();

            if (cc.SPRITE_DEBUG_DRAW == 1) {
                // draw bounding box
                var verticesG1 = [
                    cc.p(this._quad.tl.vertices.x, this._quad.tl.vertices.y),
                    cc.p(this._quad.bl.vertices.x, this._quad.bl.vertices.y),
                    cc.p(this._quad.br.vertices.x, this._quad.br.vertices.y),
                    cc.p(this._quad.tr.vertices.x, this._quad.tr.vertices.y)
                ];
                cc.drawingUtil.drawPoly(verticesG1, 4, true);
            }
            else if (cc.SPRITE_DEBUG_DRAW == 2) {
                // draw texture box
                var drawSizeG2 = this.getTextureRect().size;
                var offsetPixG2 = this.getOffsetPosition();
                var verticesG2 = [cc.p(offsetPixG2.x, offsetPixG2.y), cc.p(offsetPixG2.x + drawSizeG2.width, offsetPixG2.y),
                    cc.p(offsetPixG2.x + drawSizeG2.width, offsetPixG2.y + drawSizeG2.height), cc.p(offsetPixG2.x, offsetPixG2.y + drawSizeG2.height)];
                cc.drawingUtil.drawPoly(verticesG2, 4, true);
            } // CC_SPRITE_DEBUG_DRAW
        }

        //cc.INCREMENT_GL_DRAWS(1);
        cc.g_NumberOfDraws++;

        //CC_PROFILER_STOP_CATEGORY(kCCProfilerCategorySprite, "CCSprite - draw");
    },

    /**
     * Add child to sprite (override cc.Node )
     * @param {cc.Sprite} child
     * @param {Number} zOrder  child's zOrder
     * @param {String} tag child's tag
     * @override
     */
    addChild:function (child, zOrder, tag) {
        var argnum = arguments.length;
        switch (argnum) {
            case 1:
                this._super(child);
                break;
            case 2:
                this._super(child, zOrder);
                break;
            case 3:
                cc.Assert(child != null, "Argument must be non-NULL");
                if (cc.renderContextType == cc.WEBGL) {
                    //TODO
                    if (this._batchNode) {
                        cc.Assert((child instanceof cc.Sprite), "cc.Sprite only supports cc.Sprites as children when using cc.SpriteBatchNode");
                        cc.Assert(child.getTexture().getName() == this._textureAtlas.getTexture().getName(), "");

                        //put it in descendants array of batch node
                        this._batchNode.appendChild(child);
                        if (!this._reorderChildDirty) {
                            this._setReorderChildDirtyRecursively();
                        }
                    }
                }

                //cc.Node already sets isReorderChildDirty_ so this needs to be after batchNode check
                this._super(child, zOrder, tag);
                this._hasChildren = true;
                break;
            default:
                throw "Sprite.addChild():Argument must be non-nil ";
                break;
        }
    },

    sortAllChildren:function () {
        if (this._reorderChildDirty) {
            var j;
            var tempItem = null;
            for (var i = 1; i < this._children.length; i++) {
                tempItem = this._children[i];
                j = i - 1;

                //continue moving element downwards while zOrder is smaller or when zOrder is the same but orderOfArrival is smaller
                while (j >= 0 && ( tempItem.getZOrder() < this._children[j].getZOrder() || ( tempItem.getZOrder() == this._children[j].getZOrder()
                    && tempItem.getOrderOfArrival() < this._children[j].getOrderOfArrival() ) )) {
                    this._children[j + 1] = this._children[j];
                    j = j - 1;
                }

                this._children[j + 1] = tempItem;
            }

            if (this._batchNode) {
                this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.sortAllChildren);
            }
            this._reorderChildDirty = false;
        }
    },

    /**
     * Reorders a child according to a new z value.  (override cc.Node )
     * @param {cc.Node} child
     * @param {Number} zOrder
     * @override
     */
    reorderChild:function (child, zOrder) {
        cc.Assert(child != null, "child is null");
        cc.Assert(this._children.indexOf(child) > -1, "this child is not in children list");

        if (zOrder == child.getZOrder()) {
            return;
        }

        if (this._batchNode && this._reorderChildDirty) {
            this._setReorderChildDirtyRecursively();
            this._batchNode.reorderBatch(true);
        }

        this._super(child, zOrder);
    },

    /**
     * Removes a child from the sprite. (override cc.Node )
     * @param child
     * @param cleanup  whether or not cleanup all running actions
     * @override
     */
    removeChild:function (child, cleanup) {
        if (this._batchNode) {
            this._batchNode.removeSpriteFromAtlas(child);
        }
        this._super(child, cleanup);
    },

    /**
     * Removes all children from the container  (override cc.Node )
     * @param cleanup whether or not cleanup all running actions
     * @override
     */
    removeAllChildrenWithCleanup:function (cleanup) {
        if (this._batchNode) {
            if (this._children != null) {
                for (var i = 0; i < this._children.length; i++) {
                    if (this._children[i] instanceof cc.Sprite) {
                        this._batchNode.removeSpriteFromAtlas(this._children[i]);
                    }
                }
            }
        }

        this._super(cleanup);
        this._hasChildren = false;
    },
//
// CCNode property overloads
//

    /**
     * set Recursively is or isn't Dirty
     * used only when parent is CCSpriteBatchNode
     * @param {Boolean} value
     */
    setDirtyRecursively:function (value) {
        this._recursiveDirty = value;
        this.setDirty(value);
        // recursively set dirty
        if (this._children != null) {
            for (var i = 0; i < this._children.length; i++) {
                if (this._children[i] instanceof cc.Sprite) {
                    this._children[i].setDirtyRecursively(true);
                }
            }
        }
    },

    /**
     * HACK: optimization
     */
    SET_DIRTY_RECURSIVELY:function () {
        if (this._batchNode && !this._recursiveDirty) {
            this._recursiveDirty = true;
            //this.setDirty(true);
            this._dirty = true;
            if (this._hasChildren)
                this.setDirtyRecursively(true);
        }
    },

    /**
     * position setter (override cc.Node )
     * @param {cc.Point} pos
     * @override
     */
    setPosition:function (pos) {
        cc.Node.prototype.setPosition.call(this, pos);
        this.SET_DIRTY_RECURSIVELY();
    },

    /**
     * Rotation setter (override cc.Node )
     * @param {Number} rotation
     * @override
     */
    setRotation:function (rotation) {
        cc.Node.prototype.setRotation.call(this, rotation);
        this.SET_DIRTY_RECURSIVELY();
    },

    /**
     * SkewX setter (override cc.Node )
     * @param {Number} sx SkewX value
     * @override
     */
    setSkewX:function (sx) {
        cc.Node.prototype.setSkewX.call(this, sx);
        this.SET_DIRTY_RECURSIVELY();
    },

    /**
     * SkewY setter (override cc.Node )
     * @param {Number} sy SkewY value
     * @override
     */
    setSkewY:function (sy) {
        cc.Node.prototype.setSkewY.call(this, sy);
        this.SET_DIRTY_RECURSIVELY();
    },

    /**
     * ScaleX setter (override cc.Node )
     * @param {Number} scaleX
     * @override
     */
    setScaleX:function (scaleX) {
        cc.Node.prototype.setScaleX.call(this, scaleX);
        this.SET_DIRTY_RECURSIVELY();
    },

    /**
     * ScaleY setter (override cc.Node )
     * @param {Number} scaleY
     * @override
     */
    setScaleY:function (scaleY) {
        cc.Node.prototype.setScaleY.call(this, scaleY);
        this.SET_DIRTY_RECURSIVELY();
    },

    /**
     * <p>The scale factor of the node. 1.0 is the default scale factor. <br/>
     * It modifies the X and Y scale at the same time. (override cc.Node ) <p/>
     * @param {Number} scale
     * @override
     */
    setScale:function (scale, scaleY) {
        cc.Node.prototype.setScale.call(this, scale, scaleY);
        this.SET_DIRTY_RECURSIVELY();
    },

    /**
     * VertexZ setter (override cc.Node )
     * @param {Number} vertexZ
     * @override
     */
    setVertexZ:function (vertexZ) {
        cc.Node.prototype.setVertexZ.call(this, vertexZ);
        this.SET_DIRTY_RECURSIVELY();
    },

    /**
     * AnchorPoint setter  (override cc.Node )
     * @param {cc.Point} anchor
     * @override
     */
    setAnchorPoint:function (anchor) {
        cc.Node.prototype.setAnchorPoint.call(this, anchor);
        this.SET_DIRTY_RECURSIVELY();
    },

    /**
     * visible setter  (override cc.Node )
     * @param {Boolean} visible
     * @override
     */
    setVisible:function (visible) {
        cc.Node.prototype.setVisible.call(this, visible);
        this.SET_DIRTY_RECURSIVELY();
    },

    /**
     * IsRelativeAnchorPoint setter  (override cc.Node )
     * @param {Boolean} relative
     * @override
     */
    ignoreAnchorPointForPosition:function (relative) {
        cc.Assert(!this._batchNode, "ignoreAnchorPointForPosition is invalid in cc.Sprite");
        this._super(relative);
    },

    /**
     * FlipX value setter  (override cc.Node )
     * @param {Boolean} flipX
     */
    setFlipX:function (flipX) {
        if (this._flipX != flipX) {
            //save dirty region when before change
            //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());

            this._flipX = flipX;
            this.setTextureRect(this._rect, this._rectRotated, this._contentSize);

            //save dirty region when after changed
            //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());
            this.setNodeDirty();
        }
    },

    /**
     * FlipY value setter  (override cc.Node )
     * @param {Boolean} flipY
     */
    setFlipY:function (flipY) {
        if (this._flipY != flipY) {
            //save dirty region when before change
            //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());

            this._flipY = flipY;
            //this.setTextureRect(this._rect, this._rectRotated, this._contentSize);

            //save dirty region when after changed
            //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());
            this.setNodeDirty();
        }
    },

    /**
     * <p>whether or not the sprite is flipped horizontally.<br/>
     * It only flips the texture of the sprite, and not the texture of the sprite's children. <br/>
     * Also, flipping the texture doesn't alter the anchorPoint.<br/>
     * If you want to flip the anchorPoint too, and/or to flip the children too use:<br/>
     *      sprite->setScaleX(sprite->getScaleX() * -1);  <p/>
     * @return {Boolean}
     */
    isFlipX:function () {
        return this._flipX;
    },

    /**
     * <p>whether or not the sprite is flipped vertically.<br/>
     * It only flips the texture of the sprite, and not the texture of the sprite's children.<br/>
     * Also, flipping the texture doesn't alter the anchorPoint.<br/>
     * If you want to flip the anchorPoint too, and/or to flip the children too use:<br/>
     *         sprite->setScaleY(sprite->getScaleY() * -1); <p/>
     * @return {Boolean}
     */
    isFlipY:function () {
        return this._flipY;
    },

    //
    // RGBA protocol
    //

    /**
     * Update sprite's color
     */
    updateColor:function () {
        var color4 = new cc.Color4B(this._color.r, this._color.g, this._color.b, this._opacity);

        this._quad.bl.colors = color4;
        this._quad.br.colors = color4;
        this._quad.tl.colors = color4;
        this._quad.tr.colors = color4;

        // renders using Sprite Manager
        //TODO
        if (this._batchNode) {
            if (this._atlasIndex != cc.SPRITE_INDEX_NOT_INITIALIZED) {
                this._textureAtlas.updateQuad(this._quad, this._atlasIndex)
            } else {
                // no need to set it recursively
                // update dirty_, don't update recursiveDirty_
                //this.setDirty(true);
                this._dirty = true;
            }
        }
        // self render
        // do nothing
    },

    /**
     * Return opacity of sprite
     * @return {Number}
     */
    getOpacity:function () {
        return this._opacity;
    },

    /**
     * opacity setter
     * @param {Number} opacity
     */
    setOpacity:function (opacity) {
        this._opacity = opacity;

        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());
        this.setNodeDirty();
        //TODO in canvas
        return;
        // special opacity for premultiplied textures
        if (this._opacityModifyRGB) {
            this.setColor(this._colorUnmodified);
        }

        this.updateColor();
    },

    /**
     * Return color of sprite
     * @return {cc.Color3B}
     */
    getColor:function () {
        if (this._opacityModifyRGB) {
            return new cc.Color3B(this._colorUnmodified);
        }
        return new cc.Color3B(this._color);
    },

    /**
     * color setter
     * @param {cc.Color3B} color3
     */
    setColor:function (color3) {
        if ((this._color.r == color3.r) && (this._color.g == color3.g) && (this._color.b == color3.b)) {
            return;
        }

        this._color = this._colorUnmodified = new cc.Color3B(color3.r, color3.g, color3.b);
        if (this.getTexture()) {
            if (cc.renderContextType == cc.CANVAS) {
                var cacheTextureForColor = cc.TextureCache.getInstance().getTextureColors(this._originalTexture);
                if (cacheTextureForColor) {
                    //generate color texture cache
                    if(this._texture instanceof HTMLCanvasElement){
                        cc.generateTintImage(this.getTexture(), cacheTextureForColor, this._color, this.getTextureRect(),this._texture);
                    } else {
                        var colorTexture = cc.generateTintImage(this.getTexture(), cacheTextureForColor, this._color, this.getTextureRect());
                        this.setTexture(colorTexture);
                    }
                }
            }
        }
        /*
         if (this._opacityModifyRGB) {
         this._color.r = Math.round(color3.r * this._opacity / 255);
         this._color.g = Math.round(color3.g * this._opacity / 255);
         this._color.b = Math.round(color3.b * this._opacity / 255);
         }
         */
        this.updateColor();
        //save dirty region when after changed
        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());

        this.setNodeDirty();
    },

    // RGBAProtocol

    /**
     * opacity: conforms to CCRGBAProtocol protocol
     * @param {Boolean} value
     */
    setOpacityModifyRGB:function (value) {
        var oldColor = this._color;
        this._opacityModifyRGB = value;
        this._color = oldColor;
    },

    /**
     * return IsOpacityModifyRGB value
     * @return {Boolean}
     */
    isOpacityModifyRGB:function () {
        return this._opacityModifyRGB;
    },

    // Frames
    /**
     * Sets a new display frame to the cc.Sprite.
     * @param {cc.SpriteFrame} newFrame
     */
    setDisplayFrame:function (newFrame) {
        this.setNodeDirty();
        this._unflippedOffsetPositionFromCenter = newFrame.getOffset();
        var pNewTexture = newFrame.getTexture();
        // update texture before updating texture rect
        if (pNewTexture != this._texture) {
            this.setTexture(pNewTexture);
        }
        // update rect
        this._rectRotated = newFrame.isRotated();
        //if (this._rectRotated)
        //    this.setRotation(-90);
        this.setTextureRect(newFrame.getRect(), this._rectRotated, newFrame.getOriginalSize());
        //save dirty region when after changed
        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());
    },

    // Animation

    /**
     * changes the display frame with animation name and index.<br/>
     * The animation name will be get from the CCAnimationCache
     * @param animationName
     * @param frameIndex
     */
    setDisplayFrameWithAnimationName:function (animationName, frameIndex) {
        cc.Assert(animationName, "cc.Sprite#setDisplayFrameWithAnimationName. animationName must not be null");
        var cache = cc.AnimationCache.getInstance().getAnimation(animationName);
        cc.Assert(cache, "cc.Sprite#setDisplayFrameWithAnimationName: Frame not found");
        var animFrame = cache.getFrames()[frameIndex];
        cc.Assert(animFrame, "cc.Sprite#setDisplayFrame. Invalid frame");
        this.setDisplayFrame(animFrame.getSpriteFrame());
    },

    /**
     * Returns whether or not a cc.SpriteFrame is being displayed
     * @param {cc.SpriteFrame} frame
     * @return {Boolean}
     */
    isFrameDisplayed:function (frame) {
        if (cc.renderContextType == cc.CANVAS) {
            if (frame.getTexture() != this._texture)
                return false;
            return cc.Rect.CCRectEqualToRect(frame.getRect(), this._rect);
        } else {
            return (cc.Rect.CCRectEqualToRect(frame.getRect(), this._rect) && frame.getTexture().getName() == this._texture.getName()
                && cc.Point.CCPointEqualToPoint(frame.getOffset(), this._unflippedOffsetPositionFromCenter));
        }
    },

    /**
     * Returns the current displayed frame.
     * @return {cc.SpriteFrame}
     */
    displayFrame:function () {
        if (cc.renderContextType == cc.CANVAS) {
            return cc.SpriteFrame._frameWithTextureForCanvas(this._texture,
                cc.RECT_POINTS_TO_PIXELS(this._rect),
                this._rectRotated,
                this._unflippedOffsetPositionFromCenter,
                cc.SIZE_POINTS_TO_PIXELS(this._contentSize));
        } else {
            return cc.SpriteFrame.createWithTexture(this._texture,
                cc.RECT_POINTS_TO_PIXELS(this._rect),
                this._rectRotated,
                this._unflippedOffsetPositionFromCenter,
                cc.SIZE_POINTS_TO_PIXELS(this._contentSize));
        }
    },

    getBatchNode:function () {
        return this._batchNode;
    },

    setBatchNode:function (spriteBatchNode) {
        this._batchNode = spriteBatchNode; // weak reference

        // self render
        if (!this._batchNode) {
            this._atlasIndex = cc.SPRITE_INDEX_NOT_INITIALIZED;
            this.setTextureAtlas(null);
            this._recursiveDirty = false;
            this.setDirty(false);

            var x1 = this._offsetPosition.x;
            var y1 = this._offsetPosition.y;
            var x2 = x1 + this._rect.size.width;
            var y2 = y1 + this._rect.size.height;
            this._quad.bl.vertices = cc.vertex3(x1, y1, 0);
            this._quad.br.vertices = cc.vertex3(x2, y1, 0);
            this._quad.tl.vertices = cc.vertex3(x1, y2, 0);
            this._quad.tr.vertices = cc.vertex3(x2, y2, 0);

        } else {
            // using batch
            this._transformToBatch = cc.AffineTransformIdentity();
            this.setTextureAtlas(this._batchNode.getTextureAtlas()); // weak ref
        }
    },

    // Texture protocol
    _updateBlendFunc:function () {
        if (cc.renderContextType == cc.WEBGL) {
            //TODO
            cc.Assert(!this._batchNode, "cc.Sprite: _updateBlendFunc doesn't work when the sprite is rendered using a cc.SpriteSheet");
            // it's possible to have an untextured sprite
            if (!this._texture || !this._texture.hasPremultipliedAlpha()) {
                this._blendFunc.src = gl.SRC_ALPHA;
                this._blendFunc.dst = gl.ONE_MINUS_SRC_ALPHA;
                this.setOpacityModifyRGB(false);
            } else {
                this._blendFunc.src = cc.BLEND_SRC;
                this._blendFunc.dst = cc.BLEND_DST;
                this.setOpacityModifyRGB(true);
            }
        }
    },

    _setReorderChildDirtyRecursively:function () {
        //only set parents flag the first time
        if (!this._reorderChildDirty) {
            this._reorderChildDirty = true;
            var pNode = this._parent;
            while (pNode && pNode != this._batchNode) {
                pNode._setReorderChildDirtyRecursively();
                pNode = pNode.getParent();
            }
        }
    },

    // CCTextureProtocol
    /**
     * Texture of sprite setter
     * @param {HTMLImageElement|HTMLCanvasElement|cc.Texture2D} texture
     */
    setTexture:function (texture) {
        // CCSprite: setTexture doesn't work when the sprite is rendered using a CCSpriteSheet
        cc.Assert(!texture || texture instanceof cc.Texture2D || texture instanceof HTMLImageElement
            || texture instanceof HTMLCanvasElement, "setTexture expects a CCTexture2D. Invalid argument");

        if (cc.renderContextType != cc.CANVAS) {
            //TODO
            cc.Assert(!this._batchNode, "cc.Sprite: Batched sprites should use the same texture as the batchnode");

            if (!this._batchNode && this._texture != texture) {
                this._texture = texture;
                this._updateBlendFunc();
            }
        } else {
            if (this._texture != texture) {
                this._texture = texture;
                this._updateBlendFunc();
            }
        }
    },

    getTexture:function () {
        return this._texture;
    }
});

/**
 * Create a sprite with texture
 * @constructs
 * @param {HTMLImageElement|HTMLCanvasElement|cc.Texture2D} texture
 * @param {cc.Rect} rect rect of the texture
 * @param {cc.Point} offset offset of the texture
 * @return {cc.Sprite}
 * @example
 * //get an image
 * var img = cc.TextureCache.getInstance().addImage("HelloHTML5World.png");
 *
 * //create a sprite with texture
 * var sprite1 = cc.Sprite.createWithTexture(img);
 *
 * //create a sprite with texture and rect
 * var sprite2 = cc.Sprite.createWithTexture(img, cc.rect(0,0,480,320));
 *
 * //create a sprite with texture and rect and offset
 * var sprite3 = cc.Sprite.createWithTexture(img, cc.rect(0,0,480,320),cc.p(0,0));
 */
cc.Sprite.createWithTexture = function (texture, rect, offset) {
    var argnum = arguments.length;
    var sprite = new cc.Sprite();
    switch (argnum) {
        case 1:
            /** Creates an sprite with a texture.
             The rect used will be the size of the texture.
             The offset will be (0,0).
             */
            if (sprite && sprite.initWithTexture(texture)) {
                return sprite;
            }
            return null;
            break;

        case 2:
            /** Creates an sprite with a texture and a rect.
             The offset will be (0,0).
             */
            if (sprite && sprite.initWithTexture(texture, rect)) {
                return sprite;
            }
            return null;
            break;

        case 3:
            /** Creates an sprite with a texture, a rect and offset. */
                // not implement
            cc.Assert(0, "");
            return null;
            break;

        default:
            throw "Sprite.spriteWithTexture(): Argument must be non-nil ";
            break;
    }
};

/**
 * Create a sprite with filename and rect
 * @constructs
 * @param {String} fileName
 * @param {cc.Rect} rect
 * @return {cc.Sprite}
 * @example
 * //create a sprite with filename
 * var sprite1 = cc.Sprite.create("HelloHTML5World.png");
 *
 * //create a sprite with filename and rect
 * var sprite2 = cc.Sprite.create("HelloHTML5World.png",cc.rect(0,0,480,320));
 */
cc.Sprite.create = function (fileName, rect) {
    var argnum = arguments.length;
    var sprite = new cc.Sprite();
    if (argnum < 2) {
        /** Creates an sprite with an image filename.
         The rect used will be the size of the image.
         The offset will be (0,0).
         */
        if (sprite && sprite.initWithFile(fileName)) {
            return sprite;
        }
        return null;
    } else {
        /** Creates an sprite with an CCBatchNode and a rect
         */
        if (sprite && sprite.initWithFile(fileName, rect)) {
            return sprite;
        }
        return null;
    }
};

/**
 * Creates a sprite with a sprite frame.
 * @param {cc.SpriteFrame|String} spriteFrame or spriteFrame name
 * @return {cc.Sprite}
 * @example
 * //get a sprite frame
 * var spriteFrame = cc.SpriteFrameCache.getInstance().getSpriteFrame("grossini_dance_01.png");
 *
 * //create a sprite with a sprite frame
 * var sprite = cc.Sprite.createWithSpriteFrameName(spriteFrame);
 *
 * //create a sprite with a sprite frame
 * var sprite = cc.Sprite.createWithSpriteFrameName('rossini_dance_01.png');
 */
cc.Sprite.createWithSpriteFrameName = function (spriteFrame) {
    if (typeof(spriteFrame) == 'string') {
        var pFrame = cc.SpriteFrameCache.getInstance().getSpriteFrame(spriteFrame);
        if (pFrame) {
            spriteFrame = pFrame;
        } else {
            cc.log("Invalid spriteFrameName: " + spriteFrame);
            return null;
        }
    }
    var sprite = new cc.Sprite();
    if (sprite && sprite.initWithSpriteFrame(spriteFrame)) {
        return sprite;
    }
    return null;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * <p>
 *    cc.AnimationFrame
 *    A frame of the animation. It contains information like:
 *       - sprite frame name
 *       - # of delay units.
 *       - offset
 * </p>
 * @class
 * @extends cc.Class
 */
cc.AnimationFrame = cc.Class.extend(/** @lends cc.AnimationFrame# */{
    _spriteFrame:null,
    _delayPerUnit:0,
    _userInfo:null,

    ctor:function () {
        this._delayPerUnit = 0;
    },

    copyWithZone:function (pZone) {
        return cc.clone(this);
    },

    copy:function (pZone) {
        var newFrame = new cc.AnimationFrame();
        newFrame.initWithSpriteFrame(this._spriteFrame, this._delayPerUnit, this._userInfo);
        return newFrame;
    },

    /**
     * initializes the animation frame with a spriteframe, number of delay units and a notification user info
     * @param {cc.SpriteFrame} spriteFrame
     * @param {Number} delayUnits
     * @param {object} userInfo
     */
    initWithSpriteFrame:function (spriteFrame, delayUnits, userInfo) {
        this.setSpriteFrame(spriteFrame);
        this.setDelayUnits(delayUnits);
        this.setUserInfo(userInfo);

        return true;
    },

    /**
     * cc.SpriteFrameName to be used
     * @return {cc.SpriteFrame}
     */
    getSpriteFrame:function () {
        return this._spriteFrame;
    },

    /**
     * cc.SpriteFrameName to be used
     * @param {cc.SpriteFrame} spriteFrame
     */
    setSpriteFrame:function (spriteFrame) {
        this._spriteFrame = spriteFrame;
    },

    /**
     * how many units of time the frame takes getter
     * @return {Number}
     */
    getDelayUnits:function () {
        return this._delayPerUnit;
    },

    /**
     *  how many units of time the frame takes setter
     * @param delayUnits
     */
    setDelayUnits:function (delayUnits) {
        this._delayPerUnit = delayUnits;
    },

    /**
     *  <p>A cc.AnimationFrameDisplayedNotification notification will be broadcasted when the frame is displayed with this dictionary as UserInfo.<br/>
     *  If UserInfo is nil, then no notification will be broadcasted. </p>
     * @return {object}
     */
    getUserInfo:function () {
        return this._userInfo;
    },

    /**
     * @param {object} userInfo
     */
    setUserInfo:function (userInfo) {
        this._userInfo = userInfo;
    }
});

/**
 * <p>
 *     A cc.Animation object is used to perform animations on the cc.Sprite objects.<br/>
 *     <br/>
 *      The cc.Animation object contains cc.SpriteFrame objects, and a possible delay between the frames. <br/>
 *      You can animate a cc.Animation object by using the cc.Animate action. Example:  <br/>
 * </p>
 * @class
 * @extends cc.Class
 *
 * @example
 * //create an animation object
 * var animation = cc.Animation.create();
 *
 * //add a sprite frame to this animation
 * animation.addFrameWithFileName("grossini_dance_01.png");
 *
 * //create an animate with this animation
 * var action = cc.Animate.create(animation);
 *
 * //run animate
 * this._grossini.runAction(action);
 */
cc.Animation = cc.Class.extend(/** @lends cc.Animation# */{
    _frames:null,
    _loops:0,
    _restoreOriginalFrame:false,
    _duration:0,
    _delayPerUnit:0,
    _totalDelayUnits:0,

    /**
     * Constructor
     */
    ctor:function () {
        this._frames = [];
    },

    // attributes

    /**
     * return array of CCAnimationFrames
     * @return {Array}
     */
    getFrames:function () {
        return this._frames;
    },

    /**
     * array of CCAnimationFrames setter
     * @param {Array} frames
     */
    setFrames:function (frames) {
        this._frames = frames;
    },

    /**
     * adds a frame to a cc.Animation  The frame will be added with one "delay unit".
     * @param {cc.SpriteFrame} frame
     */
    addSpriteFrame:function (frame) {
        var animFrame = new cc.AnimationFrame();

        animFrame.initWithSpriteFrame(frame, 1, null);
        this._frames.push(animFrame);
        // update duration
        this._totalDelayUnits++;
    },

    /**
     * Adds a frame with an image filename. Internally it will create a cc.SpriteFrame and it will add it. The frame will be added with one "delay unit".
     * @param {String} fileName
     */
    addSpriteFrameWithFileName:function (fileName) {
        var texture = cc.TextureCache.getInstance().addImage(fileName);
        var rect = cc.RectZero();
        if ((texture instanceof HTMLImageElement) || (texture instanceof HTMLCanvasElement)) {
            rect.size = cc.size(texture.width, texture.height);
        } else {
            rect.size = texture.getContentSize();
        }
        var frame = cc.SpriteFrame.createWithTexture(texture, rect);
        this.addSpriteFrame(frame);
    },

    /**
     * Adds a frame with a texture and a rect. Internally it will create a cc.SpriteFrame and it will add it. The frame will be added with one "delay unit".
     * @param {cc.Texture2D} texture
     * @param {cc.Rect} rect
     */
    addSpriteFrameWithTexture:function (texture, rect) {
        var pFrame = cc.SpriteFrame.createWithTexture(texture, rect);
        this.addSpriteFrame(pFrame);
    },

    /**
     * Initializes a cc.Animation with cc.AnimationFrame
     * @param {Array} arrayOfAnimationFrames
     * @param {Number} delayPerUnit
     * @param {Number} loops
     */
    initWithAnimationFrames:function (arrayOfAnimationFrames, delayPerUnit, loops) {
        cc.ArrayVerifyType(arrayOfAnimationFrames, cc.AnimationFrame);

        this._delayPerUnit = delayPerUnit;
        this._loops = loops;

        this.setFrames([]);
        for (var i = 0; i < arrayOfAnimationFrames.length; i++) {
            var animFrame = arrayOfAnimationFrames[i];
            this._frames.push(animFrame);
            this._totalDelayUnits += animFrame.getDelayUnits();
        }

        return true;
    },

    /**
     * @param {cc.Animation} pZone
     */
    copyWithZone:function (pZone) {
        var pCopy = new cc.Animation();
        pCopy.initWithAnimationFrames(this._frames, this._delayPerUnit, this._loops);
        pCopy.setRestoreOriginalFrame(this._restoreOriginalFrame);
        return pCopy;
    },

    copy:function (pZone) {
        return this.copyWithZone(null);
    },

    /**
     * return how many times the animation is going to loop. 0 means animation is not animated. 1, animation is executed one time, ...
     * @return {Number}
     */
    getLoops:function () {
        return this._loops;
    },

    /**
     * set how many times the animation is going to loop. 0 means animation is not animated. 1, animation is executed one time, ...
     * @param {Number} value
     */
    setLoops:function (value) {
        this._loops = value;
    },

    /**
     * whether or not it shall restore the original frame when the animation finishes
     * @param {Boolean} restOrigFrame
     */
    setRestoreOriginalFrame:function (restOrigFrame) {
        this._restoreOriginalFrame = restOrigFrame;
    },

    /**
     * return whether or not it shall restore the original frame when the animation finishes
     * @return {Boolean}
     */
    getRestoreOriginalFrame:function () {
        return this._restoreOriginalFrame;
    },

    /**
     * return duration in seconds of the whole animation. It is the result of totalDelayUnits * delayPerUnit
     * @return {Number}
     */
    getDuration:function () {
        return this._totalDelayUnits * this._delayPerUnit;
    },

    /**
     * return Delay in seconds of the "delay unit"
     * @return {Number}
     */
    getDelayPerUnit:function () {
        return this._delayPerUnit;
    },

    /**
     * set Delay in seconds of the "delay unit"
     * @param {Number} delayPerUnit
     */
    setDelayPerUnit:function (delayPerUnit) {
        this._delayPerUnit = delayPerUnit;
    },

    /**
     * return total Delay units of the cc.Animation.
     * @return {Number}
     */
    getTotalDelayUnits:function () {
        return this._totalDelayUnits;
    },

    /**
     * Initializes a cc.Animation with frames and a delay between frames
     * @param {Array} frames
     * @param {Number} delay
     */
    initWithSpriteFrames:function (frames, delay) {
        cc.ArrayVerifyType(frames, cc.SpriteFrame);
        this._loops = 1;
        delay = delay || 0;
        this._delayPerUnit = delay;

        var tempFrames = [];
        this.setFrames(tempFrames);
        if (frames) {
            for (var i = 0; i < frames.length; i++) {
                var frame = frames[i];
                var animFrame = new cc.AnimationFrame();
                animFrame.initWithSpriteFrame(frame, 1, null);
                this._frames.push(animFrame);
                this._totalDelayUnits++;
            }
        }
        return true;
    }
});

/**
 * Creates an animation.
 * @param {Array} frames
 * @param {Number} delay
 * @param {Number} loops
 * @return {cc.Animation}
 * @example
 * //Creates an animation
 * var animation1 = cc.Animation.create();
 *
 * //Create an animation with sprite frames
 * var animFrames = [];
 * var frame = cache.getSpriteFrame("grossini_dance_01.png");
 * animFrames.push(frame);
 * var animation2 = cc.Animation.create(animFrames);
 *
 * //Create an animation with sprite frames and delay
 * var animation3 = cc.Animation.create(animFrames, 0.2);
 */
cc.Animation.create = function (frames, delay, loops) {
    var len = arguments.length;
    var animation = new cc.Animation();
    if (len == 0) {
        animation.initWithSpriteFrames(null, 0);
    } else if (len == 2) {
        /** with frames and a delay between frames */
        delay = delay || 0;
        animation.initWithSpriteFrames(frames, delay);
    } else if (len == 3) {
        animation.initWithAnimationFrames(frames, delay, loops);
    }
    return animation;
};

/**
 * Creates an animation with an array of cc.AnimationFrame, the delay per units in seconds and and how many times it should be executed.
 * @param {Array} arrayOfAnimationFrameNames
 * @param {Number} delayPerUnit
 * @param {Number} loops
 * @return {cc.Animation}
 */
cc.Animation.createWithAnimationFrames = function (arrayOfAnimationFrameNames, delayPerUnit, loops) {
    var animation = new cc.Animation();
    animation.initWithAnimationFrames(arrayOfAnimationFrameNames, delayPerUnit, loops);
    return animation;
};

/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * <p>
 *     Singleton that manages the Animations.<br/>
 *     It saves in a cache the animations. You should use this class if you want to save your animations in a cache.<br/>
 * </p>
 * @class
 * @extends cc.Class
 *
 * @example
 * cc.AnimationCache.getInstance().addAnimation(animation,"animation1");
 */
cc.AnimationCache = cc.Class.extend(/** @lends cc.AnimationCache# */{

    /**
     * Adds a cc.Animation with a name.
     * @param {cc.Animation} animation
     * @param {String} name
     */
    addAnimation:function (animation, name) {
        this._animations[name] = animation;
    },

    /**
     *  Deletes a cc.Animation from the cache.
     * @param  {String} name
     */
    removeAnimation:function (name) {
        if (!name) {
            return;
        }
        if (this._animations.hasOwnProperty(name)) {
            delete this._animations[name];
        }
    },

    /**
     * <p>
     *     Returns a cc.Animation that was previously added.<br/>
     *      If the name is not found it will return nil.<br/>
     *      You should retain the returned copy if you are going to use it.</br>
     * </p>
     * @param {String} name
     * @return {cc.Animation}
     */
    getAnimation:function (name) {
        return this._animations[name];
    },

    /**
     * <p>
     *     Adds an animation from an NSDictionary<br/>
     *     Make sure that the frames were previously loaded in the cc.SpriteFrameCache.
     * </p>
     * @param {object} dictionary
     */
    addAnimationsWithDictionary:function (dictionary) {
        var animations = dictionary["animations"];
        if (!animations) {
            cc.log("cocos2d: cc.AnimationCache: No animations were found in provided dictionary.");
            return;
        }

        var version = 1;
        var properties = dictionary["properties"];
        if (properties) {
            version = (properties["format"] != null) ? parseInt(properties["format"]) : version;
            var spritesheets = properties["spritesheets"];
            for (var i = 0; i < spritesheets.length; i++) {
                cc.SpriteFrameCache.getInstance().addSpriteFrames(spritesheets[i]);
            }
        }

        switch (version) {
            case 1:
                this._parseVersion1(animations);
                break;
            case 2:
                this._parseVersion2(animations);
                break;
            default :
                cc.Assert(false, "Invalid animation format");
                break;
        }
    },

    /**
     * <p>
     *    Adds an animation from a plist file.<br/>
     *    Make sure that the frames were previously loaded in the cc.SpriteFrameCache.
     * </p>
     * @param {String} plist
     */
    addAnimationsWithFile:function (plist) {
        cc.Assert(plist, "Invalid texture file name");

        var path = cc.FileUtils.getInstance().fullPathFromRelativePath(plist);
        var dict = cc.FileUtils.getInstance().dictionaryWithContentsOfFileThreadSafe(path);

        cc.Assert(dict, "cc.AnimationCache: File could not be found");

        this.addAnimationsWithDictionary(dict);
    },

    _parseVersion1:function (animations) {
        var frameCache = cc.SpriteFrameCache.getInstance();

        for (var key in animations) {
            var animationDict = animations[key];
            var frameNames = animationDict["frames"];
            var delay = parseFloat(animationDict["delay"]) || 0;
            var animation = null;
            if (!frameNames) {
                cc.log("cocos2d: cc.AnimationCache: Animation '" + key + "' found in dictionary without any frames - cannot add to animation cache.");
                continue;
            }

            var frames = [];
            for (var i = 0; i < frameNames.length; i++) {
                var spriteFrame = frameCache.getSpriteFrame(frameNames[i]);
                if (!spriteFrame) {
                    cc.log("cocos2d: cc.AnimationCache: Animation '" + key + "' refers to frame '" + frameNames[i]
                        + "' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.");
                    continue;
                }
                var animFrame = new cc.AnimationFrame();
                animFrame.initWithSpriteFrame(spriteFrame, 1, null);
                frames.push(animFrame);
            }

            if (frames.length == 0) {
                cc.log("cocos2d: cc.AnimationCache: None of the frames for animation '" + key
                    + "' were found in the cc.SpriteFrameCache. Animation is not being added to the Animation Cache.");
                continue;
            } else if (frames.length != frameNames.length) {
                cc.log("cocos2d: cc.AnimationCache: An animation in your dictionary refers to a frame which is not in the cc.SpriteFrameCache." +
                    " Some or all of the frames for the animation '" + key + "' may be missing.");
            }
            animation = cc.Animation.createWithAnimationFrames(frames, delay, 1);
            cc.AnimationCache.getInstance().addAnimation(animation, key);
        }
    },

    _parseVersion2:function (animations) {
        var frameCache = cc.SpriteFrameCache.getInstance();

        for (var key in animations) {
            var animationDict = animations[key];
            var loops = parseInt(animationDict["loops"]) || 0;
            var restoreOriginalFrame = (animationDict["restoreOriginalFrame"] && animationDict["restoreOriginalFrame"] == true) ? true : false;
            var frameArray = animationDict["frames"];

            if (!frameArray) {
                cc.log("cocos2d: CCAnimationCache: Animation '" + key + "' found in dictionary without any frames - cannot add to animation cache.");
                continue;
            }

            //Array of AnimationFrames
            var arr = [];
            for (var i = 0; i < frameArray.length; i++) {
                var entry = frameArray[i];
                var spriteFrameName = entry["spriteframe"];
                var spriteFrame = frameCache.getSpriteFrame(spriteFrameName);
                if (!spriteFrame) {
                    cc.log("cocos2d: cc.AnimationCache: Animation '" + key + "' refers to frame '" + spriteFrameName
                        + "' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.");
                    continue;
                }

                var delayUnits = parseFloat(entry["delayUnits"]) || 0;
                var userInfo = entry["notification"];
                var animFrame = new cc.AnimationFrame();
                animFrame.initWithSpriteFrame(spriteFrame, delayUnits, userInfo);
                arr.push(animFrame);
            }

            var delayPerUnit = parseFloat(animationDict["delayPerUnit"]) || 0;
            var animation = new cc.Animation();
            animation.initWithAnimationFrames(arr, delayPerUnit, loops);
            animation.setRestoreOriginalFrame(restoreOriginalFrame);
            cc.AnimationCache.getInstance().addAnimation(animation, key);
        }
    },

    /**
     * initialize cc.AnimationCache
     * @return {Boolean}
     */
    init:function () {
        this._animations = {};
        return true;
    },

    _animations:null
});

/**
 * Purges the cache. It releases all the cc.Animation objects and the shared instance.
 */
cc.AnimationCache.purgeSharedAnimationCache = function () {
    if (cc.s_sharedAnimationCache) {
        cc.s_sharedAnimationCache._animations = null;
        cc.s_sharedAnimationCache = null;
    }
};

/**
 * Retruns ths shared instance of the Animation cache
 * @return {cc.AnimationCache}
 */
cc.AnimationCache.getInstance = function () {
    if (cc.s_sharedAnimationCache == null) {
        cc.s_sharedAnimationCache = new cc.AnimationCache();
        cc.s_sharedAnimationCache.init();
    }
    return cc.s_sharedAnimationCache;
};

cc.s_sharedAnimationCache = null;
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * <p>
 *    A cc.SpriteFrame has:<br/>
 *      - texture: A cc.Texture2D that will be used by the cc.Sprite<br/>
 *      - rectangle: A rectangle of the texture<br/>
 *    <br/>
 *    You can modify the frame of a cc.Sprite by doing:<br/>
 * </p>
 * @class
 * @extends cc.Class
 *
 * @example
 * var texture = cc.TextureCache.getInstance().addImage(s_dragon_animation);
 * var frame0 = cc.SpriteFrame.createWithTexture(texture, cc.rect(132 * 0, 132 * 0, 132, 132));
 */
cc.SpriteFrame = cc.Class.extend(/** @lends cc.SpriteFrame# */{
    _offset:null,
    _originalSize:null,
    _rectInPixels:null,
    _rotated:null,
    _rect:null,
    _offsetInPixels:null,
    _originalSizeInPixels:null,
    _texture:null,
    _textureFilename:"",

    ctor:function () {
        this._offset = cc.p(0, 0);
        this._offsetInPixels = cc.p(0, 0);
        this._originalSize = cc.size(0, 0);
        this._rectInPixels = cc.rect(0, 0, 0, 0);
        this._rect = cc.rect(0, 0, 0, 0);
        this._originalSizeInPixels = cc.size(0, 0);
        this._textureFilename = "";
    },

    // attributes
    /**
     * @return {cc.Rect}
     */
    getRectInPixels:function () {
        return this._rectInPixels;
    },

    /**
     * @param {cc.Rect} rectInPixels
     */
    setRectInPixels:function (rectInPixels) {
        this._rectInPixels = rectInPixels;
        this._rect = cc.RECT_PIXELS_TO_POINTS(rectInPixels);
    },


    /**
     * <p>
     *     return is rotated of SpriteFrame. <br/>
     * </p>
     * @return {Boolean}
     */
    isRotated:function () {
        return this._rotated;
    },

    /**
     * set SpriteFrame is rotated
     * @param {Boolean} bRotated
     */
    setRotated:function (bRotated) {
        this._rotated = bRotated;
    },

    /**
     * get rect of the frame
     * @return {cc.Rect}
     */
    getRect:function () {
        return this._rect;
    },

    /**
     * set rect of the frame
     * @param {cc.Rect} rect
     */
    setRect:function (rect) {
        this._rect = rect;
        this._rectInPixels = cc.RECT_POINTS_TO_PIXELS(this._rect);
    },

    /**
     * get offset of the frame
     * @return {cc.Point}
     */
    getOffsetInPixels:function () {
        return cc.p(this._offsetInPixels.x, this._offsetInPixels.y);
    },

    /**
     * set offset of the frame
     * @param {cc.Point} offsetInPixels
     */
    setOffsetInPixels:function (offsetInPixels) {
        this._offsetInPixels = offsetInPixels;
        this._offset = cc.POINT_PIXELS_TO_POINTS(this._offsetInPixels);
    },

    /**
     * get original size of the trimmed image
     * @return {cc.Size}
     */
    getOriginalSizeInPixels:function () {
        return this._originalSizeInPixels;
    },

    /**
     * set original size of the trimmed image
     * @param {cc.Size} sizeInPixels
     */
    setOriginalSizeInPixels:function (sizeInPixels) {
        this._originalSizeInPixels = sizeInPixels;
    },

    /**
     * get original size of the trimmed image
     * @return {cc.Size}
     */
    getOriginalSize:function () {
        return cc.size(this._originalSize.width, this._originalSize.height);
    },

    /**
     * set original size of the trimmed image
     * @param {cc.Size} sizeInPixels
     */
    setOriginalSize:function (sizeInPixels) {
        this._originalSize = sizeInPixels;
    },

    /**
     * get texture of the frame
     * @return {cc.Texture2D|HTMLImageElement}
     */
    getTexture:function () {
        if (this._texture) {
            return this._texture;
        }
        if (this._textureFilename != "") {
            return cc.TextureCache.getInstance().addImage(this._textureFilename);
        }
        return null;
    },

    /**
     * set texture of the frame, the texture is retained
     * @param {cc.Texture2D|HTMLImageElement} texture
     */
    setTexture:function (texture) {
        if (this._texture != texture) {
            this._texture = texture;
        }
    },

    /**
     * Offset getter
     * @return {cc.Point}
     */
    getOffset:function () {
        return cc.p(this._offset.x, this._offset.y);
    },

    /**
     * offset setter
     * @param {cc.Point} offsets
     */
    setOffset:function (offsets) {
        this._offset = offsets;
    },

    /**
     * copy a new SpriteFrame
     * @return {cc.SpriteFrame}
     */
    copyWithZone:function () {
        var copy = new cc.SpriteFrame();
        copy.initWithTextureFilename(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels);
        copy.setTexture(this._texture);
        return copy;
    },

    /**
     * Initializes SpriteFrame with Texture, rect, rotated, offset and originalSize in pixels.
     * @param {cc.Texture2D|HTMLImageElement} texture
     * @param {cc.Rect} rect
     * @param {Boolean} rotated
     * @param {cc.Point} offset
     * @param {cc.Size} originalSize
     * @return {Boolean}
     */
    initWithTexture:function (texture, rect, rotated, offset, originalSize) {
        var argnum = arguments.length;
        switch (argnum) {
        /** Initializes a cc.SpriteFrame with a texture, rect in points.
         It is assumed that the frame was not trimmed.
         */
            case 2:
                var rectInPixels = cc.RECT_POINTS_TO_PIXELS(rect);
                return this.initWithTexture(texture, rectInPixels, false, cc.PointZero(), rectInPixels.size);
                break;

        /** Initializes a cc.SpriteFrame with a texture, rect, rotated, offset and originalSize in pixels.
         The originalSize is the size in points of the frame before being trimmed.
         */
            case 5:
                this._texture = texture;
                this._rectInPixels = rect;
                this._rect = cc.RECT_PIXELS_TO_POINTS(rect);
                this._offsetInPixels = offset;
                this._offset = cc.POINT_PIXELS_TO_POINTS(this._offsetInPixels);
                this._originalSizeInPixels = originalSize;
                this._originalSize = cc.SIZE_PIXELS_TO_POINTS(this._originalSizeInPixels);
                this._rotated = rotated;
                return true;
                break;
            default:
                throw "Argument must be non-nil ";
                break;
        }
    },

    /**
     * <p>
     *    Initializes a cc.SpriteFrame with a texture, rect, rotated, offset and originalSize in pixels.<br/>
     *    The originalSize is the size in pixels of the frame before being trimmed.
     * </p>
     * @param {string} filename
     * @param {cc.Rect} rect
     * @param {Boolean} rotated
     * @param {cc.Point} offset
     * @param {cc.Size} originalSize
     */
    initWithTextureFilename:function (filename, rect, rotated, offset, originalSize) {
        var rectInPixels = cc.RECT_POINTS_TO_PIXELS(rect);
        offset = offset || cc.size(0, 0);
        originalSize = originalSize || rectInPixels.size;

        this._texture = null;
        this._textureFilename = filename;
        this._rectInPixels = rectInPixels;
        this._rect = cc.RECT_PIXELS_TO_POINTS(rectInPixels);
        this._rotated = rotated || false;
        this._offsetInPixels = offset;
        this._offset = cc.POINT_PIXELS_TO_POINTS(offset);
        this._originalSizeInPixels = originalSize;
        this._originalSize = cc.SIZE_PIXELS_TO_POINTS(originalSize);

        return true;
    }
});

/**
 * <p>
 *    Create a cc.SpriteFrame with a texture filename, rect, rotated, offset and originalSize in pixels.<br/>
 *    The originalSize is the size in pixels of the frame before being trimmed.
 * </p>
 * @param {string} filename
 * @param {cc.Rect} rect
 * @param {Boolean} rotated
 * @param {cc.Point} offset
 * @param {cc.Size} originalSize
 * @return {cc.SpriteFrame}
 */
cc.SpriteFrame.create = function (filename, rect, rotated, offset, originalSize) {
    var spriteFrame = new cc.SpriteFrame();
    switch (arguments.length) {
        case 2:
            spriteFrame.initWithTextureFilename(filename, rect);
            break;
        case 5:
            spriteFrame.initWithTextureFilename(filename, rect, rotated, offset, originalSize);
            break;
        default:
            throw "Argument must be non-nil ";
            break;
    }
    return spriteFrame;
};

/**
 * Create a cc.SpriteFrame with a texture, rect, rotated, offset and originalSize in pixels.
 * @param {cc.Texture2D|HTMLImageElement} texture
 * @param {cc.Rect} rect
 * @param {Boolean} rotated
 * @param {cc.Point} offset
 * @param {cc.Size} originalSize
 * @return {cc.SpriteFrame}
 * @example
 * //Create a cc.SpriteFrame with a texture, rect in texture.
 * var frame1 = cc.SpriteFrame.createWithTexture("grossini_dance.png",cc.rect(0,0,90,128));
 *
 * //Create a cc.SpriteFrame with a texture, rect, rotated, offset and originalSize in pixels.
 * var frame2 = cc.SpriteFrame.createWithTexture(texture, frameRect, rotated, offset, sourceSize);
 */
cc.SpriteFrame.createWithTexture = function (texture, rect, rotated, offset, originalSize) {
    var argnum = arguments.length;
    var spriteFrame = new cc.SpriteFrame();
    switch (argnum) {
    /** Create a cc.SpriteFrame with a texture, rect in points.
     It is assumed that the frame was not trimmed.
     */
        case 2:
            spriteFrame.initWithTexture(texture, rect);
            break;
    /** Create a cc.SpriteFrame with a texture, rect, rotated, offset and originalSize in pixels.
     The originalSize is the size in points of the frame before being trimmed.
     */
        case 5:
            spriteFrame.initWithTexture(texture, rect, rotated, offset, originalSize);
            break;
        default:
            throw "Argument must be non-nil ";
            break;
    }
    return spriteFrame;
};

cc.SpriteFrame._frameWithTextureForCanvas = function (texture, rect, rotated, offset, originalSize) {
    var spriteFrame = new cc.SpriteFrame();
    spriteFrame._texture = texture;
    spriteFrame._rectInPixels = rect;
    spriteFrame._rect = cc.RECT_PIXELS_TO_POINTS(rect);
    spriteFrame._offsetInPixels = offset;
    spriteFrame._offset = cc.POINT_PIXELS_TO_POINTS(spriteFrame._offsetInPixels);
    spriteFrame._originalSizeInPixels = originalSize;
    spriteFrame._originalSize = cc.SIZE_PIXELS_TO_POINTS(spriteFrame._originalSizeInPixels);
    spriteFrame._rotated = rotated;
    return spriteFrame;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * Singleton that handles the loading of the sprite frames. It saves in a cache the sprite frames.
 * @class
 * @extends cc.Class
 * @example
 * // add SpriteFrames to SpriteFrameCache With File
 * cc.SpriteFrameCache.getInstance().addSpriteFrames(s_grossiniPlist);
 */
cc.SpriteFrameCache = cc.Class.extend(/** @lends cc.SpriteFrameCache# */{
    _spriteFrames:null,
    _spriteFramesAliases:null,
    _loadedFileNames:null,

    /**
     * Constructor
     */
    ctor:function () {
        this._spriteFrames = {};
        this._spriteFramesAliases = {};
        this._loadedFileNames = [];
    },

    /**
     * Adds multiple Sprite Frames with a dictionary. The texture will be associated with the created sprite frames.
     * @param {object} dictionary
     * @param {HTMLImageElement|cc.Texture2D} texture
     */
    _addSpriteFramesWithDictionary:function (dictionary, texture) {
        var metadataDict = dictionary["metadata"];
        var framesDict = dictionary["frames"];
        var format = 0;
        // get the format
        if (metadataDict != null) {
            format = parseInt(this._valueForKey("format", metadataDict));
        }

        // check the format
        cc.Assert(format >= 0 && format <= 3, "format is not supported for cc.SpriteFrameCache addSpriteFramesWithDictionary:textureFilename:");

        for (var key in framesDict) {
            var frameDict = framesDict[key];
            if (frameDict) {
                var spriteFrame = this._spriteFrames[key];
                if (spriteFrame) {
                    continue;
                }

                if (format == 0) {
                    var x = parseFloat(this._valueForKey("x", frameDict));
                    var y = parseFloat(this._valueForKey("y", frameDict));
                    var w = parseFloat(this._valueForKey("width", frameDict));
                    var h = parseFloat(this._valueForKey("height", frameDict));
                    var ox = parseFloat(this._valueForKey("offsetX", frameDict));
                    var oy = parseFloat(this._valueForKey("offsetY", frameDict));
                    var ow = parseInt(this._valueForKey("originalWidth", frameDict));
                    var oh = parseInt(this._valueForKey("originalHeight", frameDict));
                    // check ow/oh
                    if (!ow || !oh) {
                        cc.log("cocos2d: WARNING: originalWidth/Height not found on the cc.SpriteFrame. AnchorPoint won't work as expected. Regenrate the .plist");
                    }
                    // Math.abs ow/oh
                    ow = Math.abs(ow);
                    oh = Math.abs(oh);
                    // create frame
                    spriteFrame = new cc.SpriteFrame();
                    spriteFrame.initWithTexture(texture, cc.rect(x, y, w, h), false, cc.p(ox, oy), cc.size(ow, oh));
                } else if (format == 1 || format == 2) {
                    var frame = cc.RectFromString(this._valueForKey("frame", frameDict));
                    var rotated = false;

                    // rotation
                    if (format == 2) {
                        rotated = this._valueForKey("rotated", frameDict) == "true";
                    }
                    var offset = cc.PointFromString(this._valueForKey("offset", frameDict));
                    var sourceSize = cc.SizeFromString(this._valueForKey("sourceSize", frameDict));
                    // create frame
                    spriteFrame = new cc.SpriteFrame();
                    spriteFrame.initWithTexture(texture, frame, rotated, offset, sourceSize);
                } else if (format == 3) {
                    // get values
                    var spriteSize, spriteOffset, spriteSourceSize, textureRect, textureRotated;
                    if (frameDict.hasOwnProperty("spriteSize")) {
                        spriteSize = cc.SizeFromString(this._valueForKey("spriteSize", frameDict));
                        spriteOffset = cc.PointFromString(this._valueForKey("spriteOffset", frameDict));
                        spriteSourceSize = cc.SizeFromString(this._valueForKey("spriteSourceSize", frameDict));
                        textureRect = cc.RectFromString(this._valueForKey("textureRect", frameDict));
                        textureRotated = this._valueForKey("textureRotated", frameDict) == "true";
                    } else {
                        spriteSize = cc.RectFromString(this._valueForKey("frame", frameDict));
                        spriteOffset = cc.PointFromString(this._valueForKey("offset", frameDict));
                        spriteSourceSize = cc.SizeFromString(this._valueForKey("sourceSize", frameDict));
                        textureRect = cc.SizeFromString(this._valueForKey("sourceSize", frameDict));
                        textureRotated = this._valueForKey("rotated", frameDict) == "true";
                    }

                    // get aliases
                    var aliases = frameDict["aliases"];
                    var frameKey = key.toString();

                    for (var aliasKey in aliases) {
                        if (this._spriteFramesAliases.hasOwnProperty(aliases[aliasKey])) {
                            cc.log("cocos2d: WARNING: an alias with name " + aliasKey + " already exists");
                        }
                        this._spriteFramesAliases[aliases[aliasKey]] = frameKey;
                    }

                    // create frame
                    spriteFrame = new cc.SpriteFrame();
                    if (frameDict.hasOwnProperty("spriteSize")) {
                        spriteFrame.initWithTexture(texture,
                            cc.rect(textureRect.origin.x, textureRect.origin.y, spriteSize.width, spriteSize.height),
                            textureRotated,
                            spriteOffset,
                            spriteSourceSize);
                    } else {
                        spriteFrame.initWithTexture(texture, spriteSize, textureRotated, spriteOffset, spriteSourceSize);
                    }
                }

                if (spriteFrame.isRotated()) {
                    //clip to canvas
                    var tempTexture = cc.cutRotateImageToCanvas(spriteFrame.getTexture(), spriteFrame.getRect());
                    var rect = spriteFrame.getRect();
                    spriteFrame.setRect(cc.rect(0, 0, rect.size.width, rect.size.height));
                    spriteFrame.setTexture(tempTexture);
                }

                // add sprite frame
                this._spriteFrames[key] = spriteFrame;
            }
        }
    },

    /**
     * Adds multiple Sprite Frames from a json file. A texture will be loaded automatically.
     * @param {object} jsonData
     */
    addSpriteFramesWithJson:function (jsonData) {
        var dict = jsonData;
        var texturePath = "";

        var metadataDict = dict["metadata"];
        if (metadataDict) {
            // try to read  texture file name from meta data
            texturePath = this._valueForKey("textureFileName", metadataDict);
            texturePath = texturePath.toString();
        }

        var texture = cc.TextureCache.getInstance().addImage(texturePath);
        if (texture) {
            this._addSpriteFramesWithDictionary(dict, texture);
        }
        else {
            cc.log("cocos2d: cc.SpriteFrameCache: Couldn't load texture");
        }
    },

    /**
     * <p>
     *   Adds multiple Sprite Frames from a plist file.<br/>
     *   A texture will be loaded automatically. The texture name will composed by replacing the .plist suffix with .png<br/>
     *   If you want to use another texture, you should use the addSpriteFrames:texture method.<br/>
     * </p>
     * @param {String} plist plist filename
     * @param {HTMLImageElement|cc.Texture2D} texture
     * @example
     * // add SpriteFrames to SpriteFrameCache With File
     * cc.SpriteFrameCache.getInstance().addSpriteFrames(s_grossiniPlist);
     */
    addSpriteFrames:function (plist, texture) {
        var dict = cc.FileUtils.getInstance().dictionaryWithContentsOfFileThreadSafe(plist);

        switch (arguments.length) {
            case 1:
                cc.Assert(plist, "plist filename should not be NULL");
                if (!cc.ArrayContainsObject(this._loadedFileNames, plist)) {
                    var texturePath = "";
                    var metadataDict = dict["metadata"];
                    if (metadataDict) {
                        // try to read  texture file name from meta data
                        texturePath = this._valueForKey("textureFileName", metadataDict).toString();
                    }
                    if (texturePath != "") {
                        // build texture path relative to plist file
                        var getIndex = plist.lastIndexOf('/'), pszPath;
                        pszPath = getIndex ? plist.substring(0, getIndex + 1) : "";
                        texturePath = pszPath + texturePath;
                    } else {
                        // build texture path by replacing file extension
                        texturePath = plist;

                        // remove .xxx
                        var startPos = texturePath.lastIndexOf(".", texturePath.length);
                        texturePath = texturePath.substr(0, startPos);

                        // append .png
                        texturePath = texturePath + ".png";
                        cc.log("cocos2d: cc.SpriteFrameCache: Trying to use file " + texturePath.toString() + " as texture");
                    }

                    var getTexture = cc.TextureCache.getInstance().addImage(texturePath);
                    if (getTexture) {
                        this._addSpriteFramesWithDictionary(dict, getTexture);
                    } else {
                        cc.log("cocos2d: cc.SpriteFrameCache: Couldn't load texture");
                    }
                }
                break;
            case 2:
                if ((texture instanceof cc.Texture2D) || (texture instanceof HTMLImageElement) || (texture instanceof HTMLCanvasElement)) {
                    /** Adds multiple Sprite Frames from a plist file. The texture will be associated with the created sprite frames. */
                    this._addSpriteFramesWithDictionary(dict, texture);
                } else {
                    /** Adds multiple Sprite Frames from a plist file. The texture will be associated with the created sprite frames.
                     @since v0.99.5
                     */
                    var textureFileName = texture;
                    cc.Assert(textureFileName, "texture name should not be null");
                    var gTexture = cc.TextureCache.getInstance().addImage(textureFileName);

                    if (gTexture) {
                        this._addSpriteFramesWithDictionary(dict, gTexture);
                    } else {
                        cc.log("cocos2d: cc.SpriteFrameCache: couldn't load texture file. File not found " + textureFileName);
                    }
                }
                break;
            default:
                throw "Argument must be non-nil ";
        }
    },

    /**
     * <p>
     *  Adds an sprite frame with a given name.<br/>
     *  If the name already exists, then the contents of the old name will be replaced with the new one.
     * </p>
     * @param {cc.SpriteFrame} frame
     * @param {String} frameName
     */
    addSpriteFrame:function (frame, frameName) {
        this._spriteFrames[frameName] = frame;
    },

    /**
     * <p>
     *   Purges the dictionary of loaded sprite frames.<br/>
     *   Call this method if you receive the "Memory Warning".<br/>
     *   In the short term: it will free some resources preventing your app from being killed.<br/>
     *   In the medium term: it will allocate more resources.<br/>
     *   In the long term: it will be the same.<br/>
     * </p>
     */
    removeSpriteFrames:function () {
        this._spriteFrames = [];
        this._spriteFramesAliases = [];
        this._loadedFileNames = {};
    },

    /**
     * Deletes an sprite frame from the sprite frame cache.
     * @param {String} name
     */
    removeSpriteFrameByName:function (name) {
        // explicit nil handling
        if (!name) {
            return;
        }

        // Is this an alias ?
        if (this._spriteFramesAliases.hasOwnProperty(name)) {
            delete(this._spriteFramesAliases[name]);
        }
        if (this._spriteFrames.hasOwnProperty(name)) {
            delete(this._spriteFrames[name]);
        }
        // XXX. Since we don't know the .plist file that originated the frame, we must remove all .plist from the cache
        this._loadedFileNames = {};
    },

    /**
     * <p>
     *     Removes multiple Sprite Frames from a plist file.<br/>
     *     Sprite Frames stored in this file will be removed.<br/>
     *     It is convinient to call this method when a specific texture needs to be removed.<br/>
     * </p>
     * @param {String} plist plist filename
     */
    removeSpriteFramesFromFile:function (plist) {
        var path = cc.FileUtils.getInstance().fullPathFromRelativePath(plist);
        var dict = cc.FileUtils.getInstance().dictionaryWithContentsOfFileThreadSafe(path);

        this._removeSpriteFramesFromDictionary(dict);

        //remove it from the cache
        if (cc.ArrayContainsObject(this._loadedFileNames, plist)) {
            cc.ArrayRemoveObject(plist);
        }
    },

    /**
     * Removes multiple Sprite Frames from Dictionary.
     * @param {object} dictionary SpriteFrame of Dictionary
     */
    _removeSpriteFramesFromDictionary:function (dictionary) {
        var framesDict = dictionary["frames"];

        for (var key in framesDict) {
            if (this._spriteFrames.hasOwnProperty(key)) {
                delete(this._spriteFrames[key]);
            }
        }
    },

    /**
     * <p>
     *    Removes all Sprite Frames associated with the specified textures.<br/>
     *    It is convinient to call this method when a specific texture needs to be removed.
     * </p>
     * @param {HTMLImageElement|HTMLCanvasElement|cc.Texture2D} texture
     */
    removeSpriteFramesFromTexture:function (texture) {
        for (var key in this._spriteFrames) {
            var frame = this._spriteFrames[key];
            if (frame && (frame.getTexture() == texture)) {
                delete(this._spriteFrames[key]);
            }
        }
    },

    /**
     * <p>
     *   Returns an Sprite Frame that was previously added.<br/>
     *   If the name is not found it will return nil.<br/>
     *   You should retain the returned copy if you are going to use it.<br/>
     * </p>
     * @param {String} name name of SpriteFrame
     * @return {cc.SpriteFrame}
     * @example
     * //get a SpriteFrame by name
     * var frame = cc.SpriteFrameCache.getInstance().getSpriteFrame("grossini_dance_01.png");
     */
    getSpriteFrame:function (name) {
        var frame;
        if (this._spriteFrames.hasOwnProperty(name)) {
            frame = this._spriteFrames[name];
        }

        if (!frame) {
            // try alias dictionary
            var key;
            if (this._spriteFramesAliases.hasOwnProperty(name)) {
                key = this._spriteFramesAliases[name];
            }
            if (key) {
                if (this._spriteFrames.hasOwnProperty(key.toString())) {
                    frame = this._spriteFrames[key.toString()];
                }
                if (!frame) {
                    cc.log("cocos2d: cc.SpriteFrameCahce: Frame " + name + " not found");
                }
            }
        }
        return frame;
    },

    _valueForKey:function (key, dict) {
        if (dict) {
            if (dict.hasOwnProperty(key)) {
                return dict[key].toString();
            }
        }
        return "";
    }
});

cc.s_sharedSpriteFrameCache = null;

/**
 * Returns the shared instance of the Sprite Frame cache
 * @return {cc.SpriteFrameCache}
 */
cc.SpriteFrameCache.getInstance = function () {
    if (!cc.s_sharedSpriteFrameCache) {
        cc.s_sharedSpriteFrameCache = new cc.SpriteFrameCache();
    }
    return cc.s_sharedSpriteFrameCache;
};

/**
 * Purges the cache. It releases all the Sprite Frames and the retained instance.
 */
cc.SpriteFrameCache.purgeSharedSpriteFrameCache = function () {
    cc.s_sharedSpriteFrameCache = null;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/



/**
 * @constant
 * @type Number
 */
cc.DEFAULT_SPRITE_BATCH_CAPACITY = 29;

/**
 * <p>
 *     In WebGL render mode ,cc.SpriteBatchNode is like a batch node: if it contains children, it will draw them in 1 single OpenGL call<br/>
 *     (often known as "batch draw").<br/>
 *     <br/>
 *     A cc.SpriteBatchNode can reference one and only one texture (one image file, one texture atlas).<br/>
 *     Only the cc.Sprites that are contained in that texture can be added to the cc.SpriteBatchNode.<br/>
 *     All cc.Sprites added to a cc.SpriteBatchNode are drawn in one OpenGL ES draw call. <br/>
 *     If the CCSprites are not added to a CCSpriteBatchNode then an OpenGL ES draw call will be needed for each one, which is less efficient. <br/>
 *     <br/>
 *     Limitations:<br/>
 *       - The only object that is accepted as child (or grandchild, grand-grandchild, etc...) is CCSprite or any subclass of CCSprite. <br/>
 *          eg: particles, labels and layer can't be added to a CCSpriteBatchNode. <br/>
 *       - Either all its children are Aliased or Antialiased. It can't be a mix. <br/>
 *          This is because "alias" is a property of the texture, and all the sprites share the same texture. </br>
 * </p>
 * @class
 * @extends cc.Node
 * @example
 * //create a SpriteBatchNode
 * var parent2 = cc.SpriteBatchNode.create("res/animations/grossini.png", 50);
 */
cc.SpriteBatchNode = cc.Node.extend(/** @lends cc.SpriteBatchNode# */{
    _textureAtlas:new cc.TextureAtlas(),
    _blendFunc:new cc.BlendFunc(0, 0),
    // all descendants: chlidren, gran children, etc...
    _descendants:[],
    _renderTexture:null,
    _isUseCache:false,
    _originalTexture:null,
    /**
     * Constructor
     * @param {String} fileImage
     */
    ctor:function (fileImage) {
        this._super();
        if (fileImage) {
            this.initWithFile(fileImage, cc.DEFAULT_SPRITE_BATCH_CAPACITY);
        }
        this._renderTexture = cc.RenderTexture.create(cc.canvas.width, cc.canvas.height);
        this.setContentSize(cc.size(cc.canvas.width, cc.canvas.height));
    },
    setContentSize:function (size) {
        if (!size) {
            return;
        }

        this._super(size);
        this._renderTexture.setContentSize(size);
    },
    _updateBlendFunc:function () {
        if (!this._textureAtlas.getTexture().hasPremultipliedAlpha()) {
            this._blendFunc.src = gl.SRC_ALPHA;
            this._blendFunc.dst = gl.ONE_MINUS_SRC_ALPHA;
        }
    },

    _updateAtlasIndex:function (sprite, curIndex) {
        var count = 0;
        var pArray = sprite.getChildren();
        if (pArray) {
            count = pArray.length;
        }

        var oldIndex = 0;
        if (count == 0) {
            oldIndex = sprite.getAtlasIndex();
            sprite.setAtlasIndex(curIndex);
            sprite.setOrderOfArrival(0);
            if (oldIndex != curIndex) {
                this._swap(oldIndex, curIndex);
            }
            curIndex++;
        } else {
            var needNewIndex = true;
            if (pArray[0].getZOrder() >= 0) {
                //all children are in front of the parent
                oldIndex = sprite.getAtlasIndex();
                sprite.setAtlasIndex(curIndex);
                sprite.setOrderOfArrival(0);
                if (oldIndex != curIndex) {
                    this._swap(oldIndex, curIndex);
                }
                curIndex++;
                needNewIndex = false;
            }

            for (var i = 0; i < pArray.length; i++) {
                var child = pArray[i];
                if (needNewIndex && child.getZOrder() >= 0) {
                    oldIndex = sprite.getAtlasIndex();
                    sprite.setAtlasIndex(curIndex);
                    sprite.setOrderOfArrival(0);
                    if (oldIndex != curIndex) {
                        this._swap(oldIndex, curIndex);
                    }
                    curIndex++;
                    needNewIndex = false;
                }
                this._updateAtlasIndex(child, curIndex);
            }

            if (needNewIndex) {
                //all children have a zOrder < 0)
                oldIndex = sprite.getAtlasIndex();
                sprite.setAtlasIndex(curIndex);
                sprite.setOrderOfArrival(0);
                if (oldIndex != curIndex) {
                    this._swap(oldIndex, curIndex);
                }
                curIndex++;
            }
        }

        return curIndex;
    },

    _swap:function (oldIndex, newIndex) {
        var quads = this._textureAtlas.getQuads();
        var tempItem = this._descendants[oldIndex];
        var tempIteQuad = quads[oldIndex];

        //update the index of other swapped item
        this._descendants[newIndex].setAtlasIndex(oldIndex);

        this._descendants[oldIndex] = this._descendants[newIndex];
        quads[oldIndex] = quads[newIndex];
        this._descendants[newIndex] = tempItem;
        quads[newIndex] = tempIteQuad;
    },

    // IMPORTANT XXX IMPORTNAT:
    // These 2 methods can't be part of cc.TMXLayer since they call [super add...], and cc.SpriteSheet#add SHALL not be called

    /**
     * <p>
     *   Adds a quad into the texture atlas but it won't be added into the children array.<br/>
     *   This method should be called only when you are dealing with very big AtlasSrite and when most of the cc.Sprite won't be updated.<br/>
     *   For example: a tile map (cc.TMXMap) or a label with lots of characters (BitmapFontAtlas)<br/>
     * </p>
     * @param {cc.Sprite} sprite
     * @param {Number} index
     */
    addQuadFromSprite:function (sprite, index) {
        cc.Assert(sprite != null, "SpriteBatchNode.addQuadFromSprite():Argument must be non-nil");
        cc.Assert((sprite instanceof cc.Sprite), "cc.SpriteBatchNode only supports cc.Sprites as children");

        /*while(index >= this._textureAtlas.getCapacity() || this._textureAtlas.getCapacity() == this._textureAtlas.getTotalQuads()){
         this.increaseAtlasCapacity();
         }*/
        //todo fixed
        //
        // update the quad directly. Don't add the sprite to the scene graph
        //
        sprite.setBatchNode(this);
        sprite.setAtlasIndex(index);

        this._textureAtlas.insertQuad(sprite.getQuad(), index);

        // XXX: updateTransform will update the textureAtlas too using updateQuad.
        // XXX: so, it should be AFTER the insertQuad
        sprite.setDirty(true);
        sprite.updateTransform();

        if (cc.renderContextType == cc.CANVAS) {
            this._children = cc.ArrayAppendObjectToIndex(this._children, sprite, index);
        }
    },

    /**
     * <p>
     *    This is the opposite of "addQuadFromSprite.<br/>
     *    It add the sprite to the children and descendants array, but it doesn't update add it to the texture atlas<br/>
     * </p>
     * @param {cc.Node} child
     * @param {Number} z zOrder
     * @param {Number} aTag
     * @return {cc.SpriteBatchNode}
     */
    addSpriteWithoutQuad:function (child, z, aTag) {
        cc.Assert(child != null, "SpriteBatchNode.addQuadFromSprite():Argument must be non-nil");
        cc.Assert((child instanceof cc.Sprite), "cc.SpriteBatchNode only supports cc.Sprites as children");

        // quad index is Z
        child.setAtlasIndex(z);

        // XXX: optimize with a binary search
        var i = 0;

        if (this._descendants && this._descendants.length > 0) {
            var obj = null;
            for (var index = 0; index < this._descendants.length; index++) {
                obj = this._descendants[index];
                if (obj && (obj.getAtlasIndex() >= z)) {
                    ++i;
                }
            }
        }
        this._descendants = cc.ArrayAppendObjectToIndex(this._descendants, child, i);

        // IMPORTANT: Call super, and not self. Avoid adding it to the texture atlas array
        this.addChild(child, z, aTag);

        //#issue 1262 don't use lazy sorting, tiles are added as quads not as sprites, so sprites need to be added in order
        this.reorderBatch(false);

        return this;
    },

    // property
    /**
     * Return TextureAtlas of cc.SpriteBatchNode
     * @return {cc.TextureAtlas}
     */
    getTextureAtlas:function () {
        return this._textureAtlas;
    },

    /**
     * TextureAtlas of cc.SpriteBatchNode setter
     * @param {cc.TextureAtlas} textureAtlas
     */
    setTextureAtlas:function (textureAtlas) {
        if (textureAtlas != this._textureAtlas) {
            this._textureAtlas = textureAtlas;
        }
    },

    /**
     * Return Descendants of cc.SpriteBatchNode
     * @return {Array}
     */
    getDescendants:function () {
        return  this._descendants;
    },

    /**
     * <p>
     *    initializes a CCSpriteBatchNode with a texture2d and capacity of children.<br/>
     *    The capacity will be increased in 33% in runtime if it run out of space.
     * </p>
     * @param {cc.Texture2D} tex
     * @param {Number} capacity
     * @return {Boolean}
     */
    initWithTexture:function (tex, capacity) {
        this._children = [];
        this._descendants = [];

        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this._textureAtlas = new cc.TextureAtlas();
        capacity = capacity || cc.DEFAULT_SPRITE_BATCH_CAPACITY;

        this._textureAtlas.initWithTexture(tex, capacity);
        if (cc.renderContextType == cc.CANVAS) {
            this._originalTexture = tex;
        }
        if (cc.renderContextType == cc.WEBGL) {
            this._updateBlendFunc();
            //this.setShaderProgram(cc.ShaderCache.getInstance().programForKey(cc.Shader_PositionTextureColor)) ;
        }
        return true;
    },

    /**
     * set this node is dirty ,need redraw
     */
    setNodeDirty:function () {
        this._setNodeDirtyForCache();
        this._isTransformDirty = this._isInverseDirty = true;
        if (cc.NODE_TRANSFORM_USING_AFFINE_MATRIX) {
            this._isTransformGLDirty = true;
        }
    },

    _setNodeDirtyForCache:function () {
        this._isCacheDirty = true;
    },

    /**
     * <p>
     *    initializes a cc.SpriteBatchNode with a file image (.png, .jpeg, .pvr, etc) and a capacity of children.<br/>
     *    The capacity will be increased in 33% in runtime if it run out of space.<br/>
     *    The file will be loaded using the TextureMgr.
     * </p>
     * @param {String} fileImage
     * @param {Number} capacity
     * @return {Boolean}
     */
    initWithFile:function (fileImage, capacity) {
        var texture2D = cc.TextureCache.getInstance().textureForKey(fileImage);
        if (!texture2D)
            texture2D = cc.TextureCache.getInstance().addImage(fileImage);
        return this.initWithTexture(texture2D, capacity);
    },

    init:function () {
        var texture = new cc.Texture2D();
        return this.initWithTexture(texture, 0);
    },

    /**
     * increase Atlas Capacity
     */
    increaseAtlasCapacity:function () {
        // if we're going beyond the current TextureAtlas's capacity,
        // all the previously initialized sprites will need to redo their texture coords
        // this is likely computationally expensive
        var quantity = (this._textureAtlas.getCapacity() + 1) * 4 / 3;

        cc.log("cocos2d: CCSpriteBatchNode: resizing TextureAtlas capacity from " + this._textureAtlas.getCapacity() + " to [" + quantity + "].");

        if (!this._textureAtlas.resizeCapacity(quantity)) {
            // serious problems
            cc.log("cocos2d: WARNING: Not enough memory to resize the atlas");
            cc.Assert(false, "Not enough memory to resize the atla");
        }
    },

    /**
     * removes a child given a certain index. It will also cleanup the running actions depending on the cleanup parameter.
     * @warning Removing a child from a CCSpriteBatchNode is very slow
     * @param {Number} index
     * @param {Boolean} doCleanup
     */
    removeChildAtIndex:function (index, doCleanup) {
        this.removeChild(this._children[index], doCleanup);
    },

    /**
     * add child helper
     * @param {cc.Sprite} sprite
     * @param {Number} index
     */
    insertChild:function (sprite, index) {
        sprite.setBatchNode(this);
        sprite.setAtlasIndex(index);
        sprite.setDirty(true);

        if (this._textureAtlas.getTotalQuads() == this._textureAtlas.getCapacity()) {
            this.increaseAtlasCapacity();
        }

        this._textureAtlas.insertQuad(sprite.getQuad(), index);

        this._descendants = cc.ArrayAppendObjectToIndex(this._descendants, sprite, index);

        // update indices
        var i = index + 1;
        if (this._descendants && this._descendants.length > 0) {
            for (; i < this._descendants.length; i++) {
                this._descendants[i].setAtlasIndex(this._descendants[i].getAtlasIndex() + 1);
            }
        }

        // add children recursively
        var children = sprite.getChildren();
        if (children && children.length > 0) {
            for (i = 0; i < children.length; i++) {
                if (children[i]) {
                    var getIndex = this.atlasIndexForChild(children[i], children[i].getZOrder());
                    this.insertChild(children[i], getIndex);
                }
            }
        }
    },

    /**
     * addChild helper, faster than insertChild
     * @param {cc.Sprite} sprite
     */
    appendChild:function (sprite) {
        this._reorderChildDirty = true;
        sprite.setBatchNode(this);
        sprite.setDirty(true);

        if (this._textureAtlas.getTotalQuads() == this._textureAtlas.getCapacity()) {
            this.increaseAtlasCapacity();
        }

        cc.ArrayAppendObject(this._descendants, sprite);

        var index = this._descendants.length - 1;

        sprite.setAtlasIndex(index);

        this._textureAtlas.insertQuad(sprite.getQuad(), index);

        // add children recursively
        var children = sprite.getChildren();
        for (var i = 0; i < children.length; i++) {
            this.appendChild(children[i]);
        }
    },

    /**
     * remove sprite from TextureAtlas
     * @param {cc.Sprite} sprite
     */
    removeSpriteFromAtlas:function (sprite) {
        // remove from TextureAtlas
        this._textureAtlas.removeQuadAtIndex(sprite.getAtlasIndex());

        // Cleanup sprite. It might be reused (issue #569)
        sprite.setBatchNode(null);

        var index = cc.ArrayGetIndexOfObject(this._descendants, sprite);
        if (index != -1) {
            cc.ArrayRemoveObjectAtIndex(this._descendants, index);

            // update all sprites beyond this one
            var len = this._descendants.length;
            for (; index < len; ++index) {
                var s = this._descendants[index];
                s.setAtlasIndex(s.getAtlasIndex() - 1);
            }
        }

        // remove children recursively
        var children = sprite.getChildren();
        if (children && children.length > 0) {
            for (var i = 0; i < children.length; i++) {
                if (children[i]) {
                    this.removeSpriteFromAtlas(children[i]);
                }
            }
        }
    },

    /**
     * rebuild index in order for child
     * @param {cc.Sprite} pobParent
     * @param {Number} index
     * @return {Number}
     */
    rebuildIndexInOrder:function (pobParent, index) {
        var children = pobParent.getChildren();

        if (children && children.length > 0) {
            for (var i = 0; i < children.length; i++) {
                var obj = children[i];
                if (obj && (obj.getZOrder() < 0)) {
                    index = this.rebuildIndexInOrder(obj, index);
                }
            }
        }

        // ignore self (batch node)
        if (!pobParent.isEqual(this)) {
            pobParent.setAtlasIndex(index);
            index++;
        }

        if (children && children.length > 0) {
            for (i = 0; i < children.length; i++) {
                obj = children[i];
                if (obj && (obj.getZOrder() >= 0)) {
                    index = this.rebuildIndexInOrder(obj, index);
                }
            }
        }

        return index;
    },

    /**
     * get highest atlas index in child
     * @param {cc.Sprite} sprite
     * @return {Number}
     */
    highestAtlasIndexInChild:function (sprite) {
        var children = sprite.getChildren();

        if (!children || children.length == 0) {
            return sprite.getAtlasIndex();
        } else {
            return this.highestAtlasIndexInChild(children.pop());
        }
    },

    /**
     * get lowest atlas index in child
     * @param {cc.Sprite} sprite
     * @return {Number}
     */
    lowestAtlasIndexInChild:function (sprite) {
        var children = sprite.getChildren();

        if (!children || children.length == 0) {
            return sprite.getAtlasIndex();
        } else {
            return this.lowestAtlasIndexInChild(children.pop());
        }
    },

    /**
     * get atlas index for child
     * @param {cc.Sprite} sprite
     * @param {Number} nZ
     * @return {Number}
     */
    atlasIndexForChild:function (sprite, nZ) {
        var brothers = sprite.getParent().getChildren();
        var childIndex = cc.ArrayGetIndexOfObject(brothers, sprite);

        // ignore parent Z if parent is spriteSheet
        var ignoreParent = sprite.getParent() == this;
        var previous = null;
        if (childIndex > 0 && childIndex < cc.UINT_MAX) {
            previous = brothers[childIndex - 1];
        }

        // first child of the sprite sheet
        if (ignoreParent) {
            if (childIndex == 0) {
                return 0;
            }
            return this.highestAtlasIndexInChild(previous) + 1;
        }

        // parent is a CCSprite, so, it must be taken into account
        // first child of an CCSprite ?
        if (childIndex == 0) {
            var p = sprite.getParent();

            // less than parent and brothers
            if (nZ < 0) {
                return p.getAtlasIndex();
            } else {
                return p.getAtlasIndex() + 1;
            }
        } else {
            // previous & sprite belong to the same branch
            if ((previous.getZOrder() < 0 && nZ < 0) || (previous.getZOrder() >= 0 && nZ >= 0)) {
                return this.highestAtlasIndexInChild(previous) + 1;
            }

            // else (previous < 0 and sprite >= 0 )
            var p = sprite.getParent();
            return p.getAtlasIndex() + 1;
        }

        // Should not happen. Error calculating Z on SpriteSheet
        cc.Assert(0, "CCSpriteBatchNode.atlasIndexForChild():should not run here");
        return 0;
    },

    /**
     * Sprites use this to start sortChildren, don't call this manually
     * @param {Boolean} reorder
     */
    reorderBatch:function (reorder) {
        this._reorderChildDirty = reorder;
    },

    // CCTextureProtocol
    /**
     * Return texture of cc.SpriteBatchNode
     * @return {cc.Texture2D}
     */
    getTexture:function () {
        return this._textureAtlas.getTexture();
    },

    /**
     * texture of cc.SpriteBatchNode setter
     * @param {cc.Texture2D} texture
     */
    setTexture:function (texture) {
        this._textureAtlas.setTexture(texture);
        for (var i = 0; i < this._children.length; i++) {
            this._children[i].setTexture(texture);
        }
        //this._updateBlendFunc();
    },

    /**
     * set the source blending function for the texture
     * @param {Number} src 
     * @param {Number} dst
     */
    setBlendFunc:function (src, dst) {
        this._blendFunc = {src:src, dst:dst};
    },

    /**
     * returns the blending function used for the texture
     * @return {cc.BlendFunc}
     */
    getBlendFunc:function () {
        return this._blendFunc;
    },

    /**
     * don't call visit on it's children ( override visit of cc.Node )
     * @override
     * @param {CanvasContext} ctx
     */
    visit:function (ctx) {
        if (cc.renderContextType == cc.CANVAS) {
            var context = ctx || cc.renderContext;
            // quick return if not visible
            if (!this._isVisible) {
                return;
            }
            context.save();
            this.transform(ctx);
            var i;
            if (this._isUseCache) {
                if (this._isCacheDirty) {
                    //add dirty region
                    this._renderTexture.clear();
                    this._renderTexture.context.save();
                    this._renderTexture.context.translate(this._anchorPointInPoints.x, -(this._anchorPointInPoints.y ));
                    if (this._children) {
                        this.sortAllChildren();
                        for (i = 0; i < this._children.length; i++) {
                            if (this._children[i]) {
                                this._children[i].visit(this._renderTexture.context);
                            }
                        }
                    }
                    this._renderTexture.context.restore();
                    this._isCacheDirty = false;
                }
                // draw RenderTexture
                this.draw(ctx);
            } else {
                if (this._children) {
                    this.sortAllChildren();
                    for (i = 0; i < this._children.length; i++) {
                        if (this._children[i]) {
                            this._children[i].visit(context);
                        }
                    }
                }
            }
            context.restore();
        } else {
            //TODO
            //cc.PROFILER_START_CATEGORY(kCCProfilerCategoryBatchSprite, "CCSpriteBatchNode - visit");

            // CAREFUL:
            // This visit is almost identical to CocosNode#visit
            // with the exception that it doesn't call visit on it's children
            //
            // The alternative is to have a void CCSprite#visit, but
            // although this is less mantainable, is faster
            //
            if (!this._isVisible) {
                return;
            }

            //kmGLPushMatrix();

            if (this._grid && this._grid.isActive()) {
                this._grid.beforeDraw();
                this.transformAncestors();
            }

            this.sortAllChildren();
            this.transform();

            this.draw();

            if (this._grid && this._grid.isActive()) {
                this._grid.afterDraw(this);
            }

            //kmGLPopMatrix();
            this.setOrderOfArrival(0);

            //cc.PROFILER_STOP_CATEGORY(kCCProfilerCategoryBatchSprite, "CCSpriteBatchNode - visit");
        }
    },

    /**
     * add child to cc.SpriteBatchNode (override addChild of cc.Node)
     * @override
     * @param {cc.Sprite} child
     * @param {Number} zOrder
     * @param {Number} tag
     */
    addChild:function (child, zOrder, tag) {
        switch (arguments.length) {
            case 1:
                this._super(child);
                break;
            case 2:
                this._super(child, zOrder);
                break;
            case 3:
                cc.Assert(child != null, "SpriteBatchNode.addChild():child should not be null");
                cc.Assert((child instanceof cc.Sprite), "cc.SpriteBatchNode only supports cc.Sprites as children");

                // check CCSprite is using the same texture id
                if (cc.renderContextType != cc.CANVAS) {
                    cc.Assert(child.getTexture().getName() == this._textureAtlas.getTexture().getName(),
                        "SpriteBatchNode.addChild():check cc.Sprite is using the same texture id");
                }
                this._super(child, zOrder, tag);
                this.appendChild(child);
                break;
            case 4:
                if (arguments[3]) {
                    this._super(child, zOrder, tag);
                }
                break;
            default:
                throw "Argument must be non-nil ";
                break;
        }

        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());
        this.setNodeDirty();
    },

    /**
     *  (override reorderChild of cc.Node)
     * @override
     * @param {cc.Sprite} child
     * @param {Number} zOrder
     */
    reorderChild:function (child, zOrder) {
        cc.Assert(child != null, "SpriteBatchNode.addChild():the child should not be null");
        cc.Assert(this._children.indexOf(child) > -1, "SpriteBatchNode.addChild():Child doesn't belong to Sprite");

        if (zOrder == child.getZOrder()) {
            return;
        }

        //save dirty region when before change
        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());

        //set the z-order and sort later
        this._super(child, zOrder);

        //save dirty region when after changed
        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());
        this.setNodeDirty();
    },

    /**
     * remove child from cc.SpriteBatchNode (override removeChild of cc.Node)
     * @param {cc.Sprite} child
     * @param cleanup
     */
    removeChild:function (child, cleanup) {
        // explicit null handling
        if (child == null) {
            return;
        }
        cc.Assert(this._children.indexOf(child) > -1, "SpriteBatchNode.addChild():sprite batch node should contain the child");

        // cleanup before removing
        this.removeSpriteFromAtlas(child);

        this._super(child, cleanup);
    },

    /**
     * <p>Removes all children from the container and do a cleanup all running actions depending on the cleanup parameter. <br/>
     * (override removeAllChildrenWithCleanup of cc.Node)</p>
     * @param {Boolean} cleanup
     */
    removeAllChildrenWithCleanup:function (cleanup) {
        // Invalidate atlas index. issue #569
        // useSelfRender should be performed on all descendants. issue #1216
        var i;
        if (this._descendants && this._descendants.length > 0) {
            for (i = 0; i < this._descendants.length; i++) {
                if (this._descendants[i]) {
                    this._descendants[i].setBatchNode(null);
                }
            }
        }

        this._super(cleanup);
        this._descendants = [];
        this._textureAtlas.removeAllQuads();
    },

    sortAllChildren:function () {
        if (this._reorderChildDirty) {
            var i = 0, j = 0, length = this._children.length;
            //insertion sort
            for (i = 1; i < length; i++) {
                var tempItem = this._children[i];
                j = i - 1;

                //continue moving element downwards while zOrder is smaller or when zOrder is the same but orderOfArrival is smaller
                while (j >= 0 && (tempItem.getZOrder() < this._children[j].getZOrder() ||
                    (tempItem.getZOrder() == this._children[j].getZOrder() && tempItem.getOrderOfArrival() < this._children[j].getOrderOfArrival()))) {
                    this._children[j + 1] = this._children[j];
                    j--;
                }
                this._children[j + 1] = tempItem;
            }

            //sorted now check all children
            if (this._children.length > 0) {
                //first sort all children recursively based on zOrder
                this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.sortAllChildren);

                var index = 0;
                //fast dispatch, give every child a new atlasIndex based on their relative zOrder (keep parent -> child relations intact)
                // and at the same time reorder descedants and the quads to the right index
                if (cc.renderContextType == cc.WEBGL) {
                    for (i = 0; i < this._children.length; i++) {
                        index = this._updateAtlasIndex(this._children[i], index);
                    }
                }
            }

            this._reorderChildDirty = false;
        }
    },

    /**
     * draw cc.SpriteBatchNode (override draw of cc.Node)
     * @param {CanvasContext} ctx
     */
    draw:function (ctx) {
        //cc.PROFILER_START("cc.SpriteBatchNode - draw");
        this._super();

        if (cc.renderContextType == cc.CANVAS) {
            var context = ctx || cc.renderContext;
            //context.globalAlpha = this._opacity / 255;
            var pos = cc.p(0 | ( -this._anchorPointInPoints.x), 0 | ( -this._anchorPointInPoints.y));
            if (this._renderTexture) {
                //direct draw image by canvas drawImage
                context.drawImage(this._renderTexture.getCanvas(), pos.x, -(pos.y + this._renderTexture.getCanvas().height));
            }
        } else {
            // Optimization: Fast Dispatch
            if (this._textureAtlas.getTotalQuads() == 0) {
                return;
            }

            //cc.NODE_DRAW_SETUP();

            this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.updateTransform);

            //ccGLBlendFunc( m_blendFunc.src, m_blendFunc.dst );

            this._textureAtlas.drawQuads();

            //cc.PROFILER_STOP("CCSpriteBatchNode - draw");
        }
    }
});

/**
 * <p>
 *    creates a CCSpriteBatchNode with a file image (.png, .jpeg, .pvr, etc) with a default capacity of 29 children.<br/>
 *    The capacity will be increased in 33% in runtime if it run out of space.<br/>
 *    The file will be loaded using the TextureMgr.<br/>
 * </p>
 * @param {String} fileImage
 * @param {Number} capacity
 * @return {cc.SpriteBatchNode}
 * @example
 * //create a SpriteBatchNode
 * var parent2 = cc.SpriteBatchNode.create("res/animations/grossini.png", 50);
 */
cc.SpriteBatchNode.create = function (fileImage, capacity) {
    if (!capacity) {
        capacity = cc.DEFAULT_SPRITE_BATCH_CAPACITY;
    }

    var batchNode = new cc.SpriteBatchNode();
    batchNode.initWithFile(fileImage, capacity);

    return batchNode;
};

/**
 * <p>
 *   creates a CCSpriteBatchNode with a texture2d and a default capacity of 29 children.<br/>
 *   The capacity will be increased in 33% in runtime if it run out of space.<br/>
 * </p>
 * @param {cc.Texture2D} texture
 * @param {Number} capacity
 * @return {cc.SpriteBatchNode}
 */
cc.SpriteBatchNode.createWithTexture = function (texture, capacity) {
    if (!capacity) {
        capacity = cc.DEFAULT_SPRITE_BATCH_CAPACITY;
    }

    var batchNode = new cc.SpriteBatchNode();
    batchNode.initWithTexture(texture, capacity);

    return batchNode;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * using image file to print text label on the screen, might be a bit slower than cc.Label, similar to cc.LabelBMFont
 * @class
 * @extends cc.AtlasNode
 */
cc.LabelAtlas = cc.AtlasNode.extend(/** @lends cc.LabelAtlas# */{
    /**
     * initializes the cc.LabelAtlas with a string, a char map file(the atlas), the width and height of each element and the starting char of the atlas
     *  It accepts two groups of parameters:
     * a) string, fntFile
     * b) label, textureFilename, width, height, startChar
     * @return {Boolean} returns true on success
     */
    initWithString:function (arg) {
        var label, textureFilename, width, height, startChar;
        if (arg.length == 2) {
            var dict = cc.FileUtils.getInstance().dictionaryWithContentsOfFileThreadSafe(arg[1]);
            cc.Assert(parseInt(dict["version"]) == 1, "Unsupported version. Upgrade cocos2d version");

            label = arg[0].toString();
            textureFilename = cc.FileUtils.getInstance().fullPathFromRelativeFile(dict["textureFilename"], arg[1]);
            width = parseInt(dict["itemWidth"]) / cc.CONTENT_SCALE_FACTOR();
            height = parseInt(dict["itemHeight"]) / cc.CONTENT_SCALE_FACTOR();
            startChar = String.fromCharCode(parseInt(dict["firstChar"]));
        }
        else {
            label = arg[0].toString();
            textureFilename = arg[1];
            width = arg[2];
            height = arg[3];
            startChar = arg[4];
            cc.Assert(label != null, "Label must be non-nil");
        }

        if (this.initWithTileFile(textureFilename, width, height, label.length)) {
            this._mapStartChar = startChar;
            this.setString(label);
            return true;
        }
        return false;
    },

    /**
     *  Atlas generation
     */
    updateAtlasValues:function () {
        var texture = this.getTexture();

        for (var i = 0; i < this._string.length; i++) {
            var a = this._string.charCodeAt(i) - this._mapStartChar.charCodeAt(0);
            var row = parseInt(a % this._itemsPerRow) * cc.CONTENT_SCALE_FACTOR();
            var col = parseInt(a / this._itemsPerRow) * cc.CONTENT_SCALE_FACTOR();

            var rect = cc.rect(row * this._itemWidth, col * this._itemHeight, this._itemWidth, this._itemHeight);
            var c = this._string.charCodeAt(i);
            var fontChar = this.getChildByTag(i);
            if (!fontChar) {
                fontChar = new cc.Sprite();
                if (c == 32) {
                    fontChar.init();
                    fontChar.setTextureRect(cc.rect(0, 0, 10, 10), false, cc.SizeZero());
                }
                else {
                    fontChar.initWithTexture(texture, rect);
                }
                this.addChild(fontChar, 0, i);
            } else {
                if (c == 32) {
                    fontChar.init();
                    fontChar.setTextureRect(cc.rect(0, 0, 10, 10), false, cc.SizeZero());
                }
                else {
                    // reusing fonts
                    fontChar.initWithTexture(texture, rect);
                    // restore to default in case they were modified
                    fontChar.setVisible(true);
                    fontChar.setOpacity(this._opacity);
                }
            }
            fontChar.setPosition(cc.p(i * this._itemWidth + this._itemWidth / 2, this._itemHeight / 2));
        }
    },

    /**
     * set the display string
     * @param {String} label
     */
    setString:function (label) {
        this._string = label;
        var len = label.length;
        this._textureAtlas.resizeCapacity(len);

        var s = new cc.size(len * this._itemWidth, this._itemHeight);
        this.setContentSize(s);

        if (this._children) {
            for (var i = 0; i < this._children.length; i++) {
                var node = this._children[i];
                if (node) {
                    node.setVisible(false);
                }
            }
        }
        this.updateAtlasValues();
    },
    /**
     * @param {cc.Color3B} color3
     */
    setColor:function (color3) {
        this._super(color3);
        this.updateAtlasValues();
    },
    /**
     * return the text of this label
     * @return {String}
     */
    getString:function () {
        return this._string;
    },

    /**
     * draw the label
     */
    draw:function () {
        this._super();
        if (cc.LABELATLAS_DEBUG_DRAW) {
            var s = this.getContentSize();
            var vertices = [cc.p(0, 0), cc.p(s.width, 0),
                cc.p(s.width, s.height), cc.p(0, s.height)];
            cc.drawingUtil.drawPoly(vertices, 4, true);
        }
    },

    // string to render
    _string:null,
    // the first char in the charmap
    _mapStartChar:null
});

/**
 *  It accepts two groups of parameters:
 * a) string, fntFile
 * b) label, textureFilename, width, height, startChar
 * @return {cc.LabelAtlas|Null} returns the LabelAtlas object on success
 * @example
 * //Example
 * //creates the cc.LabelAtlas with a string, a char map file(the atlas), the width and height of each element and the starting char of the atlas
 * var myLabel = cc.LabelAtlas.create('Text to display', 'CharMapfile.png', 12, 20, ' ')
 *
 * //creates the cc.LabelAtlas with a string, a fnt file
 * var myLabel = cc.LabelAtlas.create('Text to display', 'CharMapFile.plist‘);
 */
cc.LabelAtlas.create = function (/* Multi arguments */) {
    var ret = new cc.LabelAtlas();
    if (ret && ret.initWithString(arguments)) {
        return ret;
    }
    return null;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * cc.LabelTTF is a subclass of cc.TextureNode that knows how to render text labels<br/>
 * All features from cc.TextureNode are valid in cc.LabelTTF<br/>
 * cc.LabelTTF objects are slow for js-binding on mobile devices.<br/>
 * Consider using cc.LabelAtlas or cc.LabelBMFont instead.<br/>
 * @class
 * @extends cc.Sprite
 */
cc.LabelTTF = cc.Sprite.extend(/** @lends cc.LabelTTF# */{
    _dimensions:cc.SizeZero(),
    _hAlignment:cc.TEXT_ALIGNMENT_CENTER,
    _vAlignment:cc.VERTICAL_TEXT_ALIGNMENT_TOP,
    _fontName:"Arial",
    _fontSize:0.0,
    _string:"",
    _fontStyleStr:null,
    /**
     * Constructor
     */
    ctor:function () {
        this._super();
        this._color = cc.white();
        this._opacityModifyRGB = false;
        this._fontStyleStr = "";
    },

    init:function (callsuper) {
        if (callsuper) {
            return this._super();
        }
        this.initWithString([" ", this._fontName, this._fontSize]);
    },
    /**
     * Prints out a description of this class
     * @return {String}
     */
    description:function () {
        return "<cc.LabelTTF | FontName =" + this._fontName + " FontSize = " + this._fontSize.toFixed(1) + ">";
    },

    /**
     * changes the string to render
     * @warning Changing the string is as expensive as creating a new cc.LabelTTF. To obtain better performance use cc.LabelAtlas
     * @param {String} string text for the label
     */
    setString:function (string) {
        if (this._string != string) {
            this._string = string;

            // Force update
            if (this._string.length > 0) {
                this._updateTTF();
            }
        }
    },

    /**
     * returns the text of the label
     * @return {String}
     */
    getString:function () {
        return this._string;
    },

    /**
     * return Horizontal Alignment of cc.LabelTTF
     * @return {cc.TEXT_ALIGNMENT_LEFT|cc.TEXT_ALIGNMENT_CENTER|cc.TEXT_ALIGNMENT_RIGHT}
     */
    getHorizontalAlignment:function () {
        return this._hAlignment;
    },

    /**
     * set Horizontal Alignment of cc.LabelTTF
     * @param {cc.TEXT_ALIGNMENT_LEFT|cc.TEXT_ALIGNMENT_CENTER|cc.TEXT_ALIGNMENT_RIGHT} Horizontal Alignment
     */
    setHorizontalAlignment:function (alignment) {
        if (alignment != this._hAlignment) {
            this._hAlignment = alignment;

            // Force update
            if (this._string.length > 0) {
                this._updateTTF();
            }
        }
    },

    /**
     * return Vertical Alignment of cc.LabelTTF
     * @return {cc.VERTICAL_TEXT_ALIGNMENT_TOP|cc.VERTICAL_TEXT_ALIGNMENT_CENTER|cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM}
     */
    getVerticalAlignment:function () {
        return this._vAlignment;
    },

    /**
     * set Vertical Alignment of cc.LabelTTF
     * @param {cc.VERTICAL_TEXT_ALIGNMENT_TOP|cc.VERTICAL_TEXT_ALIGNMENT_CENTER|cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM} verticalAlignment
     */
    setVerticalAlignment:function (verticalAlignment) {
        if (verticalAlignment != this._vAlignment) {
            this._vAlignment = verticalAlignment;

            // Force update
            if (this._string.length > 0) {
                this._updateTTF();
            }
        }
    },

    /**
     * return Dimensions of cc.LabelTTF
     * @return {cc.Size}
     */
    getDimensions:function () {
        return this._dimensions;
    },

    /**
     * set Dimensions of cc.LabelTTF
     * @param {cc.Size} dim
     */
    setDimensions:function (dim) {
        if (dim.width != this._dimensions.width || dim.height != this._dimensions.height) {
            this._dimensions = dim;

            // Force udpate
            if (this._string.length > 0) {
                this._updateTTF();
            }
        }
    },

    /**
     * return font size of cc.LabelTTF
     * @return {Number}
     */
    getFontSize:function () {
        return this._fontSize;
    },

    /**
     * set font size of cc.LabelTTF
     * @param {Number} fontSize
     */
    setFontSize:function (fontSize) {
        if (this._fontSize != fontSize) {
            this._fontSize = fontSize;

            // Force update
            if (this._string.length > 0) {
                this._updateTTF();
            }
        }
    },

    /**
     * return font name of cc.LabelTTF
     * @return {String}
     */
    getFontName:function () {
        return this._fontName;
    },

    /**
     * set font name of cc.LabelTTF
     * @param {String} fontName
     */
    setFontName:function (fontName) {
        if (this._fontName != fontName) {
            this._fontName = new String(fontName);
            // Force update
            if (this._string.length > 0) {
                this._updateTTF();
            }
        }
    },

    /**
     * initializes the cc.LabelTTF with a font name, alignment, dimension and font size
     * @param {String} initialize string
     * @param {String} fontName
     * @param {Number} fontSize
     * @param {cc.Size} dimensions
     * @param {cc.TEXT_ALIGNMENT_LEFT|cc.TEXT_ALIGNMENT_CENTER|cc.TEXT_ALIGNMENT_RIGHT} alignment
     * @return {Boolean} return false on error
     */
    initWithString:function (arg) {
        var strInfo = new String(arg[0]), fontName, fontSize, dimensions, hAlignment, vAlignment;
        cc.Assert(strInfo != null, "cc.LabelTTF.initWithString() label is null");
        if (arg.length == 6) {
            fontName = arg[1];
            fontSize = arg[2];
            dimensions = arg[3];
            hAlignment = arg[4];
            vAlignment = arg[5];
        }
        else if (arg.length == 5) {
            fontName = arg[1];
            fontSize = arg[2];
            dimensions = arg[3];
            hAlignment = arg[4];
            vAlignment = cc.VERTICAL_TEXT_ALIGNMENT_TOP;
        }
        else {
            fontName = arg[1];
            fontSize = arg[2];
            dimensions = cc.size(0, arg[2]);
            hAlignment = cc.TEXT_ALIGNMENT_LEFT;
            vAlignment = cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM;
        }
        if (this.init(true)) {
            this._dimensions = cc.size(dimensions.width, dimensions.height);
            this._fontName = fontName;
            this._hAlignment = hAlignment;
            this._vAlignment = vAlignment;
            this._fontSize = fontSize * cc.CONTENT_SCALE_FACTOR();
            this.setString(strInfo);
            this._fontStyleStr = this._fontSize + "px '" + this._fontName + "'";
            return true;
        }
        return false;
    },
    /**
     * renders the label
     * @param {CanvasContext|Null} ctx
     */
    draw:function (ctx) {
        if (cc.renderContextType == cc.CANVAS) {
            var context = ctx || cc.renderContext;
            if (this._flipX) {
                context.scale(-1, 1);
            }
            if (this._flipY) {
                context.scale(1, -1);
            }
            //this is fillText for canvas
            context.fillStyle = "rgba(" + this._color.r + "," + this._color.g + "," + this._color.b + ", " + this._opacity / 255 + ")";

            if (context.font != this._fontStyleStr)
                context.font = this._fontStyleStr;
            context.textBaseline = "bottom";

            var xOffset = 0, yOffset = 0;
            switch (this._hAlignment) {
                case cc.TEXT_ALIGNMENT_LEFT:
                    context.textAlign = "left";
                    xOffset = 0;
                    break;
                case cc.TEXT_ALIGNMENT_RIGHT:
                    context.textAlign = "right";
                    xOffset = this._dimensions.width;
                    break;
                case cc.TEXT_ALIGNMENT_CENTER:
                    context.textAlign = "center";
                    xOffset = this._dimensions.width / 2;
                    break;
                default:
                    break;
            }

            switch (this._vAlignment) {
                case cc.VERTICAL_TEXT_ALIGNMENT_TOP:
                    context.textBaseline = "top";
                    yOffset = -this._dimensions.height;
                    break;
                case cc.VERTICAL_TEXT_ALIGNMENT_CENTER:
                    context.textBaseline = "middle";
                    yOffset = -this._dimensions.height / 2;
                    break;
                case cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM:
                    context.textBaseline = "bottom";
                    yOffset = 0;
                    break;
                default:
                    break;
            }

            if (((this._contentSize.width > this._dimensions.width) || this._string.indexOf("\n")) && this._dimensions.width !== 0) {
                this._wrapText(context, this._string,
                    -this._dimensions.width * this._anchorPoint.x,
                    this._dimensions.height * this._anchorPoint.y,
                    this._dimensions.width,
                    this._dimensions.height,
                    this._fontSize * 1.2);
            }
            else if (this._dimensions.width == 0) {
                context.fillText(this._string, -this._contentSize.width * this._anchorPoint.x, this._contentSize.height * this._anchorPoint.y);
            }
            else {
                context.fillText(this._string,
                    -this._dimensions.width * this._anchorPoint.x + xOffset,
                    this._dimensions.height * this._anchorPoint.y + yOffset);
            }
            cc.INCREMENT_GL_DRAWS(1);
        }
    },

    _wrapText:function (context, text, x, y, maxWidth, maxHeight, lineHeight) {
        var num = this._lineCount() - 1;
        var xOffset, yOffset;
        switch (this._hAlignment) {
            case cc.TEXT_ALIGNMENT_LEFT:
                context.textAlign = "left";
                xOffset = 0;
                break;
            case cc.TEXT_ALIGNMENT_RIGHT:
                context.textAlign = "right";
                xOffset = maxWidth;
                break;
            default:
                context.textAlign = "center";
                xOffset = maxWidth / 2;
                break;
        }

        switch (this._vAlignment) {
            case cc.VERTICAL_TEXT_ALIGNMENT_TOP:
                context.textBaseline = "top";
                yOffset = -maxHeight;
                break;
            case cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM:
                context.textBaseline = "bottom";
                yOffset = -lineHeight * num;
                break;
            default:
                context.textBaseline = "middle";
                yOffset = -maxHeight / 2 - (lineHeight * num / 2);
                break;
        }

        var tmpWords = text.split("\n");
        for (var j = 0; j < tmpWords.length; j++) {
            var jOffset = j * lineHeight;
            var words = tmpWords[j].split(" ");
            var line = "";

            for (var n = 0; n < words.length; n++) {
                var testLine = line + words[n] + " ";
                var testWidth = context.measureText(testLine).width - context.measureText(" ").width;
                if (testWidth >= maxWidth) {
                    context.fillText(line, x + xOffset, y + yOffset + jOffset);
                    y += lineHeight;
                    line = words[n] + " ";
                }
                else {
                    line = testLine;
                }
                if (n == words.length - 1) {
                    context.fillText(line, x + xOffset, y + yOffset + jOffset);
                }
            }
            //context.fillText(tmpWords[j], x + xOffset, y + yOffset + j * lineHeight);
        }
    },
    _lineCount:function () {
        if (this._dimensions.width == 0) {
            return 1;
        }
        var context = cc.renderContext;
        var words = this._string.split(" ");
        var line = "", num = 0;
        cc.renderContext.save();
        for (var n = 0; n < words.length; n++) {
            var tmpLine = line + words[n] + " ";
            var tmpWidth = context.measureText(tmpLine).width - context.measureText(" ").width;
            if (tmpWidth >= this._dimensions.width) {
                num++;
                line = words[n] + " ";
            }
            else {
                line = tmpLine;
            }
            if (n == words.length - 1) {
                num++;
            }
        }
        cc.renderContext.restore();
        return num;
    },
    _updateTTF:function () {
        cc.renderContext.save();
        this._fontStyleStr = this._fontSize + "px '" + this._fontName + "'";
        cc.renderContext.font = this._fontStyleStr;
        var dim = cc.renderContext.measureText(this._string);
        this.setContentSize(cc.size(dim.width, this._fontSize));
        cc.renderContext.restore();
        this.setNodeDirty();
    }
});

/**
 * creates a cc.LabelTTF from a fontname, alignment, dimension and font size
 * @param {String} label
 * @param {String} fontName
 * @param {Number} fontSize
 * @param {cc.Size} dimensions
 * @param {cc.TEXT_ALIGNMENT_LEFT|cc.TEXT_ALIGNMENT_CENTER|cc.TEXT_ALIGNMENT_RIGHT} alignment
 * @return {cc.LabelTTF|Null}
 * @example
 * // Example
 * var myLabel = cc.LabelTTF.create('label text',  'Times New Roman', 32, cc.size(32,16), cc.TEXT_ALIGNMENT_LEFT);
 */
cc.LabelTTF.create = function (/* Multi arguments */) {
    var ret = new cc.LabelTTF();
    if (ret.initWithString(arguments)) {
        return ret;
    }
    return null;
};

cc.LabelTTF.node = function () {
    return cc.LabelTTF.create();
};

cc.LabelNode = function (pos, text, align) {
    this.pos = pos;
    this.text = text;
    this.align = align;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.

 Use any of these editors to generate BMFonts:
 http://glyphdesigner.71squared.com/ (Commercial, Mac OS X)
 http://www.n4te.com/hiero/hiero.jnlp (Free, Java)
 http://slick.cokeandcode.com/demos/hiero.jnlp (Free, Java)
 http://www.angelcode.com/products/bmfont/ (Free, Windows only)
 ****************************************************************************/
/**
 * @constant
 * @type Number
 */
cc.LabelAutomaticWidth = -1;

cc._KerningHashElement = function (key, amount) {
    this.key = key;   //key for the hash. 16-bit for 1st element, 16-bit for 2nd element
    this.amount = amount;
};

cc._FontDefHashElement = function (key, fontDef) {
    this.key = key || 0;        // key. Font Unicode value
    this.fontDef = fontDef || new cc._BMFontDef();    // font definition
};

cc._BMFontDef = function (charID, rect, xOffset, yOffset, xAdvance) {
    //! ID of the character
    this.charID = charID || 0;
    //! origin and size of the font
    this.rect = rect || cc.rect(0, 0, 0.1, 0.1);
    //! The X amount the image should be offset when drawing the image (in pixels)
    this.xOffset = xOffset || 0;
    //! The Y amount the image should be offset when drawing the image (in pixels)
    this.yOffset = yOffset || 0;
    //! The amount to move the current position after drawing the character (in pixels)
    this.xAdvance = xAdvance || 0;
};

cc._BMFontPadding = function (left, top, right, bottom) {
    /// padding left
    this.left = left || 0;
    /// padding top
    this.top = top || 0;
    /// padding right
    this.right = right || 0;
    /// padding bottom
    this.bottom = bottom || 0;
};

/**
 * cc.BMFontConfiguration has parsed _configuration of the the .fnt file
 * @class
 * @extends cc.Class
 */
cc.BMFontConfiguration = cc.Class.extend(/** @lends cc.BMFontConfiguration# */{
    // XXX: Creating a public interface so that the bitmapFontArray[] is acc.esible
    //@public
    /**
     *  The characters building up the font
     *  @type object
     */
    bitmapFontArray:{},

    /**
     * FNTConfig: Common Height
     * @type Number
     */
    commonHeight:0,

    /**
     *  Padding
     *  @type cc._BMFontPadding
     */
    padding:new cc._BMFontPadding(),

    /**
     * atlas name
     * @type String
     */
    atlasName:"",

    /**
     * values for kerning
     * @type cc._KerningHashElement
     */
    kerningDictionary:{},

    /**
     * values for FontDef
     * @type cc._FontDefHashElement
     */
    fontDefDictionary:null,
    /**
     * Constructor
     */
    ctor:function () {
        this.fontDefDictionary = {};
        this.fontDefDictionary["0"] = new cc._FontDefHashElement();
    },

    /**
     * Description of BMFontConfiguration
     * @return {String}
     */
    description:function () {
        return "<cc.BMFontConfiguration | Kernings:" + this.kerningDictionary + " | Image = " + this.atlasName.toString() + ">";
    },

    /**
     * @return {String}
     */
    getAtlasName:function () {
        return this.atlasName;
    },

    /**
     * @param {String} atlasName
     */
    setAtlasName:function (atlasName) {
        this.atlasName = atlasName;
    },

    /**
     * initializes a BitmapFontConfiguration with a FNT file
     * @param {String} FNT file path
     * @return {Boolean}
     */
    initWithFNTfile:function (FNTfile) {
        cc.Assert(FNTfile != null && FNTfile.length != 0, "");
        this._parseConfigFile(FNTfile);
        return true;
    },

    _parseConfigFile:function (controlFile) {
        var data = cc.SAXParser.shareParser().getList(controlFile);
        cc.Assert(data, "cc.BMFontConfiguration._parseConfigFile | Open file error.");

        // parse spacing / padding
        var line, re;

        re = /padding+[a-z0-9\-= ",]+/gi;
        line = re.exec(data)[0];
        if (line) {
            this._parseInfoArguments(line);
        }

        re = /common lineHeight+[a-z0-9\-= ",]+/gi;
        line = re.exec(data)[0];
        if (line) {
            this._parseCommonArguments(line);
        }

        re = /page id=[a-zA-Z0-9\.\-= ",]+/gi;
        line = re.exec(data)[0];
        if (line) {
            this._parseImageFileName(line, controlFile);
        }

        re = /chars c+[a-z0-9\-= ",]+/gi;
        line = re.exec(data)[0];
        if (line) {
            // Ignore this line
        }

        re = /char id=\w[a-z0-9\-= ]+/gi;
        line = data.match(re);
        if (line) {
            // Parse the current line and create a new CharDef
            for (var i = 0; i < line.length; i++) {
                var element = new cc._FontDefHashElement();
                this._parseCharacterDefinition(line[i], element.fontDef);
                element.key = element.fontDef.charID;
                this.fontDefDictionary[element.key] = element;
            }
        }

        re = /kernings count+[a-z0-9\-= ",]+/gi;
        if (re.test(data)) {
            line = RegExp.$1[0];
        }
        if (line) {
            this._parseKerningCapacity(line);
        }

        re = /first=\w[a-z0-9\-= ]+/gi;
        line = data.match(re);
        if (line) {
            for (var i = 0; i < line.length; i++) {
                this._parseKerningEntry(line[i]);
            }
        }
    },

    _parseCharacterDefinition:function (line, characterDefinition) {
        //////////////////////////////////////////////////////////////////////////
        // line to parse:
        // char id=32   x=0     y=0     width=0     height=0     xoffset=0     yoffset=44    xadvance=14     page=0  chnl=0
        //////////////////////////////////////////////////////////////////////////
        // Character ID
        var value = /id=(\d+)/gi.exec(line)[1];
        characterDefinition.charID = value.toString();

        // Character x
        value = /x=([\-\d]+)/gi.exec(line)[1];
        characterDefinition.rect.origin.x = parseInt(value);

        // Character y
        value = /y=([\-\d]+)/gi.exec(line)[1];
        characterDefinition.rect.origin.y = parseInt(value);

        // Character width
        value = /width=([\-\d]+)/gi.exec(line)[1];
        characterDefinition.rect.size.width = parseInt(value);

        // Character height
        value = /height=([\-\d]+)/gi.exec(line)[1];
        characterDefinition.rect.size.height = parseInt(value);

        // Character xoffset
        value = /xoffset=([\-\d]+)/gi.exec(line)[1];
        characterDefinition.xOffset = parseInt(value);

        // Character yoffset
        value = /yoffset=([\-\d]+)/gi.exec(line)[1];
        characterDefinition.yOffset = parseInt(value);

        // Character xadvance
        value = /xadvance=([\-\d]+)/gi.exec(line)[1];
        characterDefinition.xAdvance = parseInt(value);

    },

    _parseInfoArguments:function (line) {
        //////////////////////////////////////////////////////////////////////////
        // possible lines to parse:
        // info face="Script" size=32 bold=0 italic=0 charset="" unicode=1 stretchH=100 smooth=1 aa=1 padding=1,4,3,2 spacing=0,0 outline=0
        // info face="Cracked" size=36 bold=0 italic=0 charset="" unicode=0 stretchH=100 smooth=1 aa=1 padding=0,0,0,0 spacing=1,1
        //////////////////////////////////////////////////////////////////////////

        // padding
        var tmpPadding = /padding=(\d+)[,](\d+)[,](\d+)[,](\d+)/gi.exec(line);
        this.padding.left = tmpPadding[1];
        this.padding.top = tmpPadding[2]
        this.padding.right = tmpPadding[3];
        this.padding.bottom = tmpPadding[4];
    },

    _parseCommonArguments:function (line) {
        //////////////////////////////////////////////////////////////////////////
        // line to parse:
        // common lineHeight=104 base=26 scaleW=1024 scaleH=512 pages=1 packed=0
        //////////////////////////////////////////////////////////////////////////

        var value;
        // Height
        this.commonHeight = parseInt(/lineHeight=(\d+)/gi.exec(line)[1]);

        // pages. sanity check
        value = /pages=(\d+)/gi.exec(line)[1];
        cc.Assert(parseInt(value) == 1, "cc.BitfontAtlas: only supports 1 page");

        // packed (ignore) What does this mean ??
    },

    _parseImageFileName:function (line, fntFile) {
        //////////////////////////////////////////////////////////////////////////
        // line to parse:
        // page id=0 file="bitmapFontTest.png"
        //////////////////////////////////////////////////////////////////////////
        var value;
        // page ID. Sanity check
        value = /id=(\d+)/gi.exec(line)[1];
        cc.Assert(parseInt(value) == 0, "LabelBMFont file could not be found");

        // file
        value = /file="([a-zA-Z0-9\-\._]+)/gi.exec(line)[1];

        this.atlasName = cc.FileUtils.getInstance().fullPathFromRelativeFile(value, fntFile);
    },

    _parseKerningCapacity:function (line) {
    },

    _parseKerningEntry:function (line) {
        //////////////////////////////////////////////////////////////////////////
        // line to parse:
        // kerning first=121  second=44  amount=-7
        //////////////////////////////////////////////////////////////////////////
        // first
        var value = /first=([\-\d]+)/gi.exec(line)[1];
        var first = parseInt(value);

        // second
        value = /second=([\-\d]+)/gi.exec(line)[1];
        var second = parseInt(value);

        // amount
        value = /amount=([\-\d]+)/gi.exec(line)[1];
        var amount = parseInt(value);

        var element = new cc._KerningHashElement();
        element.amount = amount;
        element.key = (first << 16) | (second & 0xffff);

        this.kerningDictionary[element.key] = element;

    },

    _purgeKerningDictionary:function () {
        this.kerningDictionary = {};
    },

    _purgeFontDefDictionary:function () {
        this.fontDefDictionary = {
            "0":{
                "key":"0",
                "fontDef":{
                    "charID":"0",
                    "rect":{
                        "origin":{
                            "x":0,
                            "y":0
                        },
                        "size":{
                            "width":1,
                            "height":1
                        }
                    },
                    "xOffset":0,
                    "yOffset":0,
                    "xAdvance":0}
            }
        };
    }
});

/**
 * Create a cc.BMFontConfiguration
 * @param {String} FNTfile
 * @return {cc.BMFontConfiguration|Null} returns the configuration or null if error
 * @example
 * // Example
 * var conf = cc.BMFontConfiguration.create('myfont.fnt');
 */
cc.BMFontConfiguration.create = function (FNTfile) {
    var ret = new cc.BMFontConfiguration();
    if (ret.initWithFNTfile(FNTfile)) {
        return ret;
    }
    return null;
};

/**
 * <p>cc.LabelBMFont is a subclass of cc.SpriteSheet.</p>
 *
 * <p>Features:<br/>
 * <ul><li>- Treats each character like a cc.Sprite. This means that each individual character can be:</li>
 * <li>- rotated</li>
 * <li>- scaled</li>
 * <li>- translated</li>
 * <li>- tinted</li>
 * <li>- chage the opacity</li>
 * <li>- It can be used as part of a menu item.</li>
 * <li>- anchorPoint can be used to align the "label"</li>
 * <li>- Supports AngelCode text format</li></ul></p>
 *
 * <p>Limitations:<br/>
 * - All inner characters are using an anchorPoint of (0.5, 0.5) and it is not recommend to change it
 * because it might affect the rendering</p>
 *
 * <p>cc.LabelBMFont implements the protocol cc.LabelProtocol, like cc.Label and cc.LabelAtlas.<br/>
 * cc.LabelBMFont has the flexibility of cc.Label, the speed of cc.LabelAtlas and all the features of cc.Sprite.<br/>
 * If in doubt, use cc.LabelBMFont instead of cc.LabelAtlas / cc.Label.</p>
 *
 * <p>Supported editors:<br/>
 * http://glyphdesigner.71squared.com/ (Commercial, Mac OS X)<br/>
 * http://www.n4te.com/hiero/hiero.jnlp (Free, Java)<br/>
 * http://slick.cokeandcode.com/demos/hiero.jnlp (Free, Java)<br/>
 * http://www.angelcode.com/products/bmfont/ (Free, Windows only)</p>
 * @class
 * @extends cc.
 */
cc.LabelBMFont = cc.SpriteBatchNode.extend(/** @lends cc.LabelBMFont# */{
    RGBAProtocol:true,
    _opacity:0,
    _color:null,
    _opacityModifyRGB:false,
    _string:"",
    _configuration:null,
    // name of fntFile
    _fntFile:"",
    // initial string without line breaks
    _initialString:"",
    // alignment of all lines
    _alignment:null,
    // max width until a line break is added
    _width:0,
    _lineBreakWithoutSpaces:false,
    _imageOffset:cc.PointZero(),
    /**
     * Constructor
     */
    /*    ctor:function () {
     this._super();
     },*/
    /**
     * @param {CanvasContext} ctx
     */
    draw:function (ctx) {
        this._super();
        var context = ctx || cc.renderContext;
        //LabelBMFont - Debug draw
        if (cc.LABELBMFONT_DEBUG_DRAW) {
            var s = this.getContentSize();
            var pos = cc.p(0 | ( -this._anchorPointInPoints.x), 0 | ( -this._anchorPointInPoints.y));
            var vertices = [cc.p(pos.x, pos.y), cc.p(pos.x + s.width, pos.y), cc.p(pos.x + s.width, pos.y + s.height), cc.p(pos.x, pos.y + s.height)];
            context.strokeStyle = "rgba(0,255,0,1)";
            cc.drawingUtil.drawPoly(vertices, 4, true);
        }
    },

    /**
     * conforms to cc.RGBAProtocol protocol
     * @return {Number}
     */
    getOpacity:function () {
        return this._opacity;
    },

    /**
     * set the opacity of this label
     * @param {Number} Var
     */
    setOpacity:function (Var) {
        this._opacity = Var;
        if (this._children) {
            for (var i = 0, len = this._children.length; i < len; i++) {
                var node = this._children[i];
                if (node) {
                    node.setOpacity(this._opacity);
                }
            }
        }
    },

    /**
     * conforms to cc.RGBAProtocol protocol
     * @return {cc.Color3B}
     */
    getColor:function () {
        return this._color;
    },

    /**
     * tint this label
     * @param {cc.Color3B} Var
     */
    setColor:function (color3) {
        if ((this._color.r == color3.r) && (this._color.g == color3.g) && (this._color.b == color3.b)) {
            return;
        }
        this._color = color3;
        if (this.getTexture()) {
            if (cc.renderContextType == cc.CANVAS) {
                var cacheTextureForColor = cc.TextureCache.getInstance().getTextureColors(this._originalTexture);
                if (cacheTextureForColor) {
                    //generate color texture cache
                    var tx = this.getTexture();
                    var textureRect = cc.rect(0, 0, tx.width, tx.height);
                    var colorTexture = cc.generateTintImage(tx, cacheTextureForColor, this._color, textureRect);
                    var img = new Image();
                    img.src = colorTexture.toDataURL();
                    this.setTexture(img);
                }
            }
        }
    },

    /**
     * conforms to cc.RGBAProtocol protocol
     * @return {Boolean}
     */
    isOpacityModifyRGB:function () {
        return this._opacityModifyRGB;
    },

    /**
     * @param {Boolean} Var
     */
    setOpacityModifyRGB:function (Var) {
        this._opacityModifyRGB = Var;
        if (this._children && this._children.length != 0) {
            for (var i = 0, len = this._children.length; i < len; i++) {
                var node = this._children[i];
                if (node) {
                    if (node.RGBAProtocol) {
                        node.setOpacity(255);
                    }
                }
            }
        }
    },

    /**
     *  init LabelBMFont
     */
    init:function () {
        this.initWithString(null, null, null, null, null);
    },

    /**
     * init a bitmap font altas with an initial string and the FNT file
     * @param {String} str
     * @param {String} fntFile
     * @param {String} width
     * @param {Number} alignment
     * @param {Number} imageOffset
     * @return {Boolean}
     */
    initWithString:function (str, fntFile, width, alignment, imageOffset) {
        var theString = str;

        cc.Assert(!this._configuration, "re-init is no longer supported");

        var texture;
        if (fntFile) {
            var newConf = cc.FNTConfigLoadFile(fntFile);
            cc.Assert(newConf, "cc.LabelBMFont: Impossible to create font. Please check file");
            this._configuration = newConf;
            this._fntFile = fntFile;
            texture = cc.TextureCache.getInstance().addImage(this._configuration.getAtlasName());
        }
        else {
            texture = new Image();
        }

        if (theString == null) {
            theString = "";
        }

        if (this.initWithTexture(texture, theString.length)) {
            this._alignment = alignment || cc.TEXT_ALIGNMENT_LEFT;
            this._imageOffset = imageOffset || cc.PointZero();
            this._width = width || cc.LabelAutomaticWidth;
            this._opacity = 255;
            this._color = cc.white();
            this._contentSize = cc.SizeZero();
            this.setString(theString);
            this.setAnchorPoint(cc.p(0.5, 0.5));
            return true;
        }
        return false;
    },

    /**
     * updates the font chars based on the string to render
     */
    createFontChars:function () {
        var nextFontPositionX = 0;
        var nextFontPositionY = 0;
        var prev = -1;
        var kerningAmount = 0;

        var tmpSize = cc.SizeZero();

        var longestLine = 0;
        var totalHeight = 0;

        var quantityOfLines = 1;

        var stringLen = this._string.length;

        if (stringLen == 0) {
            return;
        }
        var i;
        for (i = 0; i < stringLen; i++) {
            if (this._string.charCodeAt(i) == 10) {
                quantityOfLines++;
            }
        }

        totalHeight = this._configuration.commonHeight * quantityOfLines;
        nextFontPositionY = -(this._configuration.commonHeight - this._configuration.commonHeight * quantityOfLines);

        for (i = 0; i < stringLen; i++) {
            var key = this._string.charCodeAt(i);

            if (key == 10) {
                nextFontPositionX = 0;
                nextFontPositionY -= this._configuration.commonHeight;
                continue;
            }

            var element = this._configuration.fontDefDictionary[key];
            cc.Assert(element, "FontDefinition could not be found!");

            var fontDef = element.fontDef;

            var rect = cc.rect(fontDef.rect.origin.x, fontDef.rect.origin.y, fontDef.rect.size.width, fontDef.rect.size.height);
            rect = cc.RECT_PIXELS_TO_POINTS(rect);
            rect.origin.x += this._imageOffset.x;
            rect.origin.y += this._imageOffset.y;

            var fontChar = this.getChildByTag(i);
            if (!fontChar) {
                fontChar = new cc.Sprite();
                if (key == 32) {
                    fontChar.init();
                    fontChar.setTextureRect(cc.RectZero(), false, cc.SizeZero());
                } else {
                    fontChar.initWithTexture(this._textureAtlas.getTexture(), rect, false);
                }
                this.addChild(fontChar, 0, i);
            } else {
                if (key == 32) {
                    fontChar.init();
                    fontChar.setTextureRect(cc.RectZero(), false, cc.SizeZero());
                } else {
                    // reusing fonts
                    fontChar.initWithTexture(this._textureAtlas.getTexture(), rect, false);
                    // restore to default in case they were modified
                    fontChar.setVisible(true);
                    fontChar.setOpacity(255);
                }
            }

            var yOffset = this._configuration.commonHeight - fontDef.yOffset;
            var fontPos = cc.p(nextFontPositionX + fontDef.xOffset + fontDef.rect.size.width * 0.5 + kerningAmount,
                nextFontPositionY + yOffset - rect.size.height * 0.5 * cc.CONTENT_SCALE_FACTOR());
            fontChar.setPosition(cc.POINT_PIXELS_TO_POINTS(fontPos));

            // update kerning
            nextFontPositionX += fontDef.xAdvance + kerningAmount;
            prev = key;

            // Apply label properties
            fontChar.setOpacityModifyRGB(this._opacityModifyRGB);

            // only apply opacity if it is different than 255 )
            if (this._opacity != 255) {
                fontChar.setOpacity(this._opacity);
            }

            if (longestLine < nextFontPositionX) {
                longestLine = nextFontPositionX;
            }
        }

        tmpSize.width = longestLine;
        tmpSize.height = totalHeight;
        this.setContentSize(cc.SIZE_PIXELS_TO_POINTS(tmpSize));
    },

    /**
     * update String
     * @param {Boolean} fromUpdate
     */
    updateString:function (fromUpdate) {
        if (this._children) {
            for (var i = 0; i < this._children.length; i++) {
                var node = this._children[i];
                if (node) {
                    node.setVisible(false);
                }
            }
        }
        if (this._configuration) {
            this.createFontChars();
        }
        if (!fromUpdate) {
            this.updateLabel();
        }
    },

    /**
     * get the text of this label
     * @return {String}
     */
    getString:function () {
        return this._initialString;
    },

    /**
     * set the text
     * @param newString
     */
    setString:function (newString, fromUpdate) {
        if (this._string != newString) {
            this._string = newString + String.fromCharCode(0);
            //  if(this._initialString == ""){
            this._initialString = newString + String.fromCharCode(0);
            //}
            this.updateString(fromUpdate);
        }
    },

    /**
     * @deprecated
     * @param label
     */
    setCString:function (label) {
        this.setString(label);
    },

    /**
     *  update Label
     */
    updateLabel:function () {
        if (this._width > 0) {
            this.setString(this._initialString, true);

            // Step 1: Make multiline
            var stringLength = this._string.length;
            var multiline_string = [];
            var last_word = [];

            var line = 1, i = 0, start_line = false, start_word = false, startOfLine = -1, startOfWord = -1, skip = 0;

            var characterSprite;
            for (var j = 0; j < this._children.length; j++) {
                while (!(characterSprite = this.getChildByTag(j + skip)))
                    skip++;

                if (!characterSprite.isVisible()) continue;
                if (i >= stringLength)
                    break;

                var character = this._string[i];

                if (!start_word) {
                    startOfWord = this._getLetterPosXLeft(characterSprite);
                    start_word = true;
                }
                if (!start_line) {
                    startOfLine = startOfWord;
                    start_line = true;
                }

                // Newline.
                if (character.charCodeAt(0) == 10) {
                    last_word.push('\n');
                    multiline_string = multiline_string.concat(last_word);
                    last_word.length = 0;
                    start_word = false;
                    start_line = false;
                    startOfWord = -1;
                    startOfLine = -1;
                    i++;
                    line++;

                    if (i >= stringLength)
                        break;

                    character = this._string[i];

                    if (!startOfWord) {
                        startOfWord = this._getLetterPosXLeft(characterSprite);
                        start_word = true;
                    }
                    if (!startOfLine) {
                        startOfLine = startOfWord;
                        start_line = true;
                    }
                }

                // Whitespace.
                if (character.charCodeAt(0) == 32) {
                    last_word.push(character);
                    multiline_string = multiline_string.concat(last_word);
                    last_word.length = 0;
                    start_word = false;
                    startOfWord = -1;
                    i++;
                    continue;
                }

                // Out of bounds.
                if (this._getLetterPosXRight(characterSprite) - startOfLine > this._width) {
                    if (!this._lineBreakWithoutSpaces) {
                        last_word.push(character);

                        var found = multiline_string.lastIndexOf(" ");
                        if (found != -1)
                            cc.utf8_trim_ws(multiline_string);
                        else
                            multiline_string = [];

                        if (multiline_string.length > 0)
                            multiline_string.push('\n');

                        line++;
                        start_line = false;
                        startOfLine = -1;
                        i++;
                    }
                    else {
                        cc.utf8_trim_ws(last_word);

                        last_word.push('\n');
                        multiline_string = multiline_string.concat(last_word);
                        last_word.length = 0;
                        start_word = false;
                        start_line = false;
                        startOfWord = -1;
                        startOfLine = -1;
                        line++;

                        if (i >= stringLength)
                            break;

                        if (!startOfWord) {
                            startOfWord = this._getLetterPosXLeft(characterSprite);
                            start_word = true;
                        }
                        if (!startOfLine) {
                            startOfLine = startOfWord;
                            start_line = true;
                        }

                        j--;
                    }

                    continue;
                }
                else {
                    // Character is normal.
                    last_word.push(character);
                    i++;
                    continue;
                }
            }

            multiline_string = multiline_string.concat(last_word);
            var len = multiline_string.length;
            var str_new = "";

            for (var i = 0; i < len; ++i) {
                str_new += multiline_string[i];
            }

            this._string = str_new + String.fromCharCode(0);
            console.log(this._string)
            this.updateString(true);
        }

        // Step 2: Make alignment
        if (this._alignment != cc.TEXT_ALIGNMENT_LEFT) {
            var i = 0;

            var lineNumber = 0;
            var strlen = this._string.length;
            var last_line = [];

            for (var ctr = 0; ctr < strlen; ctr++) {
                if (this._string[ctr].charCodeAt(0) == 10 || this._string[ctr].charCodeAt(0) == 0) {
                    var lineWidth = 0;
                    var line_length = last_line.length;
                    var index = i + line_length - 1 + lineNumber;
                    if (index < 0) continue;

                    var lastChar = this.getChildByTag(index);
                    if (lastChar == null)
                        continue;
                    lineWidth = lastChar.getPosition().x + lastChar.getContentSize().width / 2;

                    var shift = 0;
                    switch (this._alignment) {
                        case cc.TEXT_ALIGNMENT_CENTER:
                            shift = this.getContentSize().width / 2 - lineWidth / 2;
                            break;
                        case cc.TEXT_ALIGNMENT_RIGHT:
                            shift = this.getContentSize().width - lineWidth;
                            break;
                        default:
                            break;
                    }

                    if (shift != 0) {
                        for (var j = 0; j < line_length; j++) {
                            index = i + j + lineNumber;
                            if (index < 0) continue;

                            var characterSprite = this.getChildByTag(index);
                            characterSprite.setPosition(cc.pAdd(characterSprite.getPosition(), cc.p(shift, 0)));
                        }
                    }

                    i += line_length;
                    lineNumber++;

                    last_line.length = 0;
                    continue;
                }

                last_line.push(this._string[i]);
            }
        }
    },

    /**
     * Set text vertical alignment
     * @param {Number} alignment
     */
    setAlignment:function (alignment) {
        this._alignment = alignment;
        this.updateLabel();
    },

    /**
     * @param {Number} width
     */
    setWidth:function (width) {
        this._width = width;
        this.updateLabel();
    },

    /**
     * @param {Boolean}  breakWithoutSpace
     */
    setLineBreakWithoutSpace:function (breakWithoutSpace) {
        this._lineBreakWithoutSpaces = breakWithoutSpace;
        this.updateLabel();
    },

    /**
     * @param {Number} scale
     */
    setScale:function (scale, scaleY) {
        this._super(scale, scaleY);
        this.updateLabel();
    },

    /**
     * @param {Number} scaleX
     */
    setScaleX:function (scaleX) {
        this._super(scaleX);
        this.updateLabel();
    },

    /**
     * @param {Number} scaleY
     */
    setScaleY:function (scaleY) {
        this._super(scaleY);
        this.updateLabel();
    },
    /**
     * set fnt file path
     * @param {String} fntFile
     */
    setFntFile:function (fntFile) {
        if (fntFile != null && fntFile != this._fntFile) {
            var newConf = cc.FNTConfigLoadFile(fntFile);

            cc.Assert(newConf, "cc.LabelBMFont: Impossible to create font. Please check file");

            this._fntFile = fntFile;
            this._configuration = newConf;

            this.setTexture(cc.TextureCache.getInstance().addImage(this._configuration.getAtlasName()));
            this.createFontChars();
        }
    },

    /**
     * @return {String}
     */
    getFntFile:function () {
        return this._fntFile;
    },

    /**
     * set the anchorpoint of the label
     * @param {cc.Point} point
     */
    setAnchorPoint:function (point) {
        if (!cc.Point.CCPointEqualToPoint(point, this._anchorPoint)) {
            this._super(point);
            this.updateLabel();
        }
    },

    _atlasNameFromFntFile:function (fntFile) {
    },
    _kerningAmountForFirst:function (first, second) {
        var ret = 0;
        var key = (first << 16) | (second & 0xffff);
        if (this._configuration.kerningDictionary) {
            var element = this._configuration.kerningDictionary[key.toString()];
            if (element) {
                ret = element.amount;
            }
        }
        return ret;
    },
    _getLetterPosXLeft:function (sp) {
        return sp.getPosition().x * this._scaleX + (sp.getContentSize().width * this._scaleX * sp.getAnchorPoint().x);
    },
    _getLetterPosXRight:function (sp) {
        return sp.getPosition().x * this._scaleX - (sp.getContentSize().width * this._scaleX * sp.getAnchorPoint().x);
    }
});

/**
 * creates a bitmap font altas with an initial string and the FNT file
 * @param {String} str
 * @param {String} fntFile
 * @param {String} width
 * @param {Number} alignment
 * @param {Number} imageOffset
 * @return {cc.LabelBMFont|Null}
 * @example
 * // Example 01
 * var label1 = cc.LabelBMFont.create("Test case", "test.fnt");
 *
 * // Example 02
 * var label2 = cc.LabelBMFont.create("test case", "test.fnt", 200, cc.TEXT_ALIGNMENT_LEFT);
 *
 * // Example 03
 * var label3 = cc.LabelBMFont.create("This is a \n test case", "test.fnt", 200, cc.TEXT_ALIGNMENT_LEFT, cc.PointZero());
 */
cc.LabelBMFont.create = function (str, fntFile, width, alignment, imageOffset) {
    var ret = new cc.LabelBMFont();
    if (ret && ret.initWithString(str, fntFile, width, alignment, imageOffset)) {
        return ret;
    }
    return null;
};

/**
 * shared instance of configuration
 * @type cc.BMFontConfiguration
 */
cc.configurations = null;

/**
 * Load the .fnt file
 * @param {String} fntFile
 * @return {cc.BMFontConfiguration}
 * Constructor
 */
cc.FNTConfigLoadFile = function (fntFile) {
    if (!cc.configurations) {
        cc.configurations = {};
    }
    var ret = cc.configurations[fntFile];
    if (!ret) {
        ret = cc.BMFontConfiguration.create(fntFile);
    }
    return ret;
};

/**
 * Purges the cached .fnt data
 */
cc.purgeCachedData = function () {
    cc.FNTConfigRemoveCache();
};

/**
 * Purges the FNT config cache
 */
cc.FNTConfigRemoveCache = function () {
    if (cc.configurations) {
        cc.configurations = {};
    }
};

/**
 * @param {String} ch
 * @return {Boolean}  weather the character is a whitespace character.
 */
cc.isspace_unicode = function (ch) {
    ch = ch.charCodeAt(0);
    return  ((ch >= 9 && ch <= 13) || ch == 32 || ch == 133 || ch == 160 || ch == 5760
        || (ch >= 8192 && ch <= 8202) || ch == 8232 || ch == 8233 || ch == 8239
        || ch == 8287 || ch == 12288)
};

/**
 * @param {String} str
 */
cc.utf8_trim_ws = function (str) {
    var len = str.length;

    if (len <= 0)
        return;

    var last_index = len - 1;

    // Only start trimming if the last character is whitespace..
    if (cc.isspace_unicode(str[last_index])) {
        for (var i = last_index - 1; i >= 0; --i) {
            if (cc.isspace_unicode(str[i])) {
                last_index = i;
            }
            else {
                break;
            }
        }
        cc.utf8_trim_from(str, last_index);
    }
};

/**
 * Trims str st str=[0, index) after the operation.
 * Return value: the trimmed string.
 * @param {String} str  he string to trim
 * @param {Number} index  the index to start trimming from.
 */
cc.utf8_trim_from = function (str, index) {
    var len = str.length;
    if (index >= len || index < 0)
        return;
    str.splice(index, len);
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

// ideas taken from:
//	 . The ocean spray in your face [Jeff Lander]
//		http://www.double.co.nz/dust/col0798.pdf
//	 . Building an Advanced Particle System [John van der Burg]
//		http://www.gamasutra.com/features/20000623/vanderburg_01.htm
//   . LOVE game engine
//		http://love2d.org/
//
//
// Radius mode support, from 71 squared
//		http://particledesigner.71squared.com/
//
// IMPORTANT: Particle Designer is supported by cocos2d, but
// 'Radius Mode' in Particle Designer uses a fixed emit rate of 30 hz. Since that can't be guarateed in cocos2d,
//  cocos2d uses a another approach, but the results are almost identical.
//

/**
 * Shape Mode of Particle Draw
 * @constant
 * @type Number
 */
cc.PARTICLE_SHAPE_MODE = 0;
/**
 * Texture Mode of Particle Draw
 * @constant
 * @type Number
 */
cc.PARTICLE_TEXTURE_MODE = 1;

/**
 * Star Shape for ShapeMode of Particle
 * @constant
 * @type Number
 */
cc.PARTICLE_STAR_SHAPE = 0;
/**
 * Ball Shape for ShapeMode of Particle
 * @constant
 * @type Number
 */
cc.PARTICLE_BALL_SHAPE = 1;

/**
 * The Particle emitter lives forever
 * @constant
 * @type Number
 */
cc.PARTICLE_DURATION_INFINITY = -1;

/**
 * The starting size of the particle is equal to the ending size
 * @constant
 * @type Number
 */
cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE = -1;

/**
 * The starting radius of the particle is equal to the ending radius
 * @constant
 * @type Number
 */
cc.PARTICLE_START_RADIUS_EQUAL_TO_END_RADIUS = -1;

/**
 * Gravity mode (A mode)
 * @constant
 * @type Number
 */
cc.PARTICLE_MODE_GRAVITY = 0;

/**
 * Radius mode (B mode)
 * @constant
 * @type Number
 */
cc.PARTICLE_MODE_RADIUS = 1;

// tCCPositionType
// possible types of particle positions

/**
 * Living particles are attached to the world and are unaffected by emitter repositioning.
 * @constant
 * @type Number
 */
cc.PARTICLE_TYPE_FREE = 0;

/**
 * Living particles are attached to the world but will follow the emitter repositioning.<br/>
 * Use case: Attach an emitter to an sprite, and you want that the emitter follows the sprite.
 * @constant
 * @type Number
 */
cc.PARTICLE_TYPE_RELATIVE = 1;

/**
 * Living particles are attached to the emitter and are translated along with it.
 * @constant
 * @type Number
 */
cc.PARTICLE_TYPE_GROUPED = 2;

// backward compatible
cc.PARTICLE_TYPE_FREE = cc.PARTICLE_TYPE_FREE;
cc.PARTICLE_TYPE_GROUPED = cc.PARTICLE_TYPE_GROUPED;


/**
 * Structure that contains the values of each particle
 * @Class
 * @Construct
 * @param {cc.Point} pos Position of particle
 * @param {cc.Point} startPos
 * @param {cc.Color4F} color
 * @param {cc.Color4F} deltaColor
 * @param {cc.Size} size
 * @param {cc.Size} deltaSize
 * @param {Number} rotation
 * @param {Number} deltaRotation
 * @param {Number} timeToLive
 * @param {cc.Particle.ModeA} modeA
 * @param {cc.Particle.ModeA} modeB
 */
cc.Particle = function (pos, startPos, color, deltaColor, size, deltaSize, rotation, deltaRotation, timeToLive, atlasIndex, modeA, modeB) {
    this.pos = pos ? pos : cc.PointZero();
    this.startPos = startPos ? startPos : cc.PointZero();
    this.color = color ? color : new cc.Color4F(0, 0, 0, 1);
    this.deltaColor = deltaColor ? deltaColor : new cc.Color4F(0, 0, 0, 1);
    this.size = size || 0;
    this.deltaSize = deltaSize || 0;
    this.rotation = rotation || 0;
    this.deltaRotation = deltaRotation || 0;
    this.timeToLive = timeToLive || 0;
    this.atlasIndex = atlasIndex || 0;
    this.modeA = modeA ? modeA : new cc.Particle.ModeA();
    this.modeB = modeB ? modeB : new cc.Particle.ModeB();
    this.isChangeColor = false;
    this.drawPos = cc.p(0, 0);
};

/**
 * Mode A: gravity, direction, radial accel, tangential accel
 * @Class
 * @Construct
 * @param {cc.Point} dir direction of particle
 * @param {Number} radialAccel
 * @param {Number} tangentialAccel
 */
cc.Particle.ModeA = function (dir, radialAccel, tangentialAccel) {
    this.dir = dir ? dir : cc.PointZero();
    this.radialAccel = radialAccel || 0;
    this.tangentialAccel = tangentialAccel || 0;
};

/**
 * Mode B: radius mode
 * @Class
 * @Construct
 * @param {Number} angle
 * @param {Number} degreesPerSecond
 * @param {Number} radius
 * @param {Number} deltaRadius
 */
cc.Particle.ModeB = function (angle, degreesPerSecond, radius, deltaRadius) {
    this.angle = angle || 0;
    this.degreesPerSecond = degreesPerSecond || 0;
    this.radius = radius || 0;
    this.deltaRadius = deltaRadius || 0;
};


/**
 * <p>
 *     Particle System base class. <br/>
 *     Attributes of a Particle System:<br/>
 *     - emmision rate of the particles<br/>
 *     - Gravity Mode (Mode A): <br/>
 *     - gravity <br/>
 *     - direction <br/>
 *     - speed +-  variance <br/>
 *     - tangential acceleration +- variance<br/>
 *     - radial acceleration +- variance<br/>
 *     - Radius Mode (Mode B):      <br/>
 *     - startRadius +- variance    <br/>
 *     - endRadius +- variance      <br/>
 *     - rotate +- variance         <br/>
 *     - Properties common to all modes: <br/>
 *     - life +- life variance      <br/>
 *     - start spin +- variance     <br/>
 *     - end spin +- variance       <br/>
 *     - start size +- variance     <br/>
 *     - end size +- variance       <br/>
 *     - start color +- variance    <br/>
 *     - end color +- variance      <br/>
 *     - life +- variance           <br/>
 *     - blending function          <br/>
 *     - texture                    <br/>
 *                                  <br/>
 *     cocos2d also supports particles generated by Particle Designer (http://particledesigner.71squared.com/).<br/>
 *     'Radius Mode' in Particle Designer uses a fixed emit rate of 30 hz. Since that can't be guarateed in cocos2d,  <br/>
 *     cocos2d uses a another approach, but the results are almost identical.<br/>
 *     cocos2d supports all the variables used by Particle Designer plus a bit more:  <br/>
 *     - spinning particles (supported when using CCParticleSystemQuad)       <br/>
 *     - tangential acceleration (Gravity mode)                               <br/>
 *     - radial acceleration (Gravity mode)                                   <br/>
 *     - radius direction (Radius mode) (Particle Designer supports outwards to inwards direction only) <br/>
 *     It is possible to customize any of the above mentioned properties in runtime. Example:   <br/>
 * </p>
 * @class
 * @extends cc.Node
 *
 * @example
 *  emitter.radialAccel = 15;
 *  emitter.startSpin = 0;
 */
cc.ParticleSystem = cc.Node.extend(/** @lends cc.ParticleSystem# */{
    //***********variables*************
    _plistFile:"",
    //! time elapsed since the start of the system (in seconds)
    _elapsed:0,

    _dontTint:false,

    // Different modes
    //! Mode A:Gravity + Tangential Accel + Radial Accel
    modeA:null,
    //! Mode B: circular movement (gravity, radial accel and tangential accel don't are not used in this mode)
    modeB:null,

    //! Array of particles
    _particles:null,

    // color modulate
    //	BOOL colorModulate;

    //! How many particles can be emitted per second
    _emitCounter:0,
    //!  particle idx
    _particleIdx:0,

    _batchNode:null,
    /**
     * return weak reference to the cc.SpriteBatchNode that renders the cc.Sprite
     * @return {cc.ParticleBatchNode}
     */
    getBatchNode:function () {
        return this._batchNode;
    },

    /**
     *  set weak reference to the cc.SpriteBatchNode that renders the cc.Sprite
     * @param {cc.ParticleBatchNode} batchNode
     */
    setBatchNode:function (batchNode) {
        if (this._batchNode != batchNode) {
            this._batchNode = batchNode; //weak reference

            if (batchNode) {
                for (var i = 0; i < this._totalParticles; i++) {
                    this._particles[i].atlasIndex = i;
                }
            }
        }
    },

    _atlasIndex:0,
    /**
     * return index of system in batch node array
     * @return {Number}
     */
    getAtlasIndex:function () {
        return this._atlasIndex;
    },

    /**
     * set index of system in batch node array
     * @param {Number} atlasIndex
     */
    setAtlasIndex:function (atlasIndex) {
        this._atlasIndex = atlasIndex;
    },

    //true if scaled or rotated
    _transformSystemDirty:false,

    _allocatedParticles:0,

    //drawMode
    _drawMode:cc.PARTICLE_SHAPE_MODE,

    /**
     * Return DrawMode of ParticleSystem
     * @return {Number}
     */
    getDrawMode:function () {
        return this._drawMode;
    },

    /**
     * DrawMode of ParticleSystem setter
     * @param {Number} drawMode
     */
    setDrawMode:function (drawMode) {
        this._drawMode = drawMode;
    },

    //shape type
    _shapeType:cc.PARTICLE_BALL_SHAPE,

    /**
     * Return ShapeType of ParticleSystem
     * @return {Number}
     */
    getShapeType:function () {
        return this._shapeType;
    },

    /**
     * ShapeType of ParticleSystem setter
     * @param {Number} shapeType
     */
    setShapeType:function (shapeType) {
        this._shapeType = shapeType;
    },

    _isActive:false,
    /**
     * Return ParticleSystem is active
     * @return {Boolean}
     */
    isActive:function () {
        return this._isActive;
    },

    _particleCount:0,

    /**
     * Quantity of particles that are being simulated at the moment
     * @return {Number}
     */
    getParticleCount:function () {
        return this._particleCount;
    },

    /**
     * Quantity of particles setter
     * @param {Number} particleCount
     */
    setParticleCount:function (particleCount) {
        this._particleCount = particleCount;
    },

    _duration:0,
    /**
     * How many seconds the emitter wil run. -1 means 'forever'
     * @return {Number}
     */
    getDuration:function () {
        return this._duration;
    },

    /**
     * set run seconds of the emitter
     * @param {Number} duration
     */
    setDuration:function (duration) {
        this._duration = duration;
    },

    _sourcePosition:cc.PointZero(),
    /**
     * Return sourcePosition of the emitter
     * @return {cc.Point}
     */
    getSourcePosition:function () {
        return this._sourcePosition;
    },

    /**
     * sourcePosition of the emitter setter
     * @param sourcePosition
     */
    setSourcePosition:function (sourcePosition) {
        this._sourcePosition = sourcePosition;
    },

    _posVar:cc.PointZero(),
    /**
     * Return Position variance of the emitter
     * @return {cc.Point}
     */
    getPosVar:function () {
        return this._posVar;
    },

    /**
     * Position variance of the emitter setter
     * @param {cc.Point} posVar
     */
    setPosVar:function (posVar) {
        this._posVar = posVar;
    },

    _life:0,
    /**
     * Return life of each particle
     * @return {Number}
     */
    getLife:function () {
        return this._life;
    },

    /**
     * life of each particle setter
     * @param {Number} life
     */
    setLife:function (life) {
        this._life = life;
    },

    _lifeVar:0,
    /**
     * Return life variance of each particle
     * @return {Number}
     */
    getLifeVar:function () {
        return this._lifeVar;
    },

    /**
     * life variance of each particle setter
     * @param {Number} lifeVar
     */
    setLifeVar:function (lifeVar) {
        this._lifeVar = lifeVar;
    },

    _angle:0,
    /**
     * Return angle of each particle
     * @return {Number}
     */
    getAngle:function () {
        return this._angle;
    },

    /**
     * angle of each particle setter
     * @param {Number} angle
     */
    setAngle:function (angle) {
        this._angle = angle;
    },

    _angleVar:0,
    /**
     * Return angle variance of each particle
     * @return {Number}
     */
    getAngleVar:function () {
        return this._angleVar;
    },

    /**
     * angle variance of each particle setter
     * @param angleVar
     */
    setAngleVar:function (angleVar) {
        this._angleVar = angleVar;
    },

    // mode A
    /**
     * Return Gravity of emitter
     * @return {cc.Point}
     */
    getGravity:function () {
        cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        return this.modeA.gravity;
    },

    /**
     * Gravity of emitter setter
     * @param {cc.Point} gravity
     */
    setGravity:function (gravity) {
        cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        this.modeA.gravity = gravity;
    },

    /**
     * Return Speed of each particle
     * @return {Number}
     */
    getSpeed:function () {
        cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        return this.modeA.speed;
    },

    /**
     * Speed of each particle setter
     * @param {Number} speed
     */
    setSpeed:function (speed) {
        cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        this.modeA.speed = speed;
    },

    /**
     * return speed variance of each particle. Only available in 'Gravity' mode.
     * @return {Number}
     */
    getSpeedVar:function () {
        cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        return this.modeA.speedVar;
    },

    /**
     * speed variance of each particle setter. Only available in 'Gravity' mode.
     * @param {Number} speedVar
     */
    setSpeedVar:function (speedVar) {
        cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        this.modeA.speedVar = speedVar;
    },

    /**
     * Return tangential acceleration of each particle. Only available in 'Gravity' mode.
     * @return {Number}
     */
    getTangentialAccel:function () {
        cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        return this.modeA.tangentialAccel;
    },

    /**
     * Tangential acceleration of each particle setter. Only available in 'Gravity' mode.
     * @param {Number} tangentialAccel
     */
    setTangentialAccel:function (tangentialAccel) {
        cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        this.modeA.tangentialAccel = tangentialAccel;
    },

    /**
     * Return tangential acceleration variance of each particle. Only available in 'Gravity' mode.
     * @return {Number}
     */
    getTangentialAccelVar:function () {
        cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        return this.modeA.tangentialAccelVar;
    },

    /**
     * tangential acceleration variance of each particle setter. Only available in 'Gravity' mode.
     * @param {Number} tangentialAccelVar
     */
    setTangentialAccelVar:function (tangentialAccelVar) {
        cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        this.modeA.tangentialAccelVar = tangentialAccelVar;
    },

    /**
     * Return radial acceleration of each particle. Only available in 'Gravity' mode.
     * @return {Number}
     */
    getRadialAccel:function () {
        cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        return this.modeA.radialAccel;
    },

    /**
     * radial acceleration of each particle setter. Only available in 'Gravity' mode.
     * @param {Number} radialAccel
     */
    setRadialAccel:function (radialAccel) {
        cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        this.modeA.radialAccel = radialAccel;
    },

    /**
     * Return radial acceleration variance of each particle. Only available in 'Gravity' mode.
     * @return {Number}
     */
    getRadialAccelVar:function () {
        cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        return this.modeA.radialAccelVar;
    },

    /**
     * radial acceleration variance of each particle setter. Only available in 'Gravity' mode.
     * @param radialAccelVar
     */
    setRadialAccelVar:function (radialAccelVar) {
        cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        this.modeA.radialAccelVar = radialAccelVar;
    },

    // mode B
    /**
     * Return starting radius of the particles. Only available in 'Radius' mode.
     * @return {Number}
     */
    getStartRadius:function () {
        cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        return this.modeB.startRadius;
    },

    /**
     * starting radius of the particles setter. Only available in 'Radius' mode.
     * @param {Number} startRadius
     */
    setStartRadius:function (startRadius) {
        cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        this.modeB.startRadius = startRadius;
    },

    /**
     * Return starting radius variance of the particles. Only available in 'Radius' mode.
     * @return {Number}
     */
    getStartRadiusVar:function () {
        cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        return this.modeB.startRadiusVar;
    },

    /**
     * starting radius variance of the particles setter. Only available in 'Radius' mode.
     * @param {Number} startRadiusVar
     */
    setStartRadiusVar:function (startRadiusVar) {
        cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        this.modeB.startRadiusVar = startRadiusVar;
    },

    /**
     * Return ending radius of the particles. Only available in 'Radius' mode.
     * @return {Number}
     */
    getEndRadius:function () {
        cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        return this.modeB.endRadius;
    },

    /**
     * ending radius of the particles setter. Only available in 'Radius' mode.
     * @param {Number} endRadius
     */
    setEndRadius:function (endRadius) {
        cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        this.modeB.endRadius = endRadius;
    },

    /**
     * Return ending radius variance of the particles. Only available in 'Radius' mode.
     * @return {Number}
     */
    getEndRadiusVar:function () {
        cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        return this.modeB.endRadiusVar;
    },

    /**
     * ending radius variance of the particles setter. Only available in 'Radius' mode.
     * @param endRadiusVar
     */
    setEndRadiusVar:function (endRadiusVar) {
        cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        this.modeB.endRadiusVar = endRadiusVar;
    },

    /**
     * get Number of degress to rotate a particle around the source pos per second. Only available in 'Radius' mode.
     * @return {Number}
     */
    getRotatePerSecond:function () {
        cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        return this.modeB.rotatePerSecond;
    },

    /**
     * set Number of degress to rotate a particle around the source pos per second. Only available in 'Radius' mode.
     * @param {Number} degrees
     */
    setRotatePerSecond:function (degrees) {
        cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        this.modeB.rotatePerSecond = degrees;
    },

    /**
     * Return Variance in degrees for rotatePerSecond. Only available in 'Radius' mode.
     * @return {Number}
     */
    getRotatePerSecondVar:function () {
        cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        return this.modeB.rotatePerSecondVar;
    },

    /**
     * Variance in degrees for rotatePerSecond setter. Only available in 'Radius' mode.
     * @param degrees
     */
    setRotatePerSecondVar:function (degrees) {
        cc.Assert(this._emitterMode == cc.PARTICLE_MODE_GRAVITY, "Particle Mode should be Gravity");
        this.modeB.rotatePerSecondVar = degrees;
    },
    //////////////////////////////////////////////////////////////////////////

    //don't use a transform matrix, this is faster
    setScale:function (scale, scaleY) {
        this._transformSystemDirty = true;
        this._super(scale, scaleY);
    },

    setRotation:function (newRotation) {
        this._transformSystemDirty = true;
        this._super(newRotation);
    },

    setScaleX:function (newScaleX) {
        this._transformSystemDirty = true;
        this._super(newScaleX);
    },

    setScaleY:function (newScaleY) {
        this._transformSystemDirty = true;
        this._super(newScaleY);
    },


    _startSize:0,
    /**
     * get start size in pixels of each particle
     * @return {Number}
     */
    getStartSize:function () {
        return this._startSize;
    },

    /**
     * set start size in pixels of each particle
     * @param {Number} startSize
     */
    setStartSize:function (startSize) {
        this._startSize = startSize;
    },


    _startSizeVar:0,
    /**
     * get size variance in pixels of each particle
     * @return {Number}
     */
    getStartSizeVar:function () {
        return this._startSizeVar;
    },

    /**
     * set size variance in pixels of each particle
     * @param {Number} startSizeVar
     */
    setStartSizeVar:function (startSizeVar) {
        this._startSizeVar = startSizeVar;
    },


    _endSize:0,
    /**
     * get end size in pixels of each particle
     * @return {Number}
     */
    getEndSize:function () {
        return this._endSize;
    },

    /**
     * set end size in pixels of each particle
     * @param endSize
     */
    setEndSize:function (endSize) {
        this._endSize = endSize;
    },

    _endSizeVar:0,
    /**
     * get end size variance in pixels of each particle
     * @return {Number}
     */
    getEndSizeVar:function () {
        return this._endSizeVar;
    },

    /**
     * set end size variance in pixels of each particle
     * @param {Number} endSizeVar
     */
    setEndSizeVar:function (endSizeVar) {
        this._endSizeVar = endSizeVar;
    },


    _startColor:new cc.Color4F(0, 0, 0, 1),
    /**
     * set start color of each particle
     * @return {cc.Color4F}
     */
    getStartColor:function () {
        return this._startColor;
    },

    /**
     * get start color of each particle
     * @param {cc.Color4F} startColor
     */
    setStartColor:function (startColor) {
        this._startColor = startColor;
    },

    _startColorVar:new cc.Color4F(0, 0, 0, 1),
    /**
     * get start color variance of each particle
     * @return {cc.Color4F}
     */
    getStartColorVar:function () {
        return this._startColorVar;
    },

    /**
     * set start color variance of each particle
     * @param {cc.Color4F} startColorVar
     */
    setStartColorVar:function (startColorVar) {
        this._startColorVar = startColorVar;
    },


    _endColor:new cc.Color4F(0, 0, 0, 1),
    /**
     * get end color and end color variation of each particle
     * @return {cc.Color4F}
     */
    getEndColor:function () {
        return this._endColor;
    },

    /**
     * set end color and end color variation of each particle
     * @param {cc.Color4F} endColor
     */
    setEndColor:function (endColor) {
        this._endColor = endColor;
    },

    _endColorVar:new cc.Color4F(0, 0, 0, 1),
    /**
     * get end color variance of each particle
     * @return {cc.Color4F}
     */
    getEndColorVar:function () {
        return this._endColorVar;
    },

    /**
     * set end color variance of each particle
     * @param {cc.Color4F} endColorVar
     */
    setEndColorVar:function (endColorVar) {
        this._endColorVar = endColorVar;
    },

    _startSpin:0,
    /**
     * get initial angle of each particle
     * @return {Number}
     */
    getStartSpin:function () {
        return this._startSpin;
    },

    /**
     * set initial angle of each particle
     * @param {Number} startSpin
     */
    setStartSpin:function (startSpin) {
        this._startSpin = startSpin;
    },

    _startSpinVar:0,
    /**
     * get initial angle variance of each particle
     * @return {Number}
     */
    getStartSpinVar:function () {
        return this._startSpinVar;
    },

    /**
     * set initial angle variance of each particle
     * @param {Number} startSpinVar
     */
    setStartSpinVar:function (startSpinVar) {
        this._startSpinVar = startSpinVar;
    },

    _endSpin:0,
    /**
     * get end angle of each particle
     * @return {Number}
     */
    getEndSpin:function () {
        return this._endSpin;
    },

    /**
     * set end angle of each particle
     * @param {Number} endSpin
     */
    setEndSpin:function (endSpin) {
        this._endSpin = endSpin;
    },

    _endSpinVar:0,
    /**
     * get end angle variance of each particle
     * @return {Number}
     */
    getEndSpinVar:function () {
        return this._endSpinVar;
    },

    /**
     * set end angle variance of each particle
     * @param {Number} endSpinVar
     */
    setEndSpinVar:function (endSpinVar) {
        this._endSpinVar = endSpinVar;
    },

    _emissionRate:0,
    /**
     * get emission rate of the particles
     * @return {Number}
     */
    getEmissionRate:function () {
        return this._emissionRate;
    },

    /**
     * set emission rate of the particles
     * @param {Number} emissionRate
     */
    setEmissionRate:function (emissionRate) {
        this._emissionRate = emissionRate;
    },

    _totalParticles:0,
    /**
     * get maximum particles of the system
     * @return {Number}
     */
    getTotalParticles:function () {
        return this._totalParticles;
    },

    /**
     * set maximum particles of the system
     * @param {Number} totalParticles
     */
    setTotalParticles:function (totalParticles) {
        cc.Assert(totalParticles <= this._allocatedParticles, "Particle: resizing particle array only supported for quads");
        this._totalParticles = totalParticles;
    },

    _texture:null,
    /**
     * get Texture of Particle System
     * @return {cc.Texture2D}
     */
    getTexture:function () {
        return this._texture;
    },

    /**
     * set Texture of Particle System
     * @param {cc.Texture2D | HTMLImageElement | HTMLCanvasElement} texture
     */
    setTexture:function (texture) {
        //TODO
        if (this._texture != texture) {
            this._texture = texture;
            this._updateBlendFunc();
        }
    },

    /** conforms to CocosNodeTexture protocol */
    _blendFunc: {src:gl.ONE, dst:gl.ONE},
    /**
     * get BlendFunc of Particle System
     * @return {cc.BlendFunc}
     */
    getBlendFunc:function () {
        return this._blendFunc;
    },

    /**
     * set BlendFunc of Particle System
     * @param {Number} src
     * @param {Number} dst
     */
    setBlendFunc:function (src, dst) {
        if (this._blendFunc.src != src || this._blendFunc.dst != dst) {
            this._blendFunc = {src:src, dst:dst};
            this._updateBlendFunc();
        }
    },

    _opacityModifyRGB:false,
    /**
     * does the alpha value modify color getter
     * @return {Boolean}
     */
    getOpacityModifyRGB:function () {
        return this._opacityModifyRGB;
    },

    /**
     * does the alpha value modify color setter
     * @param newValue
     */
    setOpacityModifyRGB:function (newValue) {
        this._opacityModifyRGB = newValue;
    },

    _isBlendAdditive:false,
    /**
     * <p>whether or not the particles are using blend additive.<br/>
     *     If enabled, the following blending function will be used.<br/>
     * </p>
     * @return {Boolean}
     * @example
     *    source blend function = GL_SRC_ALPHA;
     *    dest blend function = GL_ONE;
     */
    isBlendAdditive:function () {
        //return this._isBlendAdditive;
        return( this._blendFunc.src == gl.SRC_ALPHA && this._blendFunc.dst == gl.ONE);
    },

    /**
     * <p>whether or not the particles are using blend additive.<br/>
     *     If enabled, the following blending function will be used.<br/>
     * </p>
     * @param {Boolean} isBlendAdditive
     */
    setBlendAdditive:function (isBlendAdditive) {
        //TODO
        this._isBlendAdditive = isBlendAdditive;
        if (isBlendAdditive) {
            this._blendFunc.src = gl.SRC_ALPHA;
            this._blendFunc.dst = gl.ONE;
        } else {
            this._blendFunc.src = cc.BLEND_SRC;
            this._blendFunc.dst = cc.BLEND_DST;
            /*if (this._texture && !this._texture.hasPremultipliedAlpha()) {
             this._blendFunc.src = gl.SRC_ALPHA;
             this._blendFunc.dst = gl.ONE_MINUS_SRC_ALPHA;
             } else {
             this._blendFunc.src = cc.BLEND_SRC;
             this._blendFunc.dst = cc.BLEND_DST;
             }*/
        }
    },

    _positionType:cc.PARTICLE_TYPE_FREE,
    /**
     * get particles movement type: Free or Grouped
     * @return {Number}
     */
    getPositionType:function () {
        return this._positionType;
    },

    /**
     * set particles movement type: Free or Grouped
     * @param {Number} positionType
     */
    setPositionType:function (positionType) {
        this._positionType = positionType;
    },

    _isAutoRemoveOnFinish:false,
    /**
     *  <p> return whether or not the node will be auto-removed when it has no particles left.<br/>
     *      By default it is false.<br/>
     *  </p>
     * @return {Boolean}
     */
    isAutoRemoveOnFinish:function () {
        return this._isAutoRemoveOnFinish;
    },

    /**
     *  <p> set whether or not the node will be auto-removed when it has no particles left.<br/>
     *      By default it is false.<br/>
     *  </p>
     * @param {Boolean} isAutoRemoveOnFinish
     */
    setAutoRemoveOnFinish:function (isAutoRemoveOnFinish) {
        this._isAutoRemoveOnFinish = isAutoRemoveOnFinish;
    },

    _emitterMode:0,
    /**
     * return kind of emitter modes
     * @return {Number}
     */
    getEmitterMode:function () {
        return this._emitterMode;
    },

    /**
     * <p>Switch between different kind of emitter modes:<br/>
     *  - CCPARTICLE_MODE_GRAVITY: uses gravity, speed, radial and tangential acceleration<br/>
     *  - CCPARTICLE_MODE_RADIUS: uses radius movement + rotation <br/>
     *  </p>
     * @param {Number} emitterMode
     */
    setEmitterMode:function (emitterMode) {
        this._emitterMode = emitterMode;
    },

    /**
     * Constructor
     * @override
     */
    ctor:function () {
        this._super();
        this._emitterMode = cc.PARTICLE_MODE_GRAVITY;
        this.modeA = new cc.ParticleSystem.ModeA();
        this.modeB = new cc.ParticleSystem.ModeB();
        this._blendFunc = {src:cc.BLEND_SRC, dst:cc.BLEND_DST};
    },

    /**
     * initializes a cc.ParticleSystem
     */
    init:function () {
        return this.initWithTotalParticles(150);
    },

    /**
     * <p> initializes a CCParticleSystem from a plist file. <br/>
     *      This plist files can be creted manually or with Particle Designer:<br/>
     *      http://particledesigner.71squared.com/<br/></p>
     * @param {String} plistFile
     * @return {cc.ParticleSystem}
     */
    initWithFile:function (plistFile) {
        var ret = false;
        //TODO
        this._plistFile = plistFile;
        var dict = cc.FileUtils.getInstance().dictionaryWithContentsOfFileThreadSafe(this._plistFile);

        cc.Assert(dict != null, "Particles: file not found");
        return this.initWithDictionary(dict);
    },

    /**
     * return bounding box of particle system in world space
     * @return {cc.Rect}
     */
    getBoundingBoxToWorld:function () {
        return cc.rect(0, 0, cc.canvas.width, cc.canvas.height);
    },

    /**
     * initializes a CCQuadParticleSystem from a CCDictionary.
     * @param {object} dictionary
     * @return {Boolean}
     */
    initWithDictionary:function (dictionary) {
        var ret = false;
        var buffer = null;
        var deflated = null;
        var image = null;

        var maxParticles = parseInt(this._valueForKey("maxParticles", dictionary));
        // self, not super
        if (this.initWithTotalParticles(maxParticles)) {
            // angle
            this._angle = parseFloat(this._valueForKey("angle", dictionary));
            this._angleVar = parseFloat(this._valueForKey("angleVariance", dictionary));

            // duration
            this._duration = parseFloat(this._valueForKey("duration", dictionary));

            // blend function
            this._blendFunc.src = parseInt(this._valueForKey("blendFuncSource", dictionary));
            this._blendFunc.dst = parseInt(this._valueForKey("blendFuncDestination", dictionary));

            // color
            this._startColor.r = parseFloat(this._valueForKey("startColorRed", dictionary));
            this._startColor.g = parseFloat(this._valueForKey("startColorGreen", dictionary));
            this._startColor.b = parseFloat(this._valueForKey("startColorBlue", dictionary));
            this._startColor.a = parseFloat(this._valueForKey("startColorAlpha", dictionary));

            this._startColorVar.r = parseFloat(this._valueForKey("startColorVarianceRed", dictionary));
            this._startColorVar.g = parseFloat(this._valueForKey("startColorVarianceGreen", dictionary));
            this._startColorVar.b = parseFloat(this._valueForKey("startColorVarianceBlue", dictionary));
            this._startColorVar.a = parseFloat(this._valueForKey("startColorVarianceAlpha", dictionary));

            this._endColor.r = parseFloat(this._valueForKey("finishColorRed", dictionary));
            this._endColor.g = parseFloat(this._valueForKey("finishColorGreen", dictionary));
            this._endColor.b = parseFloat(this._valueForKey("finishColorBlue", dictionary));
            this._endColor.a = parseFloat(this._valueForKey("finishColorAlpha", dictionary));

            this._endColorVar.r = parseFloat(this._valueForKey("finishColorVarianceRed", dictionary));
            this._endColorVar.g = parseFloat(this._valueForKey("finishColorVarianceGreen", dictionary));
            this._endColorVar.b = parseFloat(this._valueForKey("finishColorVarianceBlue", dictionary));
            this._endColorVar.a = parseFloat(this._valueForKey("finishColorVarianceAlpha", dictionary));

            // particle size
            this._startSize = parseFloat(this._valueForKey("startParticleSize", dictionary));
            this._startSizeVar = parseFloat(this._valueForKey("startParticleSizeVariance", dictionary));
            this._endSize = parseFloat(this._valueForKey("finishParticleSize", dictionary));
            this._endSizeVar = parseFloat(this._valueForKey("finishParticleSizeVariance", dictionary));

            // position
            var x = parseFloat(this._valueForKey("sourcePositionx", dictionary));
            var y = parseFloat(this._valueForKey("sourcePositiony", dictionary));
            this.setPosition(cc.p(x, y));
            this._posVar.x = parseFloat(this._valueForKey("sourcePositionVariancex", dictionary));
            this._posVar.y = parseFloat(this._valueForKey("sourcePositionVariancey", dictionary));

            // Spinning
            this._startSpin = parseFloat(this._valueForKey("rotationStart", dictionary));
            this._startSpinVar = parseFloat(this._valueForKey("rotationStartVariance", dictionary));
            this._endSpin = parseFloat(this._valueForKey("rotationEnd", dictionary));
            this._endSpinVar = parseFloat(this._valueForKey("rotationEndVariance", dictionary));

            this._emitterMode = parseInt(this._valueForKey("emitterType", dictionary));

            // Mode A: Gravity + tangential accel + radial accel
            if (this._emitterMode == cc.PARTICLE_MODE_GRAVITY) {
                // gravity
                this.modeA.gravity.x = parseFloat(this._valueForKey("gravityx", dictionary));
                this.modeA.gravity.y = parseFloat(this._valueForKey("gravityy", dictionary));

                // speed
                this.modeA.speed = parseFloat(this._valueForKey("speed", dictionary));
                this.modeA.speedVar = parseFloat(this._valueForKey("speedVariance", dictionary));

                // radial acceleration
                var pszTmp = this._valueForKey("radialAcceleration", dictionary);
                this.modeA.radialAccel = (pszTmp) ? parseFloat(pszTmp) : 0;

                pszTmp = this._valueForKey("radialAccelVariance", dictionary);
                this.modeA.radialAccelVar = (pszTmp) ? parseFloat(pszTmp) : 0;

                // tangential acceleration
                pszTmp = this._valueForKey("tangentialAcceleration", dictionary);
                this.modeA.tangentialAccel = (pszTmp) ? parseFloat(pszTmp) : 0;

                pszTmp = this._valueForKey("tangentialAccelVariance", dictionary);
                this.modeA.tangentialAccelVar = (pszTmp) ? parseFloat(pszTmp) : 0;

            } else if (this._emitterMode == cc.PARTICLE_MODE_RADIUS) {
                // or Mode B: radius movement
                this.modeB.startRadius = parseFloat(this._valueForKey("maxRadius", dictionary));
                this.modeB.startRadiusVar = parseFloat(this._valueForKey("maxRadiusVariance", dictionary));
                this.modeB.endRadius = parseFloat(this._valueForKey("minRadius", dictionary));
                this.modeB.endRadiusVar = 0;
                this.modeB.rotatePerSecond = parseFloat(this._valueForKey("rotatePerSecond", dictionary));
                this.modeB.rotatePerSecondVar = parseFloat(this._valueForKey("rotatePerSecondVariance", dictionary));
            } else {
                cc.Assert(false, "Invalid emitterType in config file");
                return false;
            }

            // life span
            this._life = parseFloat(this._valueForKey("particleLifespan", dictionary));
            this._lifeVar = parseFloat(this._valueForKey("particleLifespanVariance", dictionary));

            // emission Rate
            this._emissionRate = this._totalParticles / this._life;

            //don't get the internal texture if a batchNode is used
            if (!this._batchNode) {
                // Set a compatible default for the alpha transfer
                this._opacityModifyRGB = false;

                // texture
                // Try to get the texture from the cache
                var textureName = this._valueForKey("textureFileName", dictionary);
                var fullpath = cc.FileUtils.getInstance().fullPathFromRelativeFile(textureName, this._plistFile);

                var tex = cc.TextureCache.getInstance().textureForKey(fullpath);

                if (tex) {
                    this._texture = tex;
                } else {
                    var textureData = this._valueForKey("textureImageData", dictionary);

                    if (textureData && textureData.length == 0) {
                        cc.Assert(textureData, "cc.ParticleSystem.initWithDictory:textureImageData is null");
                        tex = cc.TextureCache.getInstance().addImage(fullpath);
                        if (!tex)
                            return false;
                        this._texture = tex;
                    } else {
                        buffer = cc.unzipBase64AsArray(textureData, 1);
                        if (!buffer)
                            return false;
                        var newImageData = cc.encodeToBase64(buffer);
                        if (!newImageData)
                            return false;

                        var img = new Image();
                        img.src = "data:image/png;base64," + newImageData;
                        this._texture = img;

                        //save image to TextureCache
                        cc.TextureCache.getInstance().cacheImage(fullpath, img);
                    }
                }
                cc.Assert(this._texture != null, "cc.ParticleSystem: error loading the texture");
            }
            ret = true;
        }
        return ret;
    },

    /**
     * Initializes a system with a fixed number of particles
     * @param {Number} numberOfParticles
     * @return {Boolean}
     */
    initWithTotalParticles:function (numberOfParticles) {
        this._totalParticles = numberOfParticles;

        this._particles = [];

        if (!this._particles) {
            cc.log("Particle system: not enough memory");
            return false;
        }
        this._allocatedParticles = numberOfParticles;

        if (this._batchNode) {
            for (var i = 0; i < this._totalParticles; i++) {
                this._particles[i].atlasIndex = i;
            }
        }

        // default, active
        this._isActive = true;

        // default blend function
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;

        // default movement type;
        this._positionType = cc.PARTICLE_TYPE_FREE;

        // by default be in mode A:
        this._emitterMode = cc.PARTICLE_MODE_GRAVITY;

        // default: modulate
        // XXX: not used
        //	colorModulate = YES;
        this._isAutoRemoveOnFinish = false;

        // Optimization: compile udpateParticle method
        //updateParticleSel = @selector(updateQuadWithParticle:newPosition:);
        //updateParticleImp = (CC_UPDATE_PARTICLE_IMP) [self methodForSelector:updateParticleSel];

        //for batchNode
        this._transformSystemDirty = false;

        // udpate after action in run!
        this.scheduleUpdateWithPriority(1);

        return true;
    },

    destoryParticleSystem:function () {
        this.unscheduleUpdate();
    },

    /**
     * Add a particle to the emitter
     * @return {Boolean}
     */
    addParticle:function () {
        if (this.isFull()) {
            return false;
        }

        var particle = new cc.Particle();
        this.initParticle(particle);
        this._particles.push(particle);
        ++this._particleCount;

        return true;
    },

    /**
     * Initializes a particle
     * @param {cc.Particle} particle
     */
    initParticle:function (particle) {
        // timeToLive
        // no negative life. prevent division by 0
        particle.timeToLive = this._life + this._lifeVar * cc.RANDOM_MINUS1_1();
        particle.timeToLive = Math.max(0, particle.timeToLive);

        // position
        particle.pos.x = this._sourcePosition.x + this._posVar.x * cc.RANDOM_MINUS1_1();
        particle.pos.y = this._sourcePosition.y + this._posVar.y * cc.RANDOM_MINUS1_1();

        // Color
        var start = new cc.Color4F(
            cc.clampf(this._startColor.r + this._startColorVar.r * cc.RANDOM_MINUS1_1(), 0, 1),
            cc.clampf(this._startColor.g + this._startColorVar.g * cc.RANDOM_MINUS1_1(), 0, 1),
            cc.clampf(this._startColor.b + this._startColorVar.b * cc.RANDOM_MINUS1_1(), 0, 1),
            cc.clampf(this._startColor.a + this._startColorVar.a * cc.RANDOM_MINUS1_1(), 0, 1)
        );

        var end = new cc.Color4F(
            cc.clampf(this._endColor.r + this._endColorVar.r * cc.RANDOM_MINUS1_1(), 0, 1),
            cc.clampf(this._endColor.g + this._endColorVar.g * cc.RANDOM_MINUS1_1(), 0, 1),
            cc.clampf(this._endColor.b + this._endColorVar.b * cc.RANDOM_MINUS1_1(), 0, 1),
            cc.clampf(this._endColor.a + this._endColorVar.a * cc.RANDOM_MINUS1_1(), 0, 1)
        );

        particle.color = start;
        particle.deltaColor.r = (end.r - start.r) / particle.timeToLive;
        particle.deltaColor.g = (end.g - start.g) / particle.timeToLive;
        particle.deltaColor.b = (end.b - start.b) / particle.timeToLive;
        particle.deltaColor.a = (end.a - start.a) / particle.timeToLive;

        // size
        var startS = this._startSize + this._startSizeVar * cc.RANDOM_MINUS1_1();
        startS = Math.max(0, startS); // No negative value

        particle.size = startS;

        if (this._endSize == cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE) {
            particle.deltaSize = 0;
        } else {
            var endS = this._endSize + this._endSizeVar * cc.RANDOM_MINUS1_1();
            endS = Math.max(0, endS); // No negative values
            particle.deltaSize = (endS - startS) / particle.timeToLive;
        }

        // rotation
        var startA = this._startSpin + this._startSpinVar * cc.RANDOM_MINUS1_1();
        var endA = this._endSpin + this._endSpinVar * cc.RANDOM_MINUS1_1();
        particle.rotation = startA;
        particle.deltaRotation = (endA - startA) / particle.timeToLive;

        // position
        if (this._positionType == cc.PARTICLE_TYPE_FREE) {
            particle.startPos = this.convertToWorldSpace(cc.PointZero());

        } else if (this._positionType == cc.PARTICLE_TYPE_RELATIVE) {
            particle.startPos = this._position;
        }

        // direction
        var a = cc.DEGREES_TO_RADIANS(this._angle + this._angleVar * cc.RANDOM_MINUS1_1());

        // Mode Gravity: A
        if (this._emitterMode == cc.PARTICLE_MODE_GRAVITY) {
            var v = cc.p(Math.cos(a), Math.sin(a));
            var s = this.modeA.speed + this.modeA.speedVar * cc.RANDOM_MINUS1_1();

            // direction
            particle.modeA.dir = cc.pMult(v, s);

            // radial accel
            particle.modeA.radialAccel = this.modeA.radialAccel + this.modeA.radialAccelVar * cc.RANDOM_MINUS1_1();

            // tangential accel
            particle.modeA.tangentialAccel = this.modeA.tangentialAccel + this.modeA.tangentialAccelVar * cc.RANDOM_MINUS1_1();
        } else {
            // Mode Radius: B

            // Set the default diameter of the particle from the source position
            var startRadius = this.modeB.startRadius + this.modeB.startRadiusVar * cc.RANDOM_MINUS1_1();
            var endRadius = this.modeB.endRadius + this.modeB.endRadiusVar * cc.RANDOM_MINUS1_1();

            particle.modeB.radius = startRadius;

            if (this.modeB.endRadius == cc.PARTICLE_START_RADIUS_EQUAL_TO_END_RADIUS) {
                particle.modeB.deltaRadius = 0;
            } else {
                particle.modeB.deltaRadius = (endRadius - startRadius) / particle.timeToLive;
            }

            particle.modeB.angle = a;
            particle.modeB.degreesPerSecond = cc.DEGREES_TO_RADIANS(this.modeB.rotatePerSecond + this.modeB.rotatePerSecondVar * cc.RANDOM_MINUS1_1());
        }
    },

    /**
     * stop emitting particles. Running particles will continue to run until they die
     */
    stopSystem:function () {
        this._isActive = false;
        this._elapsed = this._duration;
        this._emitCounter = 0;
    },

    /**
     * Kill all living particles.
     */
    resetSystem:function () {
        this._isActive = true;
        this._elapsed = 0;
        for (this._particleIdx = 0; this._particleIdx < this._particleCount; ++this._particleIdx) {
            var p = this._particles[this._particleIdx];
            p.timeToLive = 0;
        }
    },

    /**
     * whether or not the system is full
     * @return {Boolean}
     */
    isFull:function () {
        return (this._particleCount >= this._totalParticles);
    },

    /**
     * should be overriden by subclasses
     * @param {cc.Particle} particle
     * @param {cc.Point} newPosition
     */
    updateQuadWithParticle:function (particle, newPosition) {
        // should be overriden
    },

    /**
     * should be overriden by subclasses
     */
    postStep:function () {
        // should be overriden
    },

    /**
     * update emitter's status
     * @override
     * @param {Number} dt delta time
     */
    update:function (dt) {
        if (this._isActive && this._emissionRate) {
            var rate = 1.0 / this._emissionRate;
            //issue #1201, prevent bursts of particles, due to too high emitCounter
            if (this._particleCount < this._totalParticles) {
                this._emitCounter += dt;
            }

            while ((this._particleCount < this._totalParticles) && (this._emitCounter > rate)) {
                this.addParticle();
                this._emitCounter -= rate;
            }

            this._elapsed += dt;
            if (this._duration != -1 && this._duration < this._elapsed) {
                this.stopSystem();
            }
        }
        this._particleIdx = 0;

        var currentPosition = cc.PointZero();
        if (this._positionType == cc.PARTICLE_TYPE_FREE) {
            currentPosition = this.convertToWorldSpace(cc.PointZero());
        } else if (this._positionType == cc.PARTICLE_TYPE_RELATIVE) {
            currentPosition = cc.p(this._position.x, this._position.y);
        }

        if (this._isVisible) {
            while (this._particleIdx < this._particleCount) {
                var selParticle = this._particles[this._particleIdx];

                // life
                selParticle.timeToLive -= dt;

                if (selParticle.timeToLive > 0) {
                    // Mode A: gravity, direction, tangential accel & radial accel
                    if (this._emitterMode == cc.PARTICLE_MODE_GRAVITY) {
                        var tmp, radial, tangential;

                        radial = cc.PointZero();
                        // radial acceleration
                        if (selParticle.pos.x || selParticle.pos.y)
                            radial = cc.pNormalize(selParticle.pos);

                        tangential = radial;
                        radial = cc.pMult(radial, selParticle.modeA.radialAccel);

                        // tangential acceleration
                        var newy = tangential.x;
                        tangential.x = -tangential.y;
                        tangential.y = newy;
                        tangential = cc.pMult(tangential, selParticle.modeA.tangentialAccel);

                        // (gravity + radial + tangential) * dt
                        tmp = cc.pAdd(cc.pAdd(radial, tangential), this.modeA.gravity);
                        tmp = cc.pMult(tmp, dt);
                        selParticle.modeA.dir = cc.pAdd(selParticle.modeA.dir, tmp);
                        tmp = cc.pMult(selParticle.modeA.dir, dt);
                        selParticle.pos = cc.pAdd(selParticle.pos, tmp);
                    } else {
                        // Mode B: radius movement

                        // Update the angle and radius of the particle.
                        selParticle.modeB.angle += selParticle.modeB.degreesPerSecond * dt;
                        selParticle.modeB.radius += selParticle.modeB.deltaRadius * dt;

                        selParticle.pos.x = -Math.cos(selParticle.modeB.angle) * selParticle.modeB.radius;
                        selParticle.pos.y = -Math.sin(selParticle.modeB.angle) * selParticle.modeB.radius;
                    }

                    // color
                    if (!this._dontTint) {
                        selParticle.color.r += (selParticle.deltaColor.r * dt);
                        selParticle.color.g += (selParticle.deltaColor.g * dt);
                        selParticle.color.b += (selParticle.deltaColor.b * dt);
                        selParticle.color.a += (selParticle.deltaColor.a * dt);
                        selParticle.isChangeColor = true;
                    }

                    // size
                    selParticle.size += (selParticle.deltaSize * dt);
                    selParticle.size = Math.max(0, selParticle.size);

                    // angle
                    selParticle.rotation += (selParticle.deltaRotation * dt);

                    //
                    // update values in quad
                    //
                    var newPos;
                    if (this._positionType == cc.PARTICLE_TYPE_FREE || this._positionType == cc.PARTICLE_TYPE_RELATIVE) {
                        var diff = cc.pSub(currentPosition, selParticle.startPos);
                        newPos = cc.pSub(selParticle.pos, diff);
                    } else {
                        newPos = selParticle.pos;
                    }

                    // translate newPos to correct position, since matrix transform isn't performed in batchnode
                    // don't update the particle with the new position information, it will interfere with the radius and tangential calculations
                    if (this._batchNode) {
                        newPos.x += this._position.x;
                        newPos.y += this._position.y;
                    }

                    if (cc.renderContextType == cc.WEBGL) {
                        this.updateQuadWithParticle(selParticle, newPos);
                    } else {
                        selParticle.drawPos = newPos;
                    }
                    //updateParticleImp(self, updateParticleSel, p, newPos);

                    // update particle counter
                    ++this._particleIdx;
                } else {
                    // life < 0
                    var currentIndex = selParticle.atlasIndex;
                    cc.ArrayRemoveObject(this._particles, selParticle);
                    if (this._batchNode) {
                        //disable the switched particle
                        this._batchNode.disableParticle(this._atlasIndex + currentIndex);

                        //switch indexes
                        this._particles[this._particleCount - 1].atlasIndex = currentIndex;
                    }

                    --this._particleCount;

                    if (this._particleCount == 0 && this._isAutoRemoveOnFinish) {
                        this.unscheduleUpdate();
                        this._parent.removeChild(this, true);
                        return;
                    }
                }
            }
            this._transformSystemDirty = false;
        }

        if (!this._batchNode)
            this.postStep();

        //cc.PROFILER_STOP_CATEGORY(kCCProfilerCategoryParticles , "cc.ParticleSystem - update");
    },

    updateWithNoTime:function () {
        this.update(0);
    },

    /**
     * return the string found by key in dict.
     * @param {string} key
     * @param {object} dict
     * @return {String} "" if not found; return the string if found.
     * @private
     */
    _valueForKey:function (key, dict) {
        if (dict) {
            var pString = dict[key];
            return pString != null ? pString : "";
        }
        return "";
    },

    _updateBlendFunc:function () {
        cc.Assert(!this._batchNode, "Can't change blending functions when the particle is being batched");

        if (this._texture) {
            if ((this._texture instanceof HTMLImageElement) || (this._texture instanceof HTMLCanvasElement)) {

            } else {
                var premultiplied = this._texture.hasPremultipliedAlpha();
                this._opacityModifyRGB = false;

                if (this._texture && ( this._blendFunc.src == cc.BLEND_SRC && this._blendFunc.dst == cc.BLEND_DST )) {
                    if (premultiplied) {
                        this._opacityModifyRGB = true;
                    } else {
                        this._blendFunc.src = gl.SRC_ALPHA;
                        this._blendFunc.dst = gl.ONE_MINUS_SRC_ALPHA;
                    }
                }
            }
        }
    }
});

cc.encodeToBase64 = function (data) {
    return btoa(String.fromCharCode.apply(data, data)).replace(/.{76}(?=.)/g, '$&\n');
};

/**
 * <p> return the string found by key in dict. <br/>
 *    This plist files can be creted manually or with Particle Designer:<br/>
 *    http://particledesigner.71squared.com/<br/>
 * </p>
 * @param {String} plistFile
 * @return {cc.ParticleSystem}
 */
cc.ParticleSystem.create = function (plistFile) {
    var ret = new cc.ParticleSystem();
    if (ret && ret.initWithFile(plistFile)) {
        return ret;
    }
    return null;
};

// Different modes
/**
 * Mode A:Gravity + Tangential Accel + Radial Accel
 * @Class
 * @Construct
 * @param {cc.Point} gravity Gravity value.
 * @param {Number} speed speed of each particle.
 * @param {Number} speedVar speed variance of each particle.
 * @param {Number} tangentialAccel tangential acceleration of each particle.
 * @param {Number} tangentialAccelVar tangential acceleration variance of each particle.
 * @param {Number} radialAccel radial acceleration of each particle.
 * @param {Number} radialAccelVar radial acceleration variance of each particle.
 */
cc.ParticleSystem.ModeA = function (gravity, speed, speedVar, tangentialAccel, tangentialAccelVar, radialAccel, radialAccelVar) {
    /** Gravity value. Only available in 'Gravity' mode. */
    this.gravity = gravity ? gravity : cc.PointZero();
    /** speed of each particle. Only available in 'Gravity' mode.  */
    this.speed = speed || 0;
    /** speed variance of each particle. Only available in 'Gravity' mode. */
    this.speedVar = speedVar || 0;
    /** tangential acceleration of each particle. Only available in 'Gravity' mode. */
    this.tangentialAccel = tangentialAccel || 0;
    /** tangential acceleration variance of each particle. Only available in 'Gravity' mode. */
    this.tangentialAccelVar = tangentialAccelVar || 0;
    /** radial acceleration of each particle. Only available in 'Gravity' mode. */
    this.radialAccel = radialAccel || 0;
    /** radial acceleration variance of each particle. Only available in 'Gravity' mode. */
    this.radialAccelVar = radialAccelVar || 0;
};

/**
 * Mode B: circular movement (gravity, radial accel and tangential accel don't are not used in this mode)
 * @Class
 * @Construct
 * @param {Number} startRadius The starting radius of the particles.
 * @param {Number} startRadiusVar The starting radius variance of the particles.
 * @param {Number} endRadius The ending radius of the particles.
 * @param {Number} endRadiusVar The ending radius variance of the particles.
 * @param {Number} rotatePerSecond Number of degress to rotate a particle around the source pos per second.
 * @param {Number} rotatePerSecondVar Variance in degrees for rotatePerSecond.
 */
cc.ParticleSystem.ModeB = function (startRadius, startRadiusVar, endRadius, endRadiusVar, rotatePerSecond, rotatePerSecondVar) {
    /** The starting radius of the particles. Only available in 'Radius' mode. */
    this.startRadius = startRadius || 0;
    /** The starting radius variance of the particles. Only available in 'Radius' mode. */
    this.startRadiusVar = startRadiusVar || 0;
    /** The ending radius of the particles. Only available in 'Radius' mode. */
    this.endRadius = endRadius || 0;
    /** The ending radius variance of the particles. Only available in 'Radius' mode. */
    this.endRadiusVar = endRadiusVar || 0;
    /** Number of degress to rotate a particle around the source pos per second. Only available in 'Radius' mode. */
    this.rotatePerSecond = rotatePerSecond || 0;
    /** Variance in degrees for rotatePerSecond. Only available in 'Radius' mode. */
    this.rotatePerSecondVar = rotatePerSecondVar || 0;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * <p>
 *     CCParticleSystemQuad is a subclass of CCParticleSystem<br/>
 *     <br/>
 *     It includes all the features of ParticleSystem.<br/>
 *     <br/>
 *     Special features and Limitations:<br/>
 *      - Particle size can be any float number. <br/>
 *      - The system can be scaled <br/>
 *      - The particles can be rotated     <br/>
 *      - It supports subrects   <br/>
 *      - It supports batched rendering since 1.1<br/>
 * </p>
 * @class
 * @extends cc.ParticleSystem
 * @example
 * //create a particle system
 *   this._emitter = new cc.ParticleSystemQuad();
 *   this._emitter.initWithTotalParticles(150);
 */
cc.ParticleSystemQuad = cc.ParticleSystem.extend(/** @lends cc.ParticleSystemQuad# */{
    // quads to be rendered
    _quads:null,
    // indices
    _indices:null,

    _VAOname:0,
    //0: vertex  1: indices
    _buffersVBO:[],

    _pointRect:null,
    /**
     * Constructor
     * @override
     */
    ctor:function () {
        this._super();
        this._buffersVBO = [0, 0];
        this._quads = [];
    },

    /**
     * initialices the indices for the vertices
     */
    setupIndices:function () {
        for (var i = 0; i < this._totalParticles; ++i) {
            var i6 = i * 6;
            var i4 = i * 4;
            this._indices[i6 + 0] = i4 + 0;
            this._indices[i6 + 1] = i4 + 1;
            this._indices[i6 + 2] = i4 + 2;

            this._indices[i6 + 5] = i4 + 1;
            this._indices[i6 + 4] = i4 + 2;
            this._indices[i6 + 3] = i4 + 3;
        }
    },

    /**
     * <p> initilizes the texture with a rectangle measured Points<br/>
     * pointRect should be in Texture coordinates, not pixel coordinates
     * </p>
     * @param {cc.Rect} pointRect
     */
    initTexCoordsWithRect:function (pointRect) {
        // convert to pixels coords
        var rect = cc.rect(
            pointRect.origin.x * cc.CONTENT_SCALE_FACTOR(),
            pointRect.origin.y * cc.CONTENT_SCALE_FACTOR(),
            pointRect.size.width * cc.CONTENT_SCALE_FACTOR(),
            pointRect.size.height * cc.CONTENT_SCALE_FACTOR());

        var wide = pointRect.size.width;
        var high = pointRect.size.height;

        if (this._texture) {
            if ((this._texture instanceof HTMLImageElement) || (this._texture instanceof HTMLCanvasElement)) {
                wide = this._texture.width;
                high = this._texture.height;
            } else {
                wide = this._texture.getPixelsWide();
                high = this._texture.getPixelsHigh();
            }
        }

        var left, bottom, right, top;
        if (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL) {
            left = (rect.origin.x * 2 + 1) / (wide * 2);
            bottom = (rect.origin.y * 2 + 1) / (high * 2);
            right = left + (rect.size.width * 2 - 2) / (wide * 2);
            top = bottom + (rect.size.height * 2 - 2) / (high * 2);
        } else {
            left = rect.origin.x / wide;
            bottom = rect.origin.y / high;
            right = left + rect.size.width / wide;
            top = bottom + rect.size.height / high;
        }

        // Important. Texture in cocos2d are inverted, so the Y component should be inverted
        var temp = top;
        top = bottom;
        bottom = temp;

        var quads = null;
        var start = 0, end = 0;
        if (this._batchNode) {
            quads = this._batchNode.getTextureAtlas().getQuads();
            start = this._atlasIndex;
            end = this._atlasIndex + this._totalParticles;
        } else {
            quads = this._quads;
            start = 0;
            end = this._totalParticles;
        }

        for (var i = start; i < this.end; i++) {
            if (!quads[i]) {
                quads[i] = cc.V3F_C4B_T2F_QuadZero();
            }

            // bottom-left vertex:
            quads[i].bl.texCoords.u = left;
            quads[i].bl.texCoords.v = bottom;
            // bottom-right vertex:
            quads[i].br.texCoords.u = right;
            quads[i].br.texCoords.v = bottom;
            // top-left vertex:
            quads[i].tl.texCoords.u = left;
            quads[i].tl.texCoords.v = top;
            // top-right vertex:
            quads[i].tr.texCoords.u = right;
            quads[i].tr.texCoords.v = top;
        }
    },

    /**
     * <p> Sets a new CCSpriteFrame as particle.</br>
     * WARNING: this method is experimental. Use setTexture:withRect instead.
     * </p>
     * @param {cc.SpriteFrame} spriteFrame
     */
    setDisplayFrame:function (spriteFrame) {
        cc.Assert(cc.Point.CCPointEqualToPoint(spriteFrame.getOffsetInPixels(), cc.PointZero()), "QuadParticle only supports SpriteFrames with no offsets");

        // update texture before updating texture rect
        if (!this._texture || spriteFrame.getTexture().getName() != this._texture.getName()) {
            this.setTexture(spriteFrame.getTexture());
        }
    },

    /**
     *  Sets a new texture with a rect. The rect is in Points.
     * @param {cc.Texture2D} texture
     * @param {cc.Rect} rect
     */
    setTextureWithRect:function (texture, rect) {
        if (texture instanceof  cc.Texture2D) {
            // Only update the texture if is different from the current one
            if (!this._texture || texture.getName() != this._texture.getName()) {
                this.setTexture(texture, true);
            }
            this._pointRect = rect;
            this.initTexCoordsWithRect(rect);
        }
        if (texture  instanceof HTMLImageElement) {
            if (!this._texture || texture != this._texture) {
                this.setTexture(texture, true);
            }
            this._pointRect = rect;
            this.initTexCoordsWithRect(rect);
        }
    },

    // super methods
    // overriding the init method
    /**
     * Initializes a system with a fixed number of particles
     * @override
     * @param {Number} numberOfParticles
     * @return {Boolean}
     */
    initWithTotalParticles:function (numberOfParticles) {
        // base initialization
        if (this._super(numberOfParticles)) {
            // allocating data space
            if (!this._allocMemory()) {
                return false;
            }
            this.setupIndices();
            if (cc.TEXTURE_ATLAS_USE_VAO) {
                this._setupVBOandVAO();
            } else {
                this._setupVBO();
            }

            //this.setShaderProgram(cc.ShaderCache.getInstance().programForKey(kCCShader_PositionTextureColor));

            // Need to listen the event only when not use batchnode, because it will use VBO
            //extension.CCNotificationCenter.sharedNotificationCenter().addObserver(this,
            //    callfuncO_selector(cc.ParticleSystemQuad.listenBackToForeground),
            //    EVNET_COME_TO_FOREGROUND,
            //    null);

            return true;
        }
        return false;
    },

    /**
     * set Texture of Particle System
     * @override
     * @param {HTMLImageElement|HTMLCanvasElement|cc.Texture2D} texture
     * @param {Boolean} isCallSuper is direct call super method
     */
    setTexture:function (texture, isCallSuper) {
        if (isCallSuper) {
            if (isCallSuper == true) {
                this._super(texture);
                return;
            }
        }
        var size = null;
        if ((texture instanceof HTMLImageElement) || (texture instanceof HTMLCanvasElement)) {
            size = cc.size(texture.width, texture.height);
        } else {
            size = texture.getContentSize();
        }

        this.setTextureWithRect(texture, cc.rect(0, 0, size.width, size.height));
    },

    /**
     * update particle's quad
     * @override
     * @param {cc.Particle} particle
     * @param {cc.Point} newPosition
     */
    updateQuadWithParticle:function (particle, newPosition) {
        // colors
        var quad = null;
        if (this._batchNode) {
            var batchQuads = this._batchNode.getTextureAtlas().getQuads();
            quad = batchQuads[this._atlasIndex + particle.atlasIndex]
        } else {
            quad = this._quads[this._particleIdx];
        }

        var color = (this._opacityModifyRGB) ?
            new cc.Color4B(0 | (particle.color.r * particle.color.a * 255), 0 | (particle.color.g * particle.color.a * 255),
                0 | (particle.color.b * particle.color.a * 255), 0 | (particle.color.a * 255)) :
            new cc.Color4B(0 | (particle.color.r * 255), 0 | (particle.color.g * 255), 0 | (particle.color.b * 255), 0 | (particle.color.a * 255));

        quad.bl.colors = color;
        quad.br.colors = color;
        quad.tl.colors = color;
        quad.tr.colors = color;

        // vertices
        var size_2 = particle.size / 2;
        if (particle.rotation) {
            var x1 = -size_2;
            var y1 = -size_2;

            var x2 = size_2;
            var y2 = size_2;
            var x = newPosition.x;
            var y = newPosition.y;

            var r = -cc.DEGREES_TO_RADIANS(particle.rotation);
            var cr = Math.cos(r);
            var sr = Math.sin(r);
            var ax = x1 * cr - y1 * sr + x;
            var ay = x1 * sr + y1 * cr + y;
            var bx = x2 * cr - y1 * sr + x;
            var by = x2 * sr + y1 * cr + y;
            var cx = x2 * cr - y2 * sr + x;
            var cy = x2 * sr + y2 * cr + y;
            var dx = x1 * cr - y2 * sr + x;
            var dy = x1 * sr + y2 * cr + y;

            // bottom-left
            quad.bl.vertices.x = ax;
            quad.bl.vertices.y = ay;

            // bottom-right vertex:
            quad.br.vertices.x = bx;
            quad.br.vertices.y = by;

            // top-left vertex:
            quad.tl.vertices.x = dx;
            quad.tl.vertices.y = dy;

            // top-right vertex:
            quad.tr.vertices.x = cx;
            quad.tr.vertices.y = cy;
        } else {
            // bottom-left vertex:
            quad.bl.vertices.x = newPosition.x - size_2;
            quad.bl.vertices.y = newPosition.y - size_2;

            // bottom-right vertex:
            quad.br.vertices.x = newPosition.x + size_2;
            quad.br.vertices.y = newPosition.y - size_2;

            // top-left vertex:
            quad.tl.vertices.x = newPosition.x - size_2;
            quad.tl.vertices.y = newPosition.y + size_2;

            // top-right vertex:
            quad.tr.vertices.x = newPosition.x + size_2;
            quad.tr.vertices.y = newPosition.y + size_2;
        }
    },

    /**
     * override cc.ParticleSystem
     * @override
     */
    postStep:function () {
        if (cc.renderContextType == cc.CANVAS) {

        } else {
            //TODO
            glBindBuffer(GL_ARRAY_BUFFER, this._buffersVBO[0]);
            glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(this._quads[0]) * particleCount, this._quads);
            glBindBuffer(GL_ARRAY_BUFFER, 0);

            CHECK_GL_ERROR_DEBUG();
        }
    },

    /**
     * draw particle
     * @param {CanvasContext} ctx CanvasContext
     * @override
     */
    draw:function (ctx) {
        cc.Assert(!this._batchNode, "draw should not be called when added to a particleBatchNode");
        this._super();
        if (cc.renderContextType == cc.CANVAS) {
            var context = ctx || cc.renderContext;
            context.save();
            if (this.isBlendAdditive()) {
                context.globalCompositeOperation = 'lighter';
            } else {
                context.globalCompositeOperation = 'source-over';
            }

            for (var i = 0; i < this._particleCount; i++) {
                var particle = this._particles[i];
                var lpx = (0 | (particle.size * 0.5));

                //TODO these are temporary code, need modifier
                if (this._drawMode == cc.PARTICLE_TEXTURE_MODE) {
                    var drawTexture = this.getTexture();
                    if (particle.isChangeColor) {
                        var cacheTextureForColor = cc.TextureCache.getInstance().getTextureColors(this.getTexture());
                        if (cacheTextureForColor) {
                            drawTexture = cc.generateTintImage(this.getTexture(), cacheTextureForColor, particle.color, this._pointRect);
                        }
                    }

                    context.save();
                    context.globalAlpha = particle.color.a;
                    context.translate(0 | particle.drawPos.x, -(0 | particle.drawPos.y));
                    context.drawImage(drawTexture,
                        lpx, -(lpx + particle.size),
                        particle.size, particle.size);
                    context.restore();
                } else {
                    context.save();
                    context.globalAlpha = particle.color.a;
                    context.translate(0 | particle.drawPos.x, -(0 | particle.drawPos.y));
                    if (this._shapeType == cc.PARTICLE_STAR_SHAPE) {
                        cc.drawingUtil.drawStar(context, cc.p(0, 0), lpx, particle.color);
                    } else {
                        cc.drawingUtil.drawColorBall(context, cc.p(0, 0), lpx, particle.color);
                    }
                    context.restore()
                }
            }
            context.restore();
        } else {
            cc.NODE_DRAW_SETUP();

            ccGLBindTexture2D(this._texture.getName());
            ccGLBlendFunc(m_tBlendFunc.src, m_tBlendFunc.dst);

            cc.Assert(this._particleIdx == this._particleCount, "Abnormal error in particle quad");

            if (cc.TEXTURE_ATLAS_USE_VAO) {
                //
                // Using VBO and VAO
                //
                glBindVertexArray(this._VAOname);

                if (cc.REBIND_INDICES_BUFFER)
                    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);

                glDrawElements(GL_TRIANGLES, this._particleIdx * 6, GL_UNSIGNED_SHORT, 0);

                if (cc.REBIND_INDICES_BUFFER)
                    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

                glBindVertexArray(0);
            } else {
                //
                // Using VBO without VAO
                //
                var kQuadSize = sizeof(m_pQuads[0].bl);

                ccGLEnableVertexAttribs(kCCVertexAttribFlag_PosColorTex);

                glBindBuffer(GL_ARRAY_BUFFER, this._buffersVBO[0]);
                // vertices
                glVertexAttribPointer(kCCVertexAttrib_Position, 3, GL_FLOAT, GL_FALSE, kQuadSize, offsetof(ccV3F_C4B_T2F, vertices));
                // colors
                glVertexAttribPointer(kCCVertexAttrib_Color, 4, GL_UNSIGNED_BYTE, GL_TRUE, kQuadSize, offsetof(ccV3F_C4B_T2F, colors));
                // tex coords
                glVertexAttribPointer(kCCVertexAttrib_TexCoords, 2, GL_FLOAT, GL_FALSE, kQuadSize, offsetof(ccV3F_C4B_T2F, texCoords));

                glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);

                glDrawElements(GL_TRIANGLES, this._particleIdx * 6, GL_UNSIGNED_SHORT, 0);

                glBindBuffer(GL_ARRAY_BUFFER, 0);
                glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
            }
            CHECK_GL_ERROR_DEBUG();
        }

        cc.INCREMENT_GL_DRAWS(1);
    },

    setBatchNode:function (batchNode) {
        if (this._batchNode != batchNode) {
            var oldBatch = this._batchNode;

            this._super(batchNode);

            // NEW: is self render ?
            if (!batchNode) {
                this._allocMemory();
                this.setupIndices();
                this.setTexture(oldBatch.getTexture());
                if (cc.TEXTURE_ATLAS_USE_VAO)
                    this._setupVBOandVAO();
                else
                    this._setupVBO();
            }
            // OLD: was it self render ? cleanup
            else if (!oldBatch) {
                // copy current state to batch
                var batchQuads = this._batchNode.getTextureAtlas().getQuads();
                var quad = batchQuads[this._atlasIndex];
                //memcpy( quad, m_pQuads, m_uTotalParticles * sizeof(m_pQuads[0]) );

                glDeleteBuffers(2, this._buffersVBO[0]);
                if (cc.TEXTURE_ATLAS_USE_VAO)
                    glDeleteVertexArrays(1, this._VAOname);
            }
        }
    },

    setTotalParticles:function (tp) {
        this._totalParticles = tp;
        return;

        // If we are setting the total numer of particles to a number higher
        // than what is allocated, we need to allocate new arrays
        if (tp > m_uAllocatedParticles) {
            // Allocate new memory
            var particlesSize = tp * sizeof(tCCParticle);
            var quadsSize = sizeof(this._quads[0]) * tp * 1;
            var indicesSize = sizeof(m_pIndices[0]) * tp * 6 * 1;

            //var particlesNew = (tCCParticle*)realloc(m_pParticles, particlesSize);
            //ccV3F_C4B_T2F_Quad* quadsNew = (ccV3F_C4B_T2F_Quad*)realloc(m_pQuads, quadsSize);
            //GLushort* indicesNew = (GLushort*)realloc(m_pIndices, indicesSize);

            if (particlesNew && quadsNew && indicesNew) {
                // Assign pointers
                m_pParticles = particlesNew;
                m_pQuads = quadsNew;
                m_pIndices = indicesNew;

                // Clear the memory
                memset(m_pParticles, 0, particlesSize);
                memset(m_pQuads, 0, quadsSize);
                memset(m_pIndices, 0, indicesSize);

                m_uAllocatedParticles = tp;
            } else {
                // Out of memory, failed to resize some array
                if (particlesNew) m_pParticles = particlesNew;
                if (quadsNew) m_pQuads = quadsNew;
                if (indicesNew) m_pIndices = indicesNew;

                cc.log("Particle system: out of memory");
                return;
            }

            m_uTotalParticles = tp;

            // Init particles
            if (this._batchNode) {
                for (var i = 0; i < m_uTotalParticles; i++) {
                    this._particles[i].atlasIndex = i;
                }
            }

            this.setupIndices();
            if (cc.TEXTURE_ATLAS_USE_VAO)
                this._setupVBOandVAO();
            else
                this._setupVBO();

        }
        else {
            m_uTotalParticles = tp;
        }
    },

    /**
     * listen the event that coming to foreground on Android
     * @param {cc.Class} obj
     */
    listenBackToForeground:function (obj) {
        if (cc.TEXTURE_ATLAS_USE_VAO)
            this._setupVBOandVAO();
        else
            this._setupVBO();
    },

    _setupVBOandVAO:function () {
        if (cc.renderContextType == cc.CANVAS) {
            return;
        }

        glGenVertexArrays(1, this._VAOname);
        glBindVertexArray(this._VAOname);

        var kQuadSize = sizeof(m_pQuads[0].bl)

        glGenBuffers(2, this._buffersVBO[0]);

        glBindBuffer(GL_ARRAY_BUFFER, this._buffersVBO[0]);
        glBufferData(GL_ARRAY_BUFFER, sizeof(this._quads[0]) * this._totalParticles, this._quads, GL_DYNAMIC_DRAW);

        // vertices
        glEnableVertexAttribArray(kCCVertexAttrib_Position);
        glVertexAttribPointer(kCCVertexAttrib_Position, 2, GL_FLOAT, GL_FALSE, kQuadSize, offsetof(ccV3F_C4B_T2F, vertices));

        // colors
        glEnableVertexAttribArray(kCCVertexAttrib_Color);
        glVertexAttribPointer(kCCVertexAttrib_Color, 4, GL_UNSIGNED_BYTE, GL_TRUE, kQuadSize, offsetof(ccV3F_C4B_T2F, colors));

        // tex coords
        glEnableVertexAttribArray(kCCVertexAttrib_TexCoords);
        glVertexAttribPointer(kCCVertexAttrib_TexCoords, 2, GL_FLOAT, GL_FALSE, kQuadSize, offsetof(ccV3F_C4B_T2F, texCoords));

        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(m_pIndices[0]) * m_uTotalParticles * 6, m_pIndices, GL_STATIC_DRAW);

        glBindVertexArray(0);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
        glBindBuffer(GL_ARRAY_BUFFER, 0);

        CHECK_GL_ERROR_DEBUG();
    },

    _setupVBO:function () {
        if (cc.renderContextType == cc.CANVAS) {
            return;
        }

        glGenBuffers(2, this._buffersVBO[0]);

        glBindBuffer(GL_ARRAY_BUFFER, this._buffersVBO[0]);
        glBufferData(GL_ARRAY_BUFFER, sizeof(m_pQuads[0]) * m_uTotalParticles, m_pQuads, GL_DYNAMIC_DRAW);
        glBindBuffer(GL_ARRAY_BUFFER, 0);

        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(m_pIndices[0]) * m_uTotalParticles * 6, m_pIndices, GL_STATIC_DRAW);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

        CHECK_GL_ERROR_DEBUG();
    },

    _allocMemory:function () {
        //cc.Assert(( !this._quads && !this._indices), "Memory already alloced");
        cc.Assert(!this._batchNode, "Memory should not be alloced when not using batchNode");
        this._quads = [];
        this._indices = [];
        for (var i = 0; i < this._totalParticles; i++) {
            this._quads[i] = new cc.V3F_C4B_T2F_Quad();
            this._indices[i * 6] = 0;
            this._indices[(i * 6) + 1] = 0;
            this._indices[(i * 6) + 2] = 0;
            this._indices[(i * 6) + 3] = 0;
            this._indices[(i * 6) + 4] = 0;
            this._indices[(i * 6) + 5] = 0;
        }

        if (!this._quads || !this._indices) {
            cc.log("cocos2d: Particle system: not enough memory");
            return false;
        }

        return true;
    }
});

/**
 * <p>
 *   creates an initializes a CCParticleSystemQuad from a plist file.<br/>
 *   This plist files can be creted manually or with Particle Designer:<br/>
 *   http://particledesigner.71squared.com/<br/>
 * </p>
 * @param {String} pListFile
 * @return {cc.ParticleSystem}
 * @example
 *  //creates an initializes a CCParticleSystemQuad from a plist file.
 *  var system = cc.ParticleSystemQuad.create("Images/SpinningPeas.plist");
 */
cc.ParticleSystemQuad.create = function (pListFile) {
    var ret = new cc.ParticleSystemQuad();
    if (ret && ret.initWithFile(pListFile)) {
        return ret;
    }
    return null;
};

cc.ARCH_OPTIMAL_PARTICLE_SYSTEM = cc.ParticleSystemQuad;
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * A fire particle system
 * @class
 * @extends cc.ParticleSystemQuad
 *
 * @example
 * var emitter = cc.ParticleFire.create();
 */
cc.ParticleFire = cc.ParticleSystemQuad.extend(/** @lends cc.ParticleFire# */{
    /**
     * initialize a fire particle system
     * @return {Boolean}
     */
    init:function () {
        return this.initWithTotalParticles(150);
        //return this.initWithTotalParticles(250);
    },

    /**
     * initialize a fire particle system with number Of Particles
     * @param {Number} numberOfParticles
     * @return {Boolean}
     */
    initWithTotalParticles:function (numberOfParticles) {
        if (this._super(numberOfParticles)) {
            // duration
            this._duration = cc.PARTICLE_DURATION_INFINITY;

            // Gravity Mode
            this._emitterMode = cc.PARTICLE_MODE_GRAVITY;

            // Gravity Mode: gravity
            this.modeA.gravity = cc.p(0, 0);

            // Gravity Mode: radial acceleration
            this.modeA.radialAccel = 0;
            this.modeA.radialAccelVar = 0;

            // Gravity Mode: speed of particles
            this.modeA.speed = 60;
            this.modeA.speedVar = 20;

            // starting angle
            this._angle = 90;
            this._angleVar = 10;

            // emitter position
            var winSize = cc.Director.getInstance().getWinSize();
            this.setPosition(cc.p(winSize.width / 2, 60));
            this._posVar = cc.p(40, 20);

            // life of particles
            this._life = 3;
            this._lifeVar = 0.25;


            // size, in pixels
            this._startSize = 54.0;
            this._startSizeVar = 10.0;
            this._endSize = cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE;

            // emits per frame
            this._emissionRate = this._totalParticles / this._life;

            // color of particles
            this._startColor.r = 0.76;
            this._startColor.g = 0.25;
            this._startColor.b = 0.12;
            this._startColor.a = 1.0;
            this._startColorVar.r = 0.0;
            this._startColorVar.g = 0.0;
            this._startColorVar.b = 0.0;
            this._startColorVar.a = 0.0;
            this._endColor.r = 0.0;
            this._endColor.g = 0.0;
            this._endColor.b = 0.0;
            this._endColor.a = 1.0;
            this._endColorVar.r = 0.0;
            this._endColorVar.g = 0.0;
            this._endColorVar.b = 0.0;
            this._endColorVar.a = 0.0;

            // additive
            this.setBlendAdditive(true);
            return true;
        }
        return false;
    }
});

/**
 * Create a fire particle system
 * @return {cc.ParticleFire}
 *
 * @example
 * var emitter = cc.ParticleFire.create();
 */
cc.ParticleFire.create = function () {
    var ret = new cc.ParticleFire();
    if (ret.init()) {
        return ret;
    }
    return null;
};

/**
 * A fireworks particle system
 * @class
 * @extends cc.ParticleSystemQuad
 *
 * @example
 * var emitter = cc.ParticleFireworks.create();
 */
cc.ParticleFireworks = cc.ParticleSystemQuad.extend(/** @lends cc.ParticleFireworks# */{
    /**
     * initialize a fireworks particle system
     * @return {Boolean}
     */
    init:function () {
        //return this.initWithTotalParticles(1500);
        return this.initWithTotalParticles(150);
    },

    /**
     * initialize a fireworks particle system with number Of Particles
     * @param {Number} numberOfParticles
     * @return {Boolean}
     */
    initWithTotalParticles:function (numberOfParticles) {
        if (this._super(numberOfParticles)) {
            // duration
            this._duration = cc.PARTICLE_DURATION_INFINITY;

            // Gravity Mode
            this._emitterMode = cc.PARTICLE_MODE_GRAVITY;

            // Gravity Mode: gravity
            this.modeA.gravity = cc.p(0, -90);

            // Gravity Mode:  radial
            this.modeA.radialAccel = 0;
            this.modeA.radialAccelVar = 0;

            //  Gravity Mode: speed of particles
            this.modeA.speed = 180;
            this.modeA.speedVar = 50;

            // emitter position
            var winSize = cc.Director.getInstance().getWinSize();
            this.setPosition(cc.p(winSize.width / 2, winSize.height / 2));

            // angle
            this._angle = 90;
            this._angleVar = 20;

            // life of particles
            this._life = 3.5;
            this._lifeVar = 1;

            // emits per frame
            this._emissionRate = this._totalParticles / this._life;

            // color of particles
            this._startColor.r = 0.5;
            this._startColor.g = 0.5;
            this._startColor.b = 0.5;
            this._startColor.a = 1.0;
            this._startColorVar.r = 0.5;
            this._startColorVar.g = 0.5;
            this._startColorVar.b = 0.5;
            this._startColorVar.a = 0.1;
            this._endColor.r = 0.1;
            this._endColor.g = 0.1;
            this._endColor.b = 0.1;
            this._endColor.a = 0.2;
            this._endColorVar.r = 0.1;
            this._endColorVar.g = 0.1;
            this._endColorVar.b = 0.1;
            this._endColorVar.a = 0.2;

            // size, in pixels
            this._startSize = 8.0;
            this._startSizeVar = 2.0;
            this._endSize = cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE;

            // additive
            this.setBlendAdditive(false);
            return true;
        }
        return false;
    }
});

/**
 * Create a fireworks particle system
 * @return {cc.ParticleFireworks}
 *
 * @example
 * var emitter = cc.ParticleFireworks.create();
 */
cc.ParticleFireworks.create = function () {
    var ret = new cc.ParticleFireworks();
    if (ret.init()) {
        return ret;
    }
    return null;
};

/**
 * A sun particle system
 * @class
 * @extends cc.ParticleSystemQuad
 *
 * @example
 * var emitter = cc.ParticleSun.create();
 */
cc.ParticleSun = cc.ParticleSystemQuad.extend(/** @lends cc.ParticleSun# */{
    /**
     * initialize a sun particle system
     * @return {Boolean}
     */
    init:function () {
        //return this.initWithTotalParticles(350);
        return this.initWithTotalParticles(150);
    },

    /**
     * initialize a sun particle system with number Of Particles
     * @param {Number} numberOfParticles
     * @return {Boolean}
     */
    initWithTotalParticles:function (numberOfParticles) {
        if (this._super(numberOfParticles)) {
            // additive
            this.setBlendAdditive(true);

            // duration
            this._duration = cc.PARTICLE_DURATION_INFINITY;

            // Gravity Mode
            this._emitterMode = cc.PARTICLE_MODE_GRAVITY;

            // Gravity Mode: gravity
            this.modeA.gravity = cc.p(0, 0);

            // Gravity mode: radial acceleration
            this.modeA.radialAccel = 0;
            this.modeA.radialAccelVar = 0;

            // Gravity mode: speed of particles
            this.modeA.speed = 20;
            this.modeA.speedVar = 5;


            // angle
            this._angle = 90;
            this._angleVar = 360;

            // emitter position
            var winSize = cc.Director.getInstance().getWinSize();
            this.setPosition(cc.p(winSize.width / 2, winSize.height / 2));
            this._posVar = cc.PointZero();

            // life of particles
            this._life = 1;
            this._lifeVar = 0.5;

            // size, in pixels
            this._startSize = 30.0;
            this._startSizeVar = 10.0;
            this._endSize = cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE;

            // emits per seconds
            this._emissionRate = this._totalParticles / this._life;

            // color of particles
            this._startColor.r = 0.76;
            this._startColor.g = 0.25;
            this._startColor.b = 0.12;
            this._startColor.a = 1.0;
            this._startColorVar.r = 0.0;
            this._startColorVar.g = 0.0;
            this._startColorVar.b = 0.0;
            this._startColorVar.a = 0.0;
            this._endColor.r = 0.0;
            this._endColor.g = 0.0;
            this._endColor.b = 0.0;
            this._endColor.a = 1.0;
            this._endColorVar.r = 0.0;
            this._endColorVar.g = 0.0;
            this._endColorVar.b = 0.0;
            this._endColorVar.a = 0.0;

            return true;
        }
        return false;
    }
});

/**
 * Create a sun particle system
 * @return {cc.ParticleSun}
 *
 * @example
 * var emitter = cc.ParticleSun.create();
 */
cc.ParticleSun.create = function () {
    var ret = new cc.ParticleSun();
    if (ret.init()) {
        return ret;
    }
    return null;
};

//! @brief A  particle system
/**
 * A galaxy particle system
 * @class
 * @extends cc.ParticleSystemQuad
 *
 * @example
 * var emitter = cc.ParticleGalaxy.create();
 */
cc.ParticleGalaxy = cc.ParticleSystemQuad.extend(/** @lends cc.ParticleGalaxy# */{
    /**
     * initialize a galaxy particle system
     * @return {Boolean}
     */
    init:function () {
        //return this.initWithTotalParticles(200);
        return this.initWithTotalParticles(100);
    },

    /**
     * initialize a galaxy particle system with number Of Particles
     * @param {Number} numberOfParticles
     * @return {Boolean}
     */
    initWithTotalParticles:function (numberOfParticles) {
        if (this._super(numberOfParticles)) {
            // duration
            this._duration = cc.PARTICLE_DURATION_INFINITY;

            // Gravity Mode
            this._emitterMode = cc.PARTICLE_MODE_GRAVITY;

            // Gravity Mode: gravity
            this.modeA.gravity = cc.p(0, 0);

            // Gravity Mode: speed of particles
            this.modeA.speed = 60;
            this.modeA.speedVar = 10;

            // Gravity Mode: radial
            this.modeA.radialAccel = -80;
            this.modeA.radialAccelVar = 0;

            // Gravity Mode: tagential
            this.modeA.tangentialAccel = 80;
            this.modeA.tangentialAccelVar = 0;

            // angle
            this._angle = 90;
            this._angleVar = 360;

            // emitter position
            var winSize = cc.Director.getInstance().getWinSize();
            this.setPosition(cc.p(winSize.width / 2, winSize.height / 2));
            this._posVar = cc.PointZero();

            // life of particles
            this._life = 4;
            this._lifeVar = 1;

            // size, in pixels
            this._startSize = 37.0;
            this._startSizeVar = 10.0;
            this._endSize = cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE;

            // emits per second
            this._emissionRate = this._totalParticles / this._life;

            // color of particles
            this._startColor.r = 0.12;
            this._startColor.g = 0.25;
            this._startColor.b = 0.76;
            this._startColor.a = 1.0;
            this._startColorVar.r = 0.0;
            this._startColorVar.g = 0.0;
            this._startColorVar.b = 0.0;
            this._startColorVar.a = 0.0;
            this._endColor.r = 0.0;
            this._endColor.g = 0.0;
            this._endColor.b = 0.0;
            this._endColor.a = 1.0;
            this._endColorVar.r = 0.0;
            this._endColorVar.g = 0.0;
            this._endColorVar.b = 0.0;
            this._endColorVar.a = 0.0;

            // additive
            this.setBlendAdditive(true);
            return true;
        }
        return false;
    }
});
/**
 * Create a galaxy particle system
 * @return {cc.ParticleGalaxy}
 *
 * @example
 * var emitter = cc.ParticleGalaxy.create();
 */
cc.ParticleGalaxy.create = function () {
    var ret = new cc.ParticleGalaxy();
    if (ret.init()) {
        return ret;
    }
    return null;
};

/**
 * A flower particle system
 * @class
 * @extends cc.ParticleSystemQuad
 *
 * @example
 * var emitter = cc.ParticleFlower.create();
 */
cc.ParticleFlower = cc.ParticleSystemQuad.extend(/** @lends cc.ParticleFlower# */{
    /**
     * initialize a flower particle system
     * @return {Boolean}
     */
    init:function () {
        //return this.initWithTotalParticles(250);
        return this.initWithTotalParticles(100);
    },

    /**
     * initialize a flower particle system with number Of Particles
     * @param {Number} numberOfParticles
     * @return {Boolean}
     */
    initWithTotalParticles:function (numberOfParticles) {
        if (this._super(numberOfParticles)) {
            // duration
            this._duration = cc.PARTICLE_DURATION_INFINITY;

            // Gravity Mode
            this._emitterMode = cc.PARTICLE_MODE_GRAVITY;

            // Gravity Mode: gravity
            this.modeA.gravity = cc.p(0, 0);

            // Gravity Mode: speed of particles
            this.modeA.speed = 80;
            this.modeA.speedVar = 10;

            // Gravity Mode: radial
            this.modeA.radialAccel = -60;
            this.modeA.radialAccelVar = 0;

            // Gravity Mode: tagential
            this.modeA.tangentialAccel = 15;
            this.modeA.tangentialAccelVar = 0;

            // angle
            this._angle = 90;
            this._angleVar = 360;

            // emitter position
            var winSize = cc.Director.getInstance().getWinSize();
            this.setPosition(cc.p(winSize.width / 2, winSize.height / 2));
            this._posVar = cc.PointZero();

            // life of particles
            this._life = 4;
            this._lifeVar = 1;

            // size, in pixels
            this._startSize = 30.0;
            this._startSizeVar = 10.0;
            this._endSize = cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE;

            // emits per second
            this._emissionRate = this._totalParticles / this._life;

            // color of particles
            this._startColor.r = 0.50;
            this._startColor.g = 0.50;
            this._startColor.b = 0.50;
            this._startColor.a = 1.0;
            this._startColorVar.r = 0.5;
            this._startColorVar.g = 0.5;
            this._startColorVar.b = 0.5;
            this._startColorVar.a = 0.5;
            this._endColor.r = 0.0;
            this._endColor.g = 0.0;
            this._endColor.b = 0.0;
            this._endColor.a = 1.0;
            this._endColorVar.r = 0.0;
            this._endColorVar.g = 0.0;
            this._endColorVar.b = 0.0;
            this._endColorVar.a = 0.0;

            // additive
            this.setBlendAdditive(true);
            return true;
        }
        return false;
    }
});

/**
 * Create a flower particle system
 * @return {cc.ParticleFlower}
 *
 * @example
 * var emitter = cc.ParticleFlower.create();
 */
cc.ParticleFlower.create = function () {
    var ret = new cc.ParticleFlower();
    if (ret.init()) {
        return ret;
    }
    return null;
};

//! @brief A meteor particle system
/**
 * A meteor particle system
 * @class
 * @extends cc.ParticleSystemQuad
 *
 * @example
 * var emitter = cc.ParticleMeteor.create();
 */
cc.ParticleMeteor = cc.ParticleSystemQuad.extend(/** @lends cc.ParticleMeteor# */{
    /**
     * initialize a meteor particle system
     * @return {Boolean}
     */
    init:function () {
        //return this.initWithTotalParticles(150);
        return this.initWithTotalParticles(100);
    },

    /**
     * initialize a meteor particle system with number Of Particles
     * @param {Number} numberOfParticles
     * @return {Boolean}
     */
    initWithTotalParticles:function (numberOfParticles) {
        if (this._super(numberOfParticles)) {
            // duration
            this._duration = cc.PARTICLE_DURATION_INFINITY;

            // Gravity Mode
            this._emitterMode = cc.PARTICLE_MODE_GRAVITY;

            // Gravity Mode: gravity
            this.modeA.gravity = cc.p(-200, 200);

            // Gravity Mode: speed of particles
            this.modeA.speed = 15;
            this.modeA.speedVar = 5;

            // Gravity Mode: radial
            this.modeA.radialAccel = 0;
            this.modeA.radialAccelVar = 0;

            // Gravity Mode: tagential
            this.modeA.tangentialAccel = 0;
            this.modeA.tangentialAccelVar = 0;

            // angle
            this._angle = 90;
            this._angleVar = 360;

            // emitter position
            var winSize = cc.Director.getInstance().getWinSize();
            this.setPosition(cc.p(winSize.width / 2, winSize.height / 2));
            this._posVar = cc.PointZero();

            // life of particles
            this._life = 2;
            this._lifeVar = 1;

            // size, in pixels
            this._startSize = 60.0;
            this._startSizeVar = 10.0;
            this._endSize = cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE;

            // emits per second
            this._emissionRate = this._totalParticles / this._life;

            // color of particles
            this._startColor.r = 0.2;
            this._startColor.g = 0.4;
            this._startColor.b = 0.7;
            this._startColor.a = 1.0;
            this._startColorVar.r = 0.0;
            this._startColorVar.g = 0.0;
            this._startColorVar.b = 0.2;
            this._startColorVar.a = 0.1;
            this._endColor.r = 0.0;
            this._endColor.g = 0.0;
            this._endColor.b = 0.0;
            this._endColor.a = 1.0;
            this._endColorVar.r = 0.0;
            this._endColorVar.g = 0.0;
            this._endColorVar.b = 0.0;
            this._endColorVar.a = 0.0;

            // additive
            this.setBlendAdditive(true);
            return true;
        }
        return false;
    }
});

/**
 * Create a meteor particle system
 * @return {cc.ParticleFireworks}
 *
 * @example
 * var emitter = cc.ParticleMeteor.create();
 */
cc.ParticleMeteor.create = function () {
    var ret = new cc.ParticleMeteor();
    if (ret.init()) {
        return ret;
    }
    return null;
};

/**
 * A spiral particle system
 * @class
 * @extends cc.ParticleSystemQuad
 *
 * @example
 * var emitter = cc.ParticleSpiral.create();
 */
cc.ParticleSpiral = cc.ParticleSystemQuad.extend(/** @lends cc.ParticleSpiral# */{
    /**
     * initialize a spiral particle system
     * @return {Boolean}
     */
    init:function () {
        //return this.initWithTotalParticles(500);
        return this.initWithTotalParticles(100);
    },

    /**
     * initialize a spiral particle system with number Of Particles
     * @param {Number} numberOfParticles
     * @return {Boolean}
     */
    initWithTotalParticles:function (numberOfParticles) {
        if (this._super(numberOfParticles)) {
            // duration
            this._duration = cc.PARTICLE_DURATION_INFINITY;

            // Gravity Mode
            this._emitterMode = cc.PARTICLE_MODE_GRAVITY;

            // Gravity Mode: gravity
            this.modeA.gravity = cc.p(0, 0);

            // Gravity Mode: speed of particles
            this.modeA.speed = 150;
            this.modeA.speedVar = 0;

            // Gravity Mode: radial
            this.modeA.radialAccel = -380;
            this.modeA.radialAccelVar = 0;

            // Gravity Mode: tagential
            this.modeA.tangentialAccel = 45;
            this.modeA.tangentialAccelVar = 0;

            // angle
            this._angle = 90;
            this._angleVar = 0;

            // emitter position
            var winSize = cc.Director.getInstance().getWinSize();
            this.setPosition(cc.p(winSize.width / 2, winSize.height / 2));
            this._posVar = cc.PointZero();

            // life of particles
            this._life = 12;
            this._lifeVar = 0;

            // size, in pixels
            this._startSize = 20.0;
            this._startSizeVar = 0.0;
            this._endSize = cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE;

            // emits per second
            this._emissionRate = this._totalParticles / this._life;

            // color of particles
            this._startColor.r = 0.5;
            this._startColor.g = 0.5;
            this._startColor.b = 0.5;
            this._startColor.a = 1.0;
            this._startColorVar.r = 0.5;
            this._startColorVar.g = 0.5;
            this._startColorVar.b = 0.5;
            this._startColorVar.a = 0.0;
            this._endColor.r = 0.5;
            this._endColor.g = 0.5;
            this._endColor.b = 0.5;
            this._endColor.a = 1.0;
            this._endColorVar.r = 0.5;
            this._endColorVar.g = 0.5;
            this._endColorVar.b = 0.5;
            this._endColorVar.a = 0.0;

            // additive
            this.setBlendAdditive(false);
            return true;
        }
        return false;
    }
});

/**
 * Create a spiral particle system
 * @return {cc.ParticleSpiral}
 *
 * @example
 * var emitter = cc.ParticleSpiral.create();
 */
cc.ParticleSpiral.create = function () {
    var ret = new cc.ParticleSpiral();
    if (ret.init()) {
        return ret;
    }
    return null;
};

/**
 * An explosion particle system
 * @class
 * @extends cc.ParticleSystemQuad
 *
 * @example
 * var emitter = cc.ParticleExplosion.create();
 */
cc.ParticleExplosion = cc.ParticleSystemQuad.extend(/** @lends cc.ParticleExplosion# */{
    /**
     * initialize an explosion particle system
     * @return {Boolean}
     */
    init:function () {
        //return this.initWithTotalParticles(700);
        return this.initWithTotalParticles(300);
    },

    /**
     * initialize an explosion particle system with number Of Particles
     * @param {Number} numberOfParticles
     * @return {Boolean}
     */
    initWithTotalParticles:function (numberOfParticles) {
        if (this._super(numberOfParticles)) {
            // duration
            this._duration = 0.1;

            this._emitterMode = cc.PARTICLE_MODE_GRAVITY;

            // Gravity Mode: gravity
            this.modeA.gravity = cc.p(0, 0);

            // Gravity Mode: speed of particles
            this.modeA.speed = 70;
            this.modeA.speedVar = 40;

            // Gravity Mode: radial
            this.modeA.radialAccel = 0;
            this.modeA.radialAccelVar = 0;

            // Gravity Mode: tagential
            this.modeA.tangentialAccel = 0;
            this.modeA.tangentialAccelVar = 0;

            // angle
            this._angle = 90;
            this._angleVar = 360;

            // emitter position
            var winSize = cc.Director.getInstance().getWinSize();
            this.setPosition(cc.p(winSize.width / 2, winSize.height / 2));
            this._posVar = cc.PointZero();

            // life of particles
            this._life = 5.0;
            this._lifeVar = 2;

            // size, in pixels
            this._startSize = 15.0;
            this._startSizeVar = 10.0;
            this._endSize = cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE;

            // emits per second
            this._emissionRate = this._totalParticles / this._duration;

            // color of particles
            this._startColor.r = 0.7;
            this._startColor.g = 0.1;
            this._startColor.b = 0.2;
            this._startColor.a = 1.0;
            this._startColorVar.r = 0.5;
            this._startColorVar.g = 0.5;
            this._startColorVar.b = 0.5;
            this._startColorVar.a = 0.0;
            this._endColor.r = 0.5;
            this._endColor.g = 0.5;
            this._endColor.b = 0.5;
            this._endColor.a = 0.0;
            this._endColorVar.r = 0.5;
            this._endColorVar.g = 0.5;
            this._endColorVar.b = 0.5;
            this._endColorVar.a = 0.0;

            // additive
            this.setBlendAdditive(false);
            return true;
        }
        return false;
    }
});

/**
 * Create an explosion particle system
 * @return {cc.ParticleExplosion}
 *
 * @example
 * var emitter = cc.ParticleExplosion.create();
 */
cc.ParticleExplosion.create = function () {
    var ret = new cc.ParticleExplosion();
    if (ret.init()) {
        return ret;
    }
    return null;
};

/**
 * A smoke particle system
 * @class
 * @extends cc.ParticleSystemQuad
 *
 * @example
 * var emitter = cc.ParticleSmoke.create();
 */
cc.ParticleSmoke = cc.ParticleSystemQuad.extend(/** @lends cc.ParticleSmoke# */{
    /**
     * initialize a smoke particle system
     * @return {Boolean}
     */
    init:function () {
        //return this.initWithTotalParticles(200);
        return this.initWithTotalParticles(100);
    },

    /**
     * initialize a smoke particle system with number Of Particles
     * @param {Number} numberOfParticles
     * @return {Boolean}
     */
    initWithTotalParticles:function (numberOfParticles) {
        if (this._super(numberOfParticles)) {
            // duration
            this._duration = cc.PARTICLE_DURATION_INFINITY;

            // Emitter mode: Gravity Mode
            this._emitterMode = cc.PARTICLE_MODE_GRAVITY;

            // Gravity Mode: gravity
            this.modeA.gravity = cc.p(0, 0);

            // Gravity Mode: radial acceleration
            this.modeA.radialAccel = 0;
            this.modeA.radialAccelVar = 0;

            // Gravity Mode: speed of particles
            this.modeA.speed = 25;
            this.modeA.speedVar = 10;

            // angle
            this._angle = 90;
            this._angleVar = 5;

            // emitter position
            var winSize = cc.Director.getInstance().getWinSize();
            this.setPosition(cc.p(winSize.width / 2, 0));
            this._posVar = cc.p(20, 0);

            // life of particles
            this._life = 4;
            this._lifeVar = 1;

            // size, in pixels
            this._startSize = 60.0;
            this._startSizeVar = 10.0;
            this._endSize = cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE;

            // emits per frame
            this._emissionRate = this._totalParticles / this._life;

            // color of particles
            this._startColor.r = 0.8;
            this._startColor.g = 0.8;
            this._startColor.b = 0.8;
            this._startColor.a = 1.0;
            this._startColorVar.r = 0.02;
            this._startColorVar.g = 0.02;
            this._startColorVar.b = 0.02;
            this._startColorVar.a = 0.0;
            this._endColor.r = 0.0;
            this._endColor.g = 0.0;
            this._endColor.b = 0.0;
            this._endColor.a = 1.0;
            this._endColorVar.r = 0.0;
            this._endColorVar.g = 0.0;
            this._endColorVar.b = 0.0;
            this._endColorVar.a = 0.0;

            // additive
            this.setBlendAdditive(false);
            return true;
        }
        return false;
    }
});

/**
 * Create a smoke particle system
 * @return {cc.ParticleFireworks}
 *
 * @example
 * var emitter = cc.ParticleFireworks.create();
 */
cc.ParticleSmoke.create = function () {
    var ret = new cc.ParticleSmoke();
    if (ret.init()) {
        return ret;
    }
    return null;
};

/**
 * A snow particle system
 * @class
 * @extends cc.ParticleSystemQuad
 *
 * @example
 * var emitter = cc.ParticleSnow.create();
 */
cc.ParticleSnow = cc.ParticleSystemQuad.extend(/** @lends cc.ParticleSnow# */{
    /**
     * initialize a snow particle system
     * @return {Boolean}
     */
    init:function () {
        return this.initWithTotalParticles(250);
        //return this.initWithTotalParticles(700);
    },

    /**
     * initialize a snow particle system with number Of Particles
     * @param {Number} numberOfParticles
     * @return {Boolean}
     */
    initWithTotalParticles:function (numberOfParticles) {
        if (this._super(numberOfParticles)) {
            // duration
            this._duration = cc.PARTICLE_DURATION_INFINITY;

            // set gravity mode.
            this._emitterMode = cc.PARTICLE_MODE_GRAVITY;

            // Gravity Mode: gravity
            this.modeA.gravity = cc.p(0, -1);

            // Gravity Mode: speed of particles
            this.modeA.speed = 5;
            this.modeA.speedVar = 1;

            // Gravity Mode: radial
            this.modeA.radialAccel = 0;
            this.modeA.radialAccelVar = 1;

            // Gravity mode: tagential
            this.modeA.tangentialAccel = 0;
            this.modeA.tangentialAccelVar = 1;

            // emitter position
            var winSize = cc.Director.getInstance().getWinSize();
            this.setPosition(cc.p(winSize.width / 2, winSize.height + 10));
            this._posVar = cc.p(winSize.width / 2, 0);

            // angle
            this._angle = -90;
            this._angleVar = 5;

            // life of particles
            this._life = 45;
            this._lifeVar = 15;

            // size, in pixels
            this._startSize = 10.0;
            this._startSizeVar = 5.0;
            this._endSize = cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE;

            // emits per second
            this._emissionRate = 10;

            // color of particles
            this._startColor.r = 1.0;
            this._startColor.g = 1.0;
            this._startColor.b = 1.0;
            this._startColor.a = 1.0;
            this._startColorVar.r = 0.0;
            this._startColorVar.g = 0.0;
            this._startColorVar.b = 0.0;
            this._startColorVar.a = 0.0;
            this._endColor.r = 1.0;
            this._endColor.g = 1.0;
            this._endColor.b = 1.0;
            this._endColor.a = 0.0;
            this._endColorVar.r = 0.0;
            this._endColorVar.g = 0.0;
            this._endColorVar.b = 0.0;
            this._endColorVar.a = 0.0;

            // additive
            this.setBlendAdditive(false);
            return true;
        }
        return false;
    }
});

/**
 * Create a snow particle system
 * @return {cc.ParticleSnow}
 *
 * @example
 * var emitter = cc.ParticleSnow.create();
 */
cc.ParticleSnow.create = function () {
    var ret = new cc.ParticleSnow();
    if (ret.init()) {
        return ret;
    }
    return null;
};

//! @brief A rain particle system
/**
 * A rain particle system
 * @class
 * @extends cc.ParticleSystemQuad
 *
 * @example
 * var emitter = cc.ParticleRain.create();
 */
cc.ParticleRain = cc.ParticleSystemQuad.extend(/** @lends cc.ParticleRain# */{
    /**
     * initialize a rain particle system
     * @return {Boolean}
     */
    init:function () {
        return this.initWithTotalParticles(300);
        //return this.initWithTotalParticles(1000);
    },

    /**
     * initialize a rain particle system with number Of Particles
     * @param {Number} numberOfParticles
     * @return {Boolean}
     */
    initWithTotalParticles:function (numberOfParticles) {
        if (this._super(numberOfParticles)) {
            // duration
            this._duration = cc.PARTICLE_DURATION_INFINITY;

            this._emitterMode = cc.PARTICLE_MODE_GRAVITY;

            // Gravity Mode: gravity
            this.modeA.gravity = cc.p(10, -10);

            // Gravity Mode: radial
            this.modeA.radialAccel = 0;
            this.modeA.radialAccelVar = 1;

            // Gravity Mode: tagential
            this.modeA.tangentialAccel = 0;
            this.modeA.tangentialAccelVar = 1;

            // Gravity Mode: speed of particles
            this.modeA.speed = 130;
            this.modeA.speedVar = 30;

            // angle
            this._angle = -90;
            this._angleVar = 5;


            // emitter position
            var winSize = cc.Director.getInstance().getWinSize();
            this.setPosition(cc.p(winSize.width / 2, winSize.height));
            this._posVar = cc.p(winSize.width / 2, 0);

            // life of particles
            this._life = 4.5;
            this._lifeVar = 0;

            // size, in pixels
            this._startSize = 4.0;
            this._startSizeVar = 2.0;
            this._endSize = cc.PARTICLE_START_SIZE_EQUAL_TO_END_SIZE;

            // emits per second
            this._emissionRate = 20;

            // color of particles
            this._startColor.r = 0.7;
            this._startColor.g = 0.8;
            this._startColor.b = 1.0;
            this._startColor.a = 1.0;
            this._startColorVar.r = 0.0;
            this._startColorVar.g = 0.0;
            this._startColorVar.b = 0.0;
            this._startColorVar.a = 0.0;
            this._endColor.r = 0.7;
            this._endColor.g = 0.8;
            this._endColor.b = 1.0;
            this._endColor.a = 0.5;
            this._endColorVar.r = 0.0;
            this._endColorVar.g = 0.0;
            this._endColorVar.b = 0.0;
            this._endColorVar.a = 0.0;

            // additive
            this.setBlendAdditive(false);
            return true;
        }
        return false;
    }
});

/**
 * Create a rain particle system
 * @return {cc.ParticleRain}
 *
 * @example
 * var emitter = cc.ParticleRain.create();
 */
cc.ParticleRain.create = function () {
    var ret = new cc.ParticleRain();
    if (ret.init()) {
        return ret;
    }
    return null;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * @class
 * @extends cc.Class
 */
cc.Touch = cc.Class.extend(/** @lends cc.Touch# */{
    _point:null,
    _prevPoint:cc.PointZero(),
    _id:0,

    /**
     * Constructor
     */
    ctor:function (x, y, id) {
        this._point = cc.p(x || 0, y || 0);
        this._id = id || 0;
    },

    /**
     * get point of touch
     * @return {cc.Point}
     */
    getLocation:function () {
        return this._point;
    },

    /**
     * @return {cc.Point}
     */
    getPreviousLocation:function () {
        return this._prevPoint;
    },

    /**
     * @return {cc.Point}
     */
    getDelta:function () {
        return cc.pSub(this._point, this._prevPoint);
    },

    /**
     * @return {Number}
     */
    getID:function () {
        return this._id;
    },

    /**
     * set information to touch
     * @param {Number} id
     * @param  {Number} x
     * @param  {Number} y
     */
    setTouchInfo:function (id, x, y) {
        this._prevPoint = this._point;
        this._point = cc.p(x || 0, y || 0);
        this._id = id;
    },

    _setPrevPoint:function (x, y) {
        this._prevPoint = cc.p(x || 0, y || 0);
    }
});

/**
 * @class
 * @extends cc.Class
 */
cc.TouchDelegate = cc.Class.extend(/** @lends cc.TouchDelegate# */{
    _eventTypeFuncMap:null,

    /**
     * Virtual function
     * @param {cc.Touch} touch
     * @param {event} event
     * @return {Boolean}
     */
    onTouchBegan:function (touch, event) {
        return false;
    },

    /**
     * Virtual function
     * @param {cc.Touch} touch
     * @param {event} event
     */
    onTouchMoved:function (touch, event) {
    },

    /**
     * Virtual function
     * @param {cc.Touch} touch
     * @param {event} event
     */
    onTouchEnded:function (touch, event) {
    },

    /**
     * Virtual function
     * @param {cc.Touch} touch
     * @param {event} event
     */
    onTouchCancelled:function (touch, event) {
    },

    /**
     * Virtual function
     * @param {cc.Touch} touch
     * @param {event} event
     */
    onTouchesBegan:function (touches, event) {
    },

    /**
     * Virtual function
     * @param {cc.Touch} touch
     * @param {event} event
     */
    onTouchesMoved:function (touches, event) {
    },

    /**
     * Virtual function
     * @param {cc.Touch} touch
     * @param {event} event
     */
    onTouchesEnded:function (touches, event) {
    },

    /**
     * Virtual function
     * @param {cc.Touch} touch
     * @param {event} event
     */
    onTouchesCancelled:function (touches, event) {
    },

    /*
     * In TouchesTest, class Padle inherits from cc.Sprite and cc.TargetedTouchDelegate.
     * When it invoke  cc.Director.getInstance().getTouchDispatcher().addTargetedDelegate(this, 0, true),
     * it will crash in cc.TouchHandler.initWithDelegate() because of dynamic_cast() on android.
     * I don't know why, so add these functions for the subclass to invoke it's own retain() and  release
     *Virtual function
     */
    touchDelegateRetain:function () {
    },

    /**
     * Virtual function
     */
    touchDelegateRelease:function () {
    }
});

/**
 * Using this type of delegate results in two benefits:
 * - 1. You don't need to deal with cc.Sets, the dispatcher does the job of splitting
 * them. You get exactly one UITouch per call.
 * - 2. You can *claim* a UITouch by returning YES in onTouchBegan. Updates of claimed
 * touches are sent only to the delegate(s) that claimed them. So if you get a move/
 * ended/cancelled update you're sure it's your touch. This frees you from doing a
 * lot of checks when doing multi-touch.
 *
 * (The name TargetedTouchDelegate relates to updates "targeting" their specific
 * handler, without bothering the other handlers.)
 * @class
 * @extends cc.Class
 */
cc.TargetedTouchDelegate = cc.TouchDelegate.extend(/** @lends cc.TargetedTouchDelegate# */{

    /**
     * Return YES to claim the touch.
     * @param {cc.Touch} touch
     * @param {event} event
     * @return {Boolean}
     */
    onTouchBegan:function (touch, event) {
        return false;
    },

    /**
     * Virtual function
     * @param {cc.Touch} touch
     * @param {event} event
     */
    onTouchMoved:function (touch, event) {
    },

    /**
     * Virtual function
     * @param {cc.Touch} touch
     * @param {event} event
     */
    onTouchEnded:function (touch, event) {
    },

    /**
     * Virtual function
     * @param {cc.Touch} touch
     * @param {event} event
     */
    onTouchCancelled:function (touch, event) {
    }
});

/**
 * This type of delegate is the same one used by CocoaTouch. You will receive all the events (Began,Moved,Ended,Cancelled).
 * @class
 * @extends cc.Class
 */
cc.StandardTouchDelegate = cc.TouchDelegate.extend(/** @lends cc.StandardTouchDelegate# */{

    /**
     * Virtual function
     * @param {Array} touches
     * @param {event} event
     */
    onTouchesBegan:function (touches, event) {
    },

    /**
     * Virtual function
     * @param {Array} touches
     * @param {event} event
     */
    onTouchesMoved:function (touches, event) {
    },

    /**
     * Virtual function
     * @param {Array} touches
     * @param {event} event
     */
    onTouchesEnded:function (touches, event) {
    },

    /**
     * Virtual function
     * @param {Array} touches
     * @param {event} event
     */
    onTouchesCancelled:function (touches, event) {
    }
});

/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * cc.TouchHandler
 * Object than contains the delegate and priority of the event handler.
 * @class
 * @extends cc.Class
 */
cc.TouchHandler = cc.Class.extend(/** @lends cc.TouchHandler# */{
    _delegate:null,
    _priority:0,
    _enabledSelectors:0,

    /**
     * @return {cc.TouchDelegate}
     */
    getDelegate:function () {
        return this._delegate;
    },

    /**
     * @param {cc.TouchDelegate} delegate
     */
    setDelegate:function (delegate) {
        this._delegate = delegate;
    },

    /**
     * @return {Number}
     */
    getPriority:function () {
        return this._priority;
    },

    /**
     * @param {Number} priority
     */
    setPriority:function (priority) {
        this._priority = priority;
    },

    /**
     *  Enabled selectors
     * @return {Number}
     */
    getEnabledSelectors:function () {
        return this._enabledSelectors;
    },

    /**
     * @param {Number} value
     */
    setEnalbedSelectors:function (value) {
        this._enabledSelectors = value;
    },

    /**
     * initializes a TouchHandler with a delegate and a priority
     * @param {cc.TouchDelegate} delegate
     * @param {Number} priority
     * @return {Boolean}
     */
    initWithDelegate:function (delegate, priority) {
        cc.Assert(delegate != null, "TouchHandler.initWithDelegate():touch delegate should not be null");
        this._delegate = delegate;
        this._priority = priority;
        this._enabledSelectors = 0;
        return true;
    }
});

/**
 *  Allocates a TouchHandler with a delegate and a priority
 * @param {cc.TouchDelegate} delegate
 * @param {Number} priority
 * @return {cc.TouchHandler}
 */
cc.TouchHandler.handlerWithDelegate = function (delegate, priority) {
    var handler = new cc.TouchHandler();
    if (handler) {
        handler.initWithDelegate(delegate, priority);
    }
    return handler;
};

/**
 * cc.StandardTouchHandler
 * It forwardes each event to the delegate.
 * @class
 * @extends cc.TouchHandler
 */
cc.StandardTouchHandler = cc.TouchHandler.extend(/** @lends cc.StandardTouchHandler# */{
    /**
     * Initializes a TouchHandler with a delegate and a priority
     * @param {cc.TouchDelegate} delegate
     * @param {Number} priority
     * @return {Boolean}
     */
    initWithDelegate:function (delegate, priority) {
        if (this._super(delegate, priority)) {
            return true;
        }
        return false;
    }
});

/**
 * Allocates a TouchHandler with a delegate and a priority
 * @param {cc.TouchDelegate} delegate
 * @param {Number} priority
 * @return {cc.StandardTouchHandler}
 */
cc.StandardTouchHandler.handlerWithDelegate = function (delegate, priority) {
    var handler = new cc.StandardTouchHandler();
    if (handler) {
        handler.initWithDelegate(delegate, priority);
    }
    return handler;
};

/**
 * @class
 * @extends cc.TouchHandler
 */
cc.TargetedTouchHandler = cc.TouchHandler.extend(/** @lends cc.TargetedTouchHandler# */{
    _swallowsTouches:false,
    _claimedTouches:null,

    /**
     * Whether or not the touches are swallowed
     * @return {Boolean}
     */
    isSwallowsTouches:function () {
        return this._swallowsTouches;
    },

    /**
     * @param {Boolean} swallowsTouches
     */
    setSwallowsTouches:function (swallowsTouches) {
        this._swallowsTouches = swallowsTouches;
    },

    /**
     * MutableSet that contains the claimed touches
     * @return {Array}
     */
    getClaimedTouches:function () {
        return this._claimedTouches;
    },

    /**
     * Initializes a TargetedTouchHandler with a delegate, a priority and whether or not it swallows touches or not
     * @param {cc.TouchDelegate} delegate
     * @param {Number} priority
     * @param {Boolean} swallow
     * @return {Boolean}
     */
    initWithDelegate:function (delegate, priority, swallow) {
        if (this._super(delegate, priority)) {
            this._claimedTouches = [];
            this._swallowsTouches = swallow;
            return true;
        }
        return false;
    }
});

/**
 * Allocates a TargetedTouchHandler with a delegate, a priority and whether or not it swallows touches or not
 * @param {cc.TouchDelegate} delegate
 * @param {Number} priority
 * @param {Boolean} swallow
 * @return {cc.TargetedTouchHandler}
 */
cc.TargetedTouchHandler.handlerWithDelegate = function (delegate, priority, swallow) {
    var handler = new cc.TargetedTouchHandler();
    if (handler) {
        handler.initWithDelegate(delegate, priority, swallow);
    }
    return handler;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * @constant
 * @type Number
 */
cc.TouchSelectorBeganBit = 1 << 0;

/**
 * @constant
 * @type Number
 */
cc.TouchSelectorMovedBit = 1 << 1;

/**
 * @constant
 * @type Number
 */
cc.TouchSelectorEndedBit = 1 << 2;

/**
 * @constant
 * @type Number
 */
cc.TouchSelectorCancelledBit = 1 << 3;

/**
 * @constant
 * @type Number
 */
cc.TouchSelectorAllBits = ( cc.TouchSelectorBeganBit | cc.TouchSelectorMovedBit | cc.TouchSelectorEndedBit | cc.TouchSelectorCancelledBit);

/**
 * @constant
 * @type Number
 */
cc.TOUCH_BEGAN = 0;

/**
 * @constant
 * @type Number
 */
cc.TOUCH_MOVED = 1;

/**
 * @constant
 * @type Number
 */
cc.TOUCH_ENDED = 2;

/**
 * @constant
 * @type Number
 */
cc.TOUCH_CANCELLED = 3;

/**
 * @constant
 * @type Number
 */
cc.TouchMax = 4;

/**
 * @function
 * @param {cc.TouchHandler} p1
 * @param {cc.TouchHandler} p2
 * @return {Boolean}
 */
cc.less = function (p1, p2) {
    return p1.getPriority() > p2.getPriority();
};

/**
 * @param {Number} type
 * Constructor
 */
cc.TouchHandlerHelperData = function (type) {
    // we only use the type
    this.type = type;
};

/**
 * cc.TouchDispatcher.
 * Singleton that handles all the touch events.
 * The dispatcher dispatches events to the registered TouchHandlers.
 * There are 2 different type of touch handlers:
 * - Standard Touch Handlers
 * - Targeted Touch Handlers
 *
 * The Standard Touch Handlers work like the CocoaTouch touch handler: a set of touches is passed to the delegate.
 * On the other hand, the Targeted Touch Handlers only receive 1 touch at the time, and they can "swallow" touches (avoid the propagation of the event).
 *
 * Firstly, the dispatcher sends the received touches to the targeted touches.
 * These touches can be swallowed by the Targeted Touch Handlers. If there are still remaining touches, then the remaining touches will be sent
 * to the Standard Touch Handlers.
 * @class
 * @extends cc.Class
 */
cc.TouchDispatcher = cc.Class.extend(/** @lends cc.TouchDispatcher# */{
    _targetedHandlers:null,
    _standardHandlers:null,
    _locked:false,
    _toAdd:false,
    _toRemove:false,
    _handlersToAdd:null,
    _handlersToRemove:null,
    _toQuit:false,
    _dispatchEvents:false,
    _handlerHelperData:[new cc.TouchHandlerHelperData(cc.TOUCH_BEGAN), new cc.TouchHandlerHelperData(cc.TOUCH_MOVED),
        new cc.TouchHandlerHelperData(cc.TOUCH_ENDED), new cc.TouchHandlerHelperData(cc.TOUCH_CANCELLED)],

    /**
     * @return {Boolean}
     */
    init:function () {
        this._dispatchEvents = true;
        this._targetedHandlers = [];
        this._standardHandlers = [];
        this._handlersToAdd = [];
        this._handlersToRemove = [];
        this._toRemove = false;
        this._toAdd = false;
        this._toQuit = false;
        this._locked = false;
        cc.TouchDispatcher.registerHtmlElementEvent(cc.canvas);
        return true;
    },

    /**
     * Whether or not the events are going to be dispatched. Default: true
     * @return {Boolean}
     */
    isDispatchEvents:function () {
        return this._dispatchEvents;
    },

    /**
     * @param {Boolean} dispatchEvents
     */
    setDispatchEvents:function (dispatchEvents) {
        this._dispatchEvents = dispatchEvents;
    },

    /**
     * Adds a standard touch delegate to the dispatcher's list.
     * See StandardTouchDelegate description.
     * IMPORTANT: The delegate will be retained.
     * @param {cc.TouchDelegate} delegate
     * @param {Number} priority
     */
    addStandardDelegate:function (delegate, priority) {
        var handler = cc.StandardTouchHandler.handlerWithDelegate(delegate, priority);

        if (!this._locked) {
            this._standardHandlers = this.forceAddHandler(handler, this._standardHandlers);
        } else {
            /* If handler is contained in m_pHandlersToRemove, if so remove it from m_pHandlersToRemove and retrun.
             * Refer issue #752(cocos2d-x)
             */
            if (this._handlersToRemove.indexOf(delegate) != -1) {
                cc.ArrayRemoveObject(this._handlersToRemove, delegate);
                return;
            }

            this._handlersToAdd.push(handler);
            this._toAdd = true;
        }
    },

    /**
     * @param {cc.TouchDelegate} delegate
     * @param {Number} priority
     * @param {Boolean} swallowsTouches
     */
    addTargetedDelegate:function (delegate, priority, swallowsTouches) {
        var handler = cc.TargetedTouchHandler.handlerWithDelegate(delegate, priority, swallowsTouches);
        if (!this._locked) {
            this._targetedHandlers = this.forceAddHandler(handler, this._targetedHandlers);
        } else {
            /* If handler is contained in m_pHandlersToRemove, if so remove it from m_pHandlersToRemove and retrun.
             * Refer issue #752(cocos2d-x)
             */
            if (this._handlersToRemove.indexOf(delegate) != -1) {
                cc.ArrayRemoveObject(this._handlersToRemove, delegate);
                return;
            }

            this._handlersToAdd.push(handler);
            this._toAdd = true;
        }
    },

    /**
     *  Force add handler
     * @param {cc.TouchHandler} handler
     * @param {Array} array
     * @return {Array}
     */
    forceAddHandler:function (handler, array) {
        var u = 0;

        for (var i = 0; i < array.length; i++) {
            var h = array[i];
            if (h) {
                if (h.getPriority() < handler.getPriority()) {
                    ++u;
                }
                if (h.getDelegate() == handler.getDelegate()) {
                    cc.Assert(0, "TouchDispatcher.forceAddHandler()");
                    return array;
                }
            }
        }
        return cc.ArrayAppendObjectToIndex(array, handler, u);
    },

    /**
     *  Force remove all delegates
     */
    forceRemoveAllDelegates:function () {
        this._standardHandlers.length = 0;
        this._targetedHandlers.length = 0;
    },

    /**
     * Removes a touch delegate.
     * The delegate will be released
     * @param {cc.TouchDelegate} delegate
     */
    removeDelegate:function (delegate) {
        if (delegate == null) {
            return;
        }

        if (!this._locked) {
            this.forceRemoveDelegate(delegate);
        } else {
            /*
             * If handler is contained in m_pHandlersToAdd, if so remove it from m_pHandlersToAdd and return.
             */
            var handler = this.findHandler(this._handlersToAdd, delegate);
            if (handler) {
                cc.ArrayRemoveObject(this._handlersToAdd, handler);
                return;
            }

            this._handlersToRemove.push(delegate);
            this._toRemove = true;
        }
    },

    /**
     * Removes all touch delegates, releasing all the delegates
     */
    removeAllDelegates:function () {
        if (!this._locked) {
            this.forceRemoveAllDelegates();
        } else {
            this._toQuit = true;
        }
    },

    /**
     * Changes the priority of a previously added delegate. The lower the number,  the higher the priority
     * @param {Number} priority
     * @param {cc.TouchDelegate} delegate
     */
    setPriority:function (priority, delegate) {
        cc.Assert(delegate != null, "TouchDispatcher.setPriority():Arguments is null");

        var handler = this.findHandler(delegate);

        cc.Assert(handler != null, "TouchDispatcher.setPriority():Cant find TouchHandler");

        if (handler.getPriority() != priority) {
            handler.setPriority(priority);

            this.rearrangeHandlers(this._targetedHandlers);
            this.rearrangeHandlers(this._standardHandlers);
        }
    },

    /**
     * @param {Array} touches
     * @param {event} event
     * @param {Number} index
     */
    touches:function (touches, event, index) {
        cc.Assert(index >= 0 && index < 4, "TouchDispatcher.touches()");

        this._locked = true;

        // optimization to prevent a mutable copy when it is not necessary
        var targetedHandlersCount = this._targetedHandlers.length;
        var standardHandlersCount = this._standardHandlers.length;
        var needsMutableSet = (targetedHandlersCount && standardHandlersCount);

        var mutableTouches = (needsMutableSet ? touches.slice() : touches);
        var helper = this._handlerHelperData[index];
        //
        // process the target handlers 1st
        //
        if (targetedHandlersCount > 0) {
            var touch;
            for (var i = 0; i < touches.length; i++) {
                touch = touches[i];
                var handler;

                for (var j = 0; j < this._targetedHandlers.length; j++) {
                    handler = this._targetedHandlers[j];

                    if (!handler) {
                        break;
                    }

                    var claimed = false;
                    if (index == cc.TOUCH_BEGAN) {
                        claimed = handler.getDelegate().onTouchBegan(touch, event);

                        if (claimed) {
                            handler.getClaimedTouches().push(touch);
                        }
                        //} else if (handler.getClaimedTouches().indexOf(touch)> -1){
                    } else if (handler.getClaimedTouches().length > 0) {
                        // moved ended cancelled
                        claimed = true;
                        switch (helper.type) {
                            case cc.TOUCH_MOVED:
                                handler.getDelegate().onTouchMoved(touch, event);
                                break;
                            case cc.TOUCH_ENDED:
                                handler.getDelegate().onTouchEnded(touch, event);
                                handler.getClaimedTouches().length = 0;
                                //cc.ArrayRemoveObject(handler.getClaimedTouches(),touch);
                                break;
                            case cc.TOUCH_CANCELLED:
                                handler.getDelegate().onTouchCancelled(touch, event);
                                handler.getClaimedTouches().length = 0;
                                //cc.ArrayRemoveObject(handler.getClaimedTouches(),touch);
                                break;
                        }
                    }

                    if (claimed && handler.isSwallowsTouches()) {
                        if (needsMutableSet) {
                            cc.ArrayRemoveObject(mutableTouches, touch);
                        }
                        break;
                    }
                }
            }
        }

        //
        // process standard handlers 2nd
        //
        if (standardHandlersCount > 0) {
            for (i = 0; i < this._standardHandlers.length; i++) {
                handler = this._standardHandlers[i];

                if (!handler) {
                    break;
                }

                switch (helper.type) {
                    case cc.TOUCH_BEGAN:
                        if (mutableTouches.length > 0) {
                            handler.getDelegate().onTouchesBegan(mutableTouches, event);
                        }
                        break;
                    case cc.TOUCH_MOVED:
                        if (mutableTouches.length > 0) {
                            handler.getDelegate().onTouchesMoved(mutableTouches, event);
                        }
                        break;
                    case cc.TOUCH_ENDED:
                        handler.getDelegate().onTouchesEnded(mutableTouches, event);
                        break;
                    case cc.TOUCH_CANCELLED:
                        handler.getDelegate().onTouchesCancelled(mutableTouches, event);
                        break;
                }
            }
        }

        if (needsMutableSet) {
            mutableTouches = null;
        }

        //
        // Optimization. To prevent a [handlers copy] which is expensive
        // the add/removes/quit is done after the iterations
        //
        this._locked = false;
        if (this._toRemove) {
            this._toRemove = false;
            for (i = 0; i < this._handlersToRemove.length; i++) {
                this.forceRemoveDelegate(this._handlersToRemove[i]);
            }
            this._handlersToRemove.length = 0;
        }

        if (this._toAdd) {
            this._toAdd = false;

            for (i = 0; i < this._handlersToAdd.length; i++) {
                handler = this._handlersToAdd[i];
                if (!handler) {
                    break;
                }

                if (handler  instanceof cc.TargetedTouchHandler) {
                    this._targetedHandlers = this.forceAddHandler(handler, this._targetedHandlers);
                } else {
                    this._standardHandlers = this.forceAddHandler(handler, this._standardHandlers);
                }
            }
            this._handlersToAdd.length = 0;
        }

        if (this._toQuit) {
            this._toQuit = false;
            this.forceRemoveAllDelegates();
        }
    },

    /**
     * @param {Array} touches
     * @param {event} event
     */
    touchesBegan:function (touches, event) {
        if (this._dispatchEvents) {
            this.touches(touches, event, cc.TOUCH_BEGAN);
        }
    },

    /**
     * @param {Array} touches
     * @param {event} event
     */
    touchesMoved:function (touches, event) {
        if (this._dispatchEvents) {
            this.touches(touches, event, cc.TOUCH_MOVED);
        }
    },

    /**
     * @param {Array} touches
     * @param {event} event
     */
    touchesEnded:function (touches, event) {
        if (this._dispatchEvents) {
            this.touches(touches, event, cc.TOUCH_ENDED);
        }
    },

    /**
     * @param {Array} touches
     * @param {event} event
     */
    touchesCancelled:function (touches, event) {
        if (this._dispatchEvents) {
            this.touches(touches, event, cc.TOUCH_CANCELLED);
        }
    },

    /**
     * @param {Array||cc.TouchDelegate} array array or delegate
     * @param {cc.TouchDelegate} delegate
     * @return {cc.TargetedTouchHandler|cc.StandardTouchHandler|Null}
     */
    findHandler:function (array, delegate) {
        switch (arguments.length) {
            case 1:
                delegate = arguments[0];
                for (var i = 0; i < this._targetedHandlers.length; i++) {
                    if (this._targetedHandlers[i].getDelegate() == delegate) {
                        return this._targetedHandlers[i];
                    }
                }
                for (i = 0; i < this._standardHandlers.length; i++) {
                    if (this._standardHandlers[i].getDelegate() == delegate) {
                        return this._standardHandlers[i];
                    }
                }
                return null;
                break;
            case 2:
                cc.Assert(array != null && delegate != null, "TouchDispatcher.findHandler():Arguments is null");

                for (i = 0; i < array.length; i++) {
                    if (array[i].getDelegate() == delegate) {
                        return array[i];
                    }
                }

                return null;
                break;
            default:
                throw "Argument must be non-nil ";
                break;
        }
    },

    /**
     * @param {cc.TouchDelegate} delegate
     */
    forceRemoveDelegate:function (delegate) {
        var handler;
        // XXX: remove it from both handlers ???
        // remove handler from m_pStandardHandlers
        for (var i = 0; i < this._standardHandlers.length; i++) {
            handler = this._standardHandlers[i];
            if (handler && handler.getDelegate() == delegate) {
                cc.ArrayRemoveObject(this._standardHandlers, handler);
                break;
            }
        }

        for (i = 0; i < this._targetedHandlers.length; i++) {
            handler = this._targetedHandlers[i];
            if (handler && handler.getDelegate() == delegate) {
                cc.ArrayRemoveObject(this._targetedHandlers, handler);
                break;
            }
        }
    },

    /**
     * @param {Array} array
     */
    rearrangeHandlers:function (array) {
        array.sort(cc.less);
    }
});

/**
 * @type {cc.Point}
 */
cc.TouchDispatcher.preTouchPoint = cc.p(0, 0);

cc.TouchDispatcher.isRegisterEvent = false;

cc.getHTMLElementPosition = function (element) {
    var pos = null;
    if (element instanceof HTMLCanvasElement) {
        pos = {left:0, top:0, height:element.height};
    } else {
        pos = {left:0, top:0, height:parseInt(element.style.height)};
    }
    while (element != null) {
        pos.left += element.offsetLeft;
        pos.top += element.offsetTop;
        element = element.offsetParent;
    }
    return pos;
};

cc.ProcessMouseupEvent = function (element, event) {
    var pos = cc.getHTMLElementPosition(element);

    var tx = event.pageX;
    var ty = event.pageY;

    var mouseX = (tx - pos.left) / cc.Director.getInstance().getContentScaleFactor();
    var mouseY = (pos.height - (ty - pos.top)) / cc.Director.getInstance().getContentScaleFactor();

    var touch = new cc.Touch(mouseX, mouseY);
    touch._setPrevPoint(cc.TouchDispatcher.preTouchPoint.x, cc.TouchDispatcher.preTouchPoint.y);
    cc.TouchDispatcher.preTouchPoint.x = mouseX;
    cc.TouchDispatcher.preTouchPoint.y = mouseY;

    var set = [];
    set.push(touch);
    cc.Director.getInstance().getTouchDispatcher().touchesEnded(set, null);
};
/**
 * @param {HTMLCanvasElement|HTMLDivElement} element
 */
cc.TouchDispatcher.registerHtmlElementEvent = function (element) {
    if (cc.TouchDispatcher.isRegisterEvent)
        return;

    if (!cc.Browser.isMobile) {
        //register canvas mouse event
        element.addEventListener("mousedown", function (event) {
            var pos = cc.getHTMLElementPosition(element);

            var tx = event.pageX;
            var ty = event.pageY;

            var mouseX = (tx - pos.left) / cc.Director.getInstance().getContentScaleFactor();
            var mouseY = (pos.height - (ty - pos.top)) / cc.Director.getInstance().getContentScaleFactor();

            var touch = new cc.Touch(mouseX, mouseY);
            touch._setPrevPoint(cc.TouchDispatcher.preTouchPoint.x, cc.TouchDispatcher.preTouchPoint.y);
            cc.TouchDispatcher.preTouchPoint.x = mouseX;
            cc.TouchDispatcher.preTouchPoint.y = mouseY;

            var set = [];
            set.push(touch);
            cc.Director.getInstance().getTouchDispatcher().touchesBegan(set, null);
        });

        element.addEventListener("mouseup", function (event) {
            cc.ProcessMouseupEvent(element, event);
        });

        element.addEventListener("mousemove", function (event) {
            var pos = cc.getHTMLElementPosition(element);

            var tx = event.pageX;
            var ty = event.pageY;

            var mouseX = (tx - pos.left) / cc.Director.getInstance().getContentScaleFactor();
            var mouseY = (pos.height - (ty - pos.top)) / cc.Director.getInstance().getContentScaleFactor();

            var touch = new cc.Touch(mouseX, mouseY);

            //TODO this feature only chrome support
            //if((event.button == 0) && (event.which == 1))
            //    touch._setPressed(true);

            touch._setPrevPoint(cc.TouchDispatcher.preTouchPoint.x, cc.TouchDispatcher.preTouchPoint.y);
            cc.TouchDispatcher.preTouchPoint.x = mouseX;
            cc.TouchDispatcher.preTouchPoint.y = mouseY;

            var set = [];
            set.push(touch);

            cc.Director.getInstance().getTouchDispatcher().touchesMoved(set, null);
        });
    } else {
        //register canvas touch event
        element.addEventListener("touchstart", function (event) {
            if (!event.touches)
                return;

            var set = [];
            var pos = cc.getHTMLElementPosition(element);

            pos.left -= document.body.scrollLeft;
            pos.top -= document.body.scrollTop;
            for (var i = 0; i < event.touches.length; i++) {
                var tx = event.touches[i].pageX;
                var ty = event.touches[i].pageY;
                if (event.touches[i]) {
                    tx = event.touches[i].clientX;
                    ty = event.touches[i].clientY;
                }
                var mouseX = (tx - pos.left) / cc.Director.getInstance().getContentScaleFactor();
                var mouseY = (pos.height - (ty - pos.top)) / cc.Director.getInstance().getContentScaleFactor();
                var touch = null;
                if (event.touches[i].hasOwnProperty("identifier"))
                    touch = new cc.Touch(mouseX, mouseY, event.touches[i].identifier);
                else
                    touch = new cc.Touch(mouseX, mouseY);

                touch._setPrevPoint(cc.TouchDispatcher.preTouchPoint.x, cc.TouchDispatcher.preTouchPoint.y);
                cc.TouchDispatcher.preTouchPoint.x = mouseX;
                cc.TouchDispatcher.preTouchPoint.y = mouseY;

                set.push(touch);
            }
            cc.Director.getInstance().getTouchDispatcher().touchesBegan(set, null);
            event.stopPropagation();
            event.preventDefault();
        }, false);

        element.addEventListener("touchmove", function (event) {
            if (!event.touches)
                return;

            var set = [];
            var pos = cc.getHTMLElementPosition(element);

            pos.left -= document.body.scrollLeft;
            pos.top -= document.body.scrollTop;
            for (var i = 0; i < event.touches.length; i++) {
                var tx = event.touches[i].pageX;
                var ty = event.touches[i].pageY;
                if (event.touches[i]) {
                    tx = event.touches[i].clientX;
                    ty = event.touches[i].clientY;
                }
                var mouseX = (tx - pos.left) / cc.Director.getInstance().getContentScaleFactor();
                var mouseY = (pos.height - (ty - pos.top)) / cc.Director.getInstance().getContentScaleFactor();

                var touch = null;
                if (event.touches[i].hasOwnProperty("identifier"))
                    touch = new cc.Touch(mouseX, mouseY, event.touches[i].identifier);
                else
                    touch = new cc.Touch(mouseX, mouseY);
                touch._setPrevPoint(cc.TouchDispatcher.preTouchPoint.x, cc.TouchDispatcher.preTouchPoint.y);
                cc.TouchDispatcher.preTouchPoint.x = mouseX;
                cc.TouchDispatcher.preTouchPoint.y = mouseY;

                set.push(touch);
            }
            cc.Director.getInstance().getTouchDispatcher().touchesMoved(set, null);
            event.stopPropagation();
            event.preventDefault();
        }, false);

        element.addEventListener("touchend", function (event) {
            if (!event.touches)
                return;

            var set = [];
            var pos = cc.getHTMLElementPosition(element);

            pos.left -= document.body.scrollLeft;
            pos.top -= document.body.scrollTop;

            var fireTouches = event.touches;
            if (!fireTouches || (fireTouches.length == 0)) {
                fireTouches = event.changedTouches;
            }
            for (var i = 0; i < fireTouches.length; i++) {
                var tx = fireTouches[i].pageX;
                var ty = fireTouches[i].pageY;
                if (fireTouches[i]) {
                    tx = fireTouches[i].clientX;
                    ty = fireTouches[i].clientY;
                }

                var mouseX = (tx - pos.left) / cc.Director.getInstance().getContentScaleFactor();
                var mouseY = (pos.height - (ty - pos.top)) / cc.Director.getInstance().getContentScaleFactor();

                var touch = null;
                if (fireTouches[i].hasOwnProperty("identifier"))
                    touch = new cc.Touch(mouseX, mouseY, fireTouches[i].identifier);
                else
                    touch = new cc.Touch(mouseX, mouseY);

                touch._setPrevPoint(cc.TouchDispatcher.preTouchPoint.x, cc.TouchDispatcher.preTouchPoint.y);
                cc.TouchDispatcher.preTouchPoint.x = mouseX;
                cc.TouchDispatcher.preTouchPoint.y = mouseY;

                set.push(touch);
            }
            cc.Director.getInstance().getTouchDispatcher().touchesEnded(set, null);
            event.stopPropagation();
            event.preventDefault();
        }, false);

        element.addEventListener("touchcancel", function (event) {
            if (!event.touches)
                return;

            var set = [];
            var pos = cc.getHTMLElementPosition(element);

            pos.left -= document.body.scrollLeft;
            pos.top -= document.body.scrollTop;

            for (var i = 0; i < event.touches.length; i++) {
                var tx = event.touches[i].pageX;
                var ty = event.touches[i].pageY;
                if (event.touches[i]) {
                    tx = event.touches[i].clientX;
                    ty = event.touches[i].clientY;
                }
                var mouseX = (tx - pos.left) / cc.Director.getInstance().getContentScaleFactor();
                var mouseY = (pos.height - (ty - pos.top)) / cc.Director.getInstance().getContentScaleFactor();

                var touch = null;
                if (event.touches[i].hasOwnProperty("identifier"))
                    touch = new cc.Touch(mouseX, mouseY, event.touches[i].identifier);
                else
                    touch = new cc.Touch(mouseX, mouseY);
                touch._setPrevPoint(cc.TouchDispatcher.preTouchPoint.x, cc.TouchDispatcher.preTouchPoint.y);
                cc.TouchDispatcher.preTouchPoint.x = mouseX;
                cc.TouchDispatcher.preTouchPoint.y = mouseY;

                set.push(touch);
            }
            cc.Director.getInstance().getTouchDispatcher().touchesCancelled(set, null);
            event.stopPropagation();
            event.preventDefault();
        }, false);
    }

    cc.TouchDispatcher.isRegisterEvent = true;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/


/**
 * you must extend the keyboardDelegate and
 * implement your own game logic in
 * keydown and keyup functions
 * @class
 * @extends cc.Class
 */
cc.KeyboardDelegate = cc.Class.extend(/** @lends cc.KeyboardDelegate# */{
    /**
     * Call back when a key is pressed down
     */
    onKeyDown:function () {
    },

    /**
     * Call back when a key is released
     */
    onKeyUp:function () {
    }
});

/**
 * KeyboardHandler is an object that contains KeyboardDelegate
 * @class
 * @extends cc.Class
 */
cc.KeyboardHandler = cc.Class.extend(/** @lends cc.KeyboardHandler# */{
    /**
     * returns the keyboard delegate
     * @return {cc.KeyboardDelegate}
     */
    getDelegate:function () {
        return this._delegate;
    },

    /**
     * set the keyboard delegate
     * @param {cc.KeyboardDelegate} delegate
     */
    setDelegate:function (delegate) {
        this._delegate = delegate;
    },
    /**
     * initializes a cc.KeyboardHandler with a delegate
     * @param {cc.KeyboardDelegate} delegate
     * @return {Boolean}
     */
    initWithDelegate:function (delegate) {
        cc.Assert(delegate != null, "It's a wrong delegate!");

        this._delegate = delegate;

        return true;
    },
    _delegate:null
});
/**
 * Create a KeyboardHandler with KeyboardDelegate
 * @param delegate
 * @return {cc.KeyboardHandler}
 */
cc.KeyboardHandler.create = function (delegate) {
    var handler = new cc.KeyboardHandler();
    handler.initWithDelegate(delegate);
    return handler;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * android back button
 * @deprecated These were for android devices, but does not work in html5 environment
 * @constant
 * @type Number
 */
cc.TYPE_BACK_CLICKED = 1;
/**
 * android menu button
 * @deprecated for android devices, does not work in html5 environment
 * @constant
 * @type Number
 */
cc.TYPE_MENU_CLICKED = 2;
/**
 * keymap
 * @example
 * //Example
 * //to mark a keydown
 * cc.keyDown[65] = true;
 * //or
 * cc.keyMap[cc.KEY.a]
 *
 * //to mark a keyup
 * do cc.keyDown[65] = false;
 *
 * //to find out if a key is down, check
 * if(cc.keyDown[65])
 * //or
 * if,(cc.keyDown[cc.KEY.space])
 * //if its undefined or false or null, its not pressed
 * @constant
 * @type object
 */
cc.KEY = {
    backspace:8,
    tab:9,
    enter:13,
    shift:16, //should use shiftkey instead
    ctrl:17, //should use ctrlkey
    alt:18, //should use altkey
    pause:19,
    capslock:20,
    escape:27,
    pageup:33,
    pagedown:34,
    end:35,
    home:36,
    left:37,
    up:38,
    right:39,
    down:40,
    insert:45,
    Delete:46,
    0:48,
    1:49,
    2:50,
    3:51,
    4:52,
    5:53,
    6:54,
    7:55,
    8:56,
    9:57,
    a:65,
    b:66,
    c:67,
    d:68,
    e:69,
    f:70,
    g:71,
    h:72,
    i:73,
    j:74,
    k:75,
    l:76,
    m:77,
    n:78,
    o:79,
    p:80,
    q:81,
    r:82,
    s:83,
    t:84,
    u:85,
    v:86,
    w:87,
    x:88,
    y:89,
    z:90,
    num0:96,
    num1:97,
    num2:98,
    num3:99,
    num4:100,
    num5:101,
    num6:102,
    num7:103,
    num8:104,
    num9:105,
    '*':106,
    '+':107,
    '-':109,
    'numdel':110,
    '/':111,
    f1:112, //f1-f12 dont work on ie
    f2:113,
    f3:114,
    f4:115,
    f5:116,
    f6:117,
    f7:118,
    f8:119,
    f9:120,
    f10:121,
    f11:122,
    f12:123,
    numlock:144,
    scrolllock:145,
    semicolon:186,
    ',':186,
    equal:187,
    '=':187,
    ';':188,
    comma:188,
    dash:189,
    '.':190,
    period:190,
    forwardslash:191,
    grave:192,
    '[':219,
    openbracket:219,
    ']':221,
    closebracket:221,
    backslash:220,
    quote:222,
    space:32
};

/**
 * Dispatch the keyboard message
 * @class
 * @extends cc.Class
 */
cc.KeyboardDispatcher = cc.Class.extend(/** @lends cc.KeyboardDispatcher# */{
    /**
     * add delegate to concern keyboard msg
     * @param {cc.KeyboardDelegate} delegate keyboard delegate object
     */
    addDelegate:function (delegate) {
        if (!delegate) {
            return;
        }
        if (!this._locked) {
            this.forceAddDelegate(delegate);
        }
        else {
            this._handlersToAdd.push(delegate);
            this._toAdd = true;
        }
    },

    /**
     * remove the delegate from the delegates who concern keyboard msg
     * @param {cc.KeyboardDelegate} delegate
     */
    removeDelegate:function (delegate) {
        if (!delegate) {
            return;
        }
        if (!this._locked) {
            this.forceRemoveDelegate(delegate);
        }
        else {
            this._handlersToRemove.push(delegate);
            this._toRemove = true;
        }
    },

    /**
     * force add the delegate
     * @param {cc.KeyboardDelegate} delegate
     */
    forceAddDelegate:function (delegate) {
        var handler = cc.KeyboardHandler.create(delegate);
        if (handler) {
            //if handler already exist
            for (var i = 0; i < this._delegates; i++) {
                if (this._delegates[i].getDelegate() == handler.getDelegate()) {
                }
            }
            this._delegates.push(handler);
        }
    },

    /**
     * force remove the delegate
     * @param {cc.KeyboardDelegate} delegate
     */
    forceRemoveDelegate:function (delegate) {
        for (var i = 0; i < this._delegates.length; i++) {
            if (this._delegates[i].getDelegate() == delegate) {
                this._delegates.splice(i, 1);
                return;
            }
        }
    },

    /**
     * dispatch the keyboard message to the delegates
     * @param {event} e
     * @param {Boolean} keydown whether this is a keydown or keyup
     * @return {Boolean}
     */
    dispatchKeyboardMSG:function (e, keydown) {
        this._locked = true;
        e.stopPropagation();
        e.preventDefault();
        //update keymap
        if (keydown && e)//if keydown and our keymap doesnt have it
        {
            //execute all deletegate that registered a keyboard event
            for (var i = 0; i < this._delegates.length; i++) {
                this._delegates[i].getDelegate().onKeyDown(e.keyCode);
            }
        }
        else if (!keydown && e)//if keyup and our keymap have that key in it
        {
            for (var i = 0; i < this._delegates.length; i++) {
                this._delegates[i].getDelegate().onKeyUp(e.keyCode);
            }
        }
        this._locked = false;
        if (this._toRemove) {
            this._toRemove = false;
            for (var i = 0; i < this._handlersToRemove.length; ++i) {
                this.forceRemoveDelegate(this._handlersToRemove[i]);
            }
            delete this._handlersToRemove;
            this._handlersToRemove = [];
        }

        if (this._toAdd) {
            this._toAdd = false;
            for (var i = 0; i < this._handlersToAdd.length; ++i) {
                this.forceAddDelegate(this._handlersToAdd[i]);
            }
            this._handlersToAdd = [];
        }
        return true;
    },

    //private
    _delegates:[],
    _locked:false,
    _toAdd:false,
    _toRemove:false,
    _handlersToAdd:[],
    _handlersToRemove:[]
});

/**
 * Returns the shared cc.KeyboardDispatcher object for the system.
 * @return {cc.keyboardDispatcher}
 */
cc.KeyboardDispatcher.getInstance = function () {
    if (!cc.keyboardDispatcher) {
        cc.keyboardDispatcher = new cc.KeyboardDispatcher();
        //make canvas focusable
        cc.canvas.setAttribute('contentEditable', true);
        cc.canvas.style.outline = 'none';
        cc.canvas.style.cursor = 'default';
        cc.canvas.addEventListener("keydown", function (e) {
            cc.keyboardDispatcher.dispatchKeyboardMSG(e, true);
            cc.IMEDispatcher.getInstance().processKeycode(e.keyCode);
        });
        cc.canvas.addEventListener("keyup", function (e) {
            cc.keyboardDispatcher.dispatchKeyboardMSG(e, false);
        });
    }
    return cc.keyboardDispatcher;
};

/**
 * Release the shared cc.KeyboardDispatcher object from the system.
 */
cc.KeyboardDispatcher.purgeSharedDispatcher = function () {
    if (cc.keyboardDispatcher) {
        delete cc.keyboardDispatcher;
        cc.keyboardDispatcher = null;
    }
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * IME Keyboard Notification Info structure
 * @param {cc.Rect} begin the soft keyboard rectangle when animatin begin
 * @param {cc.Rect} end the soft keyboard rectangle when animatin end
 * @param {Number} duration the soft keyboard animation duration
 */
cc.IMEKeyboardNotificationInfo = function (begin, end, duration) {
    this.begin = begin || cc.RectZero();
    this.end = end || cc.RectZero();
    this.duration = duration || 0;
};

/**
 * Input method editor delegate.
 * @class
 * @extends cc.Class
 */
cc.IMEDelegate = cc.Class.extend(/** @lends cc.IMEDelegate# */{
    /**
     * Constructor
     */
    ctor:function () {
        cc.IMEDispatcher.getInstance().addDelegate(this);
    },
    /**
     * Remove delegate
     */
    removeDelegate:function () {
        cc.IMEDispatcher.getInstance().removeDelegate(this);
    },
    /**
     * Remove delegate
     * @return {Boolean}
     */
    attachWithIME:function () {
        return cc.IMEDispatcher.getInstance().attachDelegateWithIME(this);
    },
    /**
     * Detach with IME
     * @return {Boolean}
     */
    detachWithIME:function () {
        return cc.IMEDispatcher.getInstance().detachDelegateWithIME(this);
    },

    /**
     * Decide the delegate instance is ready for receive ime message or not.<br />
     * Called by CCIMEDispatcher.
     * @return {Boolean}
     */
    canAttachWithIME:function () {
        return false;
    },

    /**
     * When the delegate detach with IME, this method call by CCIMEDispatcher.
     */
    didAttachWithIME:function () {
    },

    /**
     * Decide the delegate instance can stop receive ime message or not.
     * @return {Boolean}
     */
    canDetachWithIME:function () {
        return false;
    },

    /**
     * When the delegate detach with IME, this method call by CCIMEDispatcher.
     */
    didDetachWithIME:function () {
    },

    /**
     * Called by CCIMEDispatcher when some text input from IME.
     */
    insertText:function (text, len) {
    },

    /**
     * Called by CCIMEDispatcher when user clicked the backward key.
     */
    deleteBackward:function () {
    },

    /**
     * Called by CCIMEDispatcher for get text which delegate already has.
     * @return {String}
     */
    getContentText:function () {
        return "";
    },

    //////////////////////////////////////////////////////////////////////////
    // keyboard show/hide notification
    //////////////////////////////////////////////////////////////////////////
    keyboardWillShow:function (info) {
    },
    keyboardDidShow:function (info) {
    },
    keyboardWillHide:function (info) {
    },
    keyboardDidHide:function (info) {
    }
});


/**
 * Input Method Edit Message Dispatcher.
 * @class
 * @extends cc.Class
 */
cc.IMEDispatcher = cc.Class.extend(/**  @lends cc.IMEDispatcher# */{
    impl:null,
    /**
     * Constructor
     */
    ctor:function () {
        this.impl = new cc.IMEDispatcher.Impl();
    },
    /**
     * Dispatch the input text from ime
     * @param {String} text
     * @param {Number} len
     */
    dispatchInsertText:function (text, len) {
        if (!this.impl || !text || len <= 0)
            return;

        // there is no delegate attach with ime
        if (!this.impl._delegateWithIme)
            return;

        this.impl._delegateWithIme.insertText(text, len);
    },

    /**
     * Dispatch the delete backward operation
     */
    dispatchDeleteBackward:function () {
        if (!this.impl) {
            return;
        }

        // there is no delegate attach with ime
        if (!this.impl._delegateWithIme)
            return;

        this.impl._delegateWithIme.deleteBackward();
    },

    /**
     * Get the content text, which current CCIMEDelegate which attached with IME has.
     * @return {String}
     */
    getContentText:function () {
        if (this.impl && this.impl._delegateWithIme) {
            var pszContentText = this.impl._delegateWithIme.getContentText();
            return (pszContentText) ? pszContentText : "";
        }
        return "";
    },

    /**
     * Dispatch keyboard notification
     * @param {cc.IMEKeyboardNotificationInfo} info
     */
    dispatchKeyboardWillShow:function (info) {
        if (this.impl) {
            for (var i = 0; i < this.impl._delegateList.length; i++) {
                var delegate = this.impl._delegateList[i];
                if (delegate) {
                    delegate.keyboardWillShow(info);
                }
            }
        }
    },
    /**
     * Dispatch keyboard notification
     * @param {cc.IMEKeyboardNotificationInfo} info
     */
    dispatchKeyboardDidShow:function (info) {
        if (this.impl) {
            for (var i = 0; i < this.impl._delegateList.length; i++) {
                var delegate = this.impl._delegateList[i];
                if (delegate) {
                    delegate.keyboardDidShow(info);
                }
            }
        }
    },
    /**
     * Dispatch keyboard notification
     * @param {cc.IMEKeyboardNotificationInfo} info
     */
    dispatchKeyboardWillHide:function (info) {
        if (this.impl) {
            for (var i = 0; i < this.impl._delegateList.length; i++) {
                var delegate = this.impl._delegateList[i];
                if (delegate) {
                    delegate.keyboardWillHide(info);
                }
            }
        }
    },
    /**
     * Dispatch keyboard notification
     * @param {cc.IMEKeyboardNotificationInfo} info
     */
    dispatchKeyboardDidHide:function (info) {
        if (this.impl) {
            for (var i = 0; i < this.impl._delegateList.length; i++) {
                var delegate = this.impl._delegateList[i];
                if (delegate) {
                    delegate.keyboardDidHide(info);
                }
            }
        }
    },

    /**
     * Add delegate to concern ime msg
     * @param {cc.IMEDelegate} delegate
     * @example
     * //example
     * cc.IMEDispatcher.getInstance().addDelegate(this);
     */
    addDelegate:function (delegate) {
        if (!delegate || !this.impl) {
            return;
        }
        if (this.impl._delegateList.indexOf(delegate) > -1) {
            // delegate already in list
            return;
        }
        this.impl._delegateList = cc.ArrayAppendObjectToIndex(this.impl._delegateList, delegate, 0);
    },

    /**
     * Attach the pDeleate with ime.
     * @param {cc.IMEDelegate} delegate
     * @return {Boolean} If the old delegate can detattach with ime and the new delegate can attach with ime, return true, otherwise return false.
     * @example
     * //example
     * var ret = cc.IMEDispatcher.getInstance().attachDelegateWithIME(this);
     */
    attachDelegateWithIME:function (delegate) {
        if (!this.impl || !delegate) {
            return false;
        }

        // if delegate is not in delegate list, return
        if (this.impl._delegateList.indexOf(delegate) == -1) {
            return false;
        }

        if (this.impl._delegateWithIme) {
            // if old delegate canDetachWithIME return false
            // or delegate canAttachWithIME return false,
            // do nothing.
            if (!this.impl._delegateWithIme.canDetachWithIME()
                || !delegate.canAttachWithIME())
                return false;

            // detach first
            var pOldDelegate = this.impl._delegateWithIme;
            this.impl._delegateWithIme = null;
            pOldDelegate.didDetachWithIME();

            this.impl._delegateWithIme = delegate;
            delegate.didAttachWithIME();
            return true;
        }

        // havn't delegate attached with IME yet
        if (!delegate.canAttachWithIME())
            return false;

        this.impl._delegateWithIme = delegate;
        delegate.didAttachWithIME();
        return true;
    },
    /**
     * Detach the pDeleate with ime.
     * @param {cc.IMEDelegate} delegate
     * @return {Boolean} If the old delegate can detattach with ime and the new delegate can attach with ime, return true, otherwise return false.
     * @example
     * //example
     * var ret = cc.IMEDispatcher.getInstance().detachDelegateWithIME(this);
     */
    detachDelegateWithIME:function (delegate) {
        if (!this.impl || !delegate) {
            return false;
        }

        // if delegate is not the current delegate attached with ime, return
        if (this.impl._delegateWithIme != delegate) {
            return false;
        }

        if (!delegate.canDetachWithIME()) {
            return false;
        }

        this.impl._delegateWithIme = 0;
        delegate.didDetachWithIME();
        return true;
    },

    /**
     * Remove the delegate from the delegates who concern ime msg
     * @param {cc.IMEDelegate} delegate
     * @example
     * //example
     * cc.IMEDispatcher.getInstance().removeDelegate(this);
     */
    removeDelegate:function (delegate) {
        if (!this.impl || !delegate) {
            return;
        }

        // if delegate is not in delegate list, return
        if (this.impl._delegateList.indexOf(delegate) == -1) {
            return;
        }

        if (this.impl._delegateWithIme) {
            if (delegate == this.impl._delegateWithIme) {
                this.impl._delegateWithIme = null;
            }
        }
        cc.ArrayRemoveObject(this.impl._delegateList, delegate);
    },

    /**
     * Process keydown's keycode
     * @param {Number} keyCode
     * @example
     * //example
     * document.addEventListener("keydown", function (e) {
     *      cc.IMEDispatcher.getInstance().processKeycode(e.keyCode);
     * });
     */
    processKeycode:function (keyCode) {
        if (keyCode < 32) {
            if (keyCode == cc.KEY.backspace) {
                this.dispatchDeleteBackward();
            } else if (keyCode == cc.KEY.enter) {
                this.dispatchInsertText("\n", 1);
            } else if (keyCode == cc.KEY.tab) {
                //tab input
            } else if (keyCode == cc.KEY.escape) {
                //ESC input
            }
        } else if (keyCode < 255) {
            this.dispatchInsertText(String.fromCharCode(keyCode), 1);
        } else {
            //
        }
    }
});

/**
 * @class
 * @extends cc.Class
 */
cc.IMEDispatcher.Impl = cc.Class.extend(/** @lends cc.IMEDispatcher.Impl# */{
    _delegateWithIme:null,
    _delegateList:null,
    /**
     * Constructor
     */
    ctor:function () {
        this._delegateList = [];
    },
    /**
     * Find delegate
     * @param {cc.IMEDelegate} delegate
     * @return {Number|Null}
     */
    findDelegate:function (delegate) {
        for (var i = 0; i < this._delegateList.length; i++) {
            if (this._delegateList[i] == delegate) {
                return i;
            }
        }
        return null;
    }
});

/**
 * Returns the shared CCIMEDispatcher object for the system.
 * @return {cc.IMEDispatcher}
 */
cc.IMEDispatcher.getInstance = function () {
    if (!cc.IMEDispatcher.instance) {
        cc.IMEDispatcher.instance = new cc.IMEDispatcher();
        cc.KeyboardDispatcher.getInstance();
    }
    return cc.IMEDispatcher.instance;
};

/**
 * @type object
 */
cc.IMEDispatcher.instance = null;
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * Text field delegate
 * @class
 * @extends cc.Class
 */
cc.TextFieldDelegate = cc.Class.extend(/** @lends cc.TextFieldDelegate# */{
    /**
     * If the sender doesn't want to attach with IME, return true;
     * @param {cc.TextFieldTTF} sender
     * @return {Boolean}
     */
    onTextFieldAttachWithIME:function (sender) {
        return false;
    },

    /**
     * If the sender doesn't want to detach with IME, return true;
     * @param {cc.TextFieldTTF} sender
     * @return {Boolean}
     */
    onTextFieldDetachWithIME:function (sender) {
        return false;
    },

    /**
     * If the sender doesn't want to insert the text, return true;
     * @param {cc.TextFieldTTF} sender
     * @param {String} text
     * @param {Number} len
     * @return {Boolean}
     */
    onTextFieldInsertText:function (sender, text, len) {
        return false
    },

    /**
     * f the sender doesn't want to delete the delText, return true;
     * @param {cc.TextFieldTTF} sender
     * @param {String} delText
     * @param {Number} len
     * @return {Boolean}
     */
    onTextFieldDeleteBackward:function (sender, delText, len) {
        return false;
    },

    /**
     * If doesn't want draw sender as default, return true.
     * @param {cc.TextFieldTTF} sender
     * @return {Boolean}
     */
    onDraw:function (sender) {
        return false;
    }
});

/**
 * A simple text input field with TTF font.
 * @class
 * @extends cc.LabelTTF
 */
cc.TextFieldTTF = cc.LabelTTF.extend(/** @lends cc.TextFieldTTF# */{
    _lens:null,
    _inputText:"",
    _placeHolder:"",
    _charCount:0,
    _delegate:null,
    _ColorSpaceHolder:null,
    /**
     * Constructor
     */
    ctor:function () {
        this._ColorSpaceHolder = new cc.Color3B(127, 127, 127);
        cc.IMEDispatcher.getInstance().addDelegate(this);
        this._super();
    },
    /**
     * @return {cc.Node}
     */
    getDelegate:function () {
        return this._delegate;
    },
    /**
     * @param {cc.Node} value
     */
    setDelegate:function (value) {
        this._delegate = value;
    },
    /**
     * @return {Number}
     */
    getCharCount:function () {
        return this._charCount;
    },
    /**
     * @return {cc.Color3B}
     */
    getColorSpaceHolder:function () {
        return this._ColorSpaceHolder;
    },
    /**
     * @param {cc.Color3B} value
     */
    setColorSpaceHolder:function (value) {
        this._ColorSpaceHolder = value;
    },
    /**
     * Initializes the cc.TextFieldTTF with a font name, alignment, dimension and font size
     * @param {String} placeholder
     * @param {cc.Size} dimensions
     * @param {Number} alignment
     * @param {String} fontName
     * @param {Number} fontSize
     * @return {Boolean}
     * @example
     * //example
     * var  textField = new cc.TextFieldTTF();
     * // When five parameters
     * textField.initWithPlaceHolder("<click here for input>", cc.size(100,50), cc.TEXT_ALIGNMENT_LEFT,"Arial", 32);
     * // When three parameters
     * textField.initWithPlaceHolder("<click here for input>", "Arial", 32);
     */
    initWithPlaceHolder:function (placeholder, dimensions, alignment, fontName, fontSize) {
        switch (arguments.length) {
            case 5:
                if (placeholder) {
                    this._placeHolder = placeholder;
                }
                return this.initWithString(this._placeHolder, dimensions, alignment, fontName, fontSize);
                break;
            case 3:
                if (placeholder) {
                    this._placeHolder = placeholder;
                }
                fontName = arguments[1];
                fontSize = arguments[2];
                return this.initWithString(this._placeHolder, fontName, fontSize);
                break;
            default:
                throw "Argument must be non-nil ";
                break;
        }
    },
    /**
     * Input text property
     * @param {String} text
     * @param {Boolean} isCallParent
     */
    setString:function (text, isCallParent) {
        if (isCallParent && isCallParent == true) {
            this._super(text);
            return;
        }
        if (text) {
            this._inputText = text;
        } else {
            this._inputText = "";
        }

        // if there is no input text, display placeholder instead
        if (!this._inputText.length) {
            this._super(this._placeHolder);
        } else {
            this._super(this._inputText);
        }
        this._charCount = this._inputText.length;
    },
    /**
     * @return {String}
     */
    getString:function () {
        return this._inputText;
    },
    /**
     * @param {String} text
     */
    setPlaceHolder:function (text) {
        this._placeHolder = text || "";
        if (!this._inputText.length) {
            this.setString(this._placeHolder, true);
        }
    },
    /**
     * @return {String}
     */
    getPlaceHolder:function () {
        return this._placeHolder;
    },
    /**
     * @param {CanvasContext} ctx
     */
    draw:function (ctx) {
        var context = ctx || cc.renderContext;
        if (this._delegate && this._delegate.onDraw(this)) {
            return;
        }
        if (this._inputText) {
            this._super(context);
            return;
        }

        // draw placeholder
        var color = this.getColor();
        this.setColor(this._ColorSpaceHolder);
        this._super(context);
        this.setColor(color);
    },

    //////////////////////////////////////////////////////////////////////////
    // CCIMEDelegate interface
    //////////////////////////////////////////////////////////////////////////
    /**
     * Open keyboard and receive input text.
     * @return {Boolean}
     */
    attachWithIME:function () {
        var ret = cc.IMEDispatcher.getInstance().attachDelegateWithIME(this);
        return ret;
    },
    /**
     * End text input  and close keyboard.
     * @return {Boolean}
     */
    detachWithIME:function () {
        var ret = cc.IMEDispatcher.getInstance().detachDelegateWithIME(this);
        return ret;
    },
    /**
     * @return {Boolean}
     */
    canAttachWithIME:function () {
        return (this._delegate) ? (!this._delegate.onTextFieldAttachWithIME(this)) : true;
    },

    /**
     * When the delegate detach with IME, this method call by CCIMEDispatcher.
     */
    didAttachWithIME:function () {
    },
    /**
     * @return {Boolean}
     */
    canDetachWithIME:function () {
        return (this._delegate) ? (!this._delegate.onTextFieldDetachWithIME(this)) : true;
    },

    /**
     * When the delegate detach with IME, this method call by CCIMEDispatcher.
     */
    didDetachWithIME:function () {
    },
    /**
     *  Delete backward
     */
    deleteBackward:function () {
        var nStrLen = this._inputText.length;
        if (nStrLen == 0) {
            // there is no string
            return;
        }

        // get the delete byte number
        var nDeleteLen = 1;    // default, erase 1 byte

        if (this._delegate && this._delegate.onTextFieldDeleteBackward(this, this._inputText[nStrLen - nDeleteLen], nDeleteLen)) {
            // delegate don't want delete backward
            return;
        }

        // if delete all text, show space holder string
        if (nStrLen <= nDeleteLen) {
            this._inputText = "";
            this._charCount = 0;
            this.setString(this._placeHolder, true);
            return;
        }

        // set new input text
        var sText = this._inputText.substring(0, nStrLen - nDeleteLen);
        this.setString(sText);
    },
    /**
     *  Remove delegate
     */
    removeDelegate:function () {
        cc.IMEDispatcher.getInstance().removeDelegate(this);
    },
    /**
     * @param {String} text
     * @param {Number} len
     */
    insertText:function (text, len) {
        var sInsert = text;

        // insert \n means input end
        var nPos = sInsert.indexOf('\n');
        if (nPos > -1) {
            sInsert = sInsert.substring(0, nPos);
        }

        if (sInsert.length > 0) {
            if (this._delegate && this._delegate.onTextFieldInsertText(this, sInsert, sInsert.length)) {
                // delegate doesn't want insert text
                return;
            }

            var sText = this._inputText + sInsert;
            this._charCount = sText.length;
            this.setString(sText);
        }

        if (nPos == -1) {
            return;
        }

        // '\n' has inserted,  let delegate process first
        if (this._delegate && this._delegate.onTextFieldInsertText(this, "\n", 1)) {
            return;
        }

        // if delegate hasn't process, detach with ime as default
        this.detachWithIME();
    },
    /**
     * @return {String}
     */
    getContentText:function () {
        return this._inputText;
    },

    //////////////////////////////////////////////////////////////////////////
    // keyboard show/hide notification
    //////////////////////////////////////////////////////////////////////////
    keyboardWillShow:function (info) {
    },
    keyboardDidShow:function (info) {
    },
    keyboardWillHide:function (info) {
    },
    keyboardDidHide:function (info) {
    }
});

/**
 *  creates a cc.TextFieldTTF from a fontName, alignment, dimension and font size
 * @param {String} placeholder
 * @param {cc.Size} dimensions
 * @param {Number} alignment
 * @param {String} fontName
 * @param {Number} fontSize
 * @return {cc.TextFieldTTF|Null}
 * @example
 * //example
 * // When five parameters
 * var textField = cc.TextFieldTTF.create("<click here for input>", cc.size(100,50), cc.TEXT_ALIGNMENT_LEFT,"Arial", 32);
 * // When three parameters
 * var textField = cc.TextFieldTTF.create("<click here for input>", "Arial", 32);
 */
cc.TextFieldTTF.create = function (placeholder, dimensions, alignment, fontName, fontSize) {
    switch (arguments.length) {
        case 5:
            var ret = new cc.TextFieldTTF();
            if (ret && ret.initWithPlaceHolder("", dimensions, alignment, fontName, fontSize)) {
                if (placeholder) {
                    ret.setPlaceHolder(placeholder);
                }
                return ret;
            }
            return null;
            break;
        case 3:
            var ret = new cc.TextFieldTTF();
            fontName = arguments[1];
            fontSize = arguments[2];
            if (ret && ret.initWithString(["", fontName, fontSize])) {
                if (placeholder) {
                    ret.setPlaceHolder(placeholder);
                }
                return ret;
            }
            return null;
            break;
        default:
            throw "Argument must be non-nil ";
            break;
    }
};

/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

cc.g_NumberOfDraws = 0;

//Possible OpenGL projections used by director
/**
 * sets a 2D projection (orthogonal projection)
 * @constant
 * @type Number
 */
cc.DIRECTOR_PROJECTION_2D = 0;

/**
 * sets a 3D projection with a fovy=60, znear=0.5f and zfar=1500.
 * @constant
 * @type Number
 */
cc.DIRECTOR_PROJECTION_3D = 1;

/**
 * it calls "updateProjection" on the projection delegate.
 * @constant
 * @type Number
 */
cc.DIRECTOR_PROJECTION_CUSTOM = 3;

/**
 * Detault projection is 3D projection
 * @constant
 * @type Number
 */
cc.DIRECTOR_PROJECTION_DEFAULT = cc.DIRECTOR_PROJECTION_3D;

//----------------------------------------------------------------------------------------------------------------------
//Possible device orientations
/**
 * Device oriented vertically, home button on the bottom (UIDeviceOrientationPortrait)
 * @constant
 * @type Number
 */
cc.DEVICE_ORIENTATION_PORTRAIT = 0;

/**
 * Device oriented horizontally, home button on the right (UIDeviceOrientationLandscapeLeft)
 * @constant
 * @type Number
 */
cc.DEVICE_ORIENTATION_LANDSCAPE_LEFT = 1;

/**
 * Device oriented vertically, home button on the top (UIDeviceOrientationPortraitUpsideDown)
 * @constant
 * @type Number
 */
cc.DEVICE_ORIENTATION_PORTRAIT_UPSIDE_DOWN = 2;

/**
 * Device oriented horizontally, home button on the left (UIDeviceOrientationLandscapeRight)
 * @constant
 * @type Number
 */
cc.DEVICE_ORIENTATION_LANDSCAPE_RIGHT = 3;

/**
 * In browsers, we only support 2 orientations by change window size.
 * @constant
 * @type Number
 */
cc.DEVICE_MAX_ORIENTATIONS = 2;


//----------------------------------------------------------------------------------------------------------------------

/**
 * <p>
 *    Class that creates and handle the main Window and manages how<br/>
 *    and when to execute the Scenes.<br/>
 *    <br/>
 *    The cc.Director is also responsible for:<br/>
 *      - initializing the OpenGL context<br/>
 *      - setting the OpenGL pixel format (default on is RGB565)<br/>
 *      - setting the OpenGL pixel format (default on is RGB565)<br/>
 *      - setting the OpenGL buffer depth (default one is 0-bit)<br/>
 *      - setting the projection (default one is 3D)<br/>
 *      - setting the orientation (default one is Protrait)<br/>
 *      <br/>
 *    Since the cc.Director is a singleton, the standard way to use it is by calling:<br/>
 *      - cc.Director.getInstance().methodName(); <br/>
 *    <br/>
 *    The CCDirector also sets the default OpenGL context:<br/>
 *      - GL_TEXTURE_2D is enabled<br/>
 *      - GL_VERTEX_ARRAY is enabled<br/>
 *      - GL_COLOR_ARRAY is enabled<br/>
 *      - GL_TEXTURE_COORD_ARRAY is enabled<br/>
 * </p>
 * @class
 * @extends cc.Class
 */
cc.Director = cc.Class.extend(/** @lends cc.Director# */{
    //Variables
    _isContentScaleSupported:false,
    _landscape:false,
    _nextDeltaTimeZero:false,
    _paused:false,
    _purgeDirecotorInNextLoop:false,
    _sendCleanupToScene:false,
    _animationInterval:0.0,
    _oldAnimationInterval:0.0,
    _projection:0,
    _accumDt:0.0,
    _contentScaleFactor:1.0,

    _displayStats:false,
    _deltaTime:0.0,
    _frameRate:0.0,

    _FPSLabel:null,
    _SPFLabel:null,
    _drawsLabel:null,

    _winSizeInPixels:null,
    _winSizeInPoints:null,

    _lastUpdate:null,
    _nextScene:null,
    _notificationNode:null,
    _openGLView:null,
    _scenesStack:null,
    _projectionDelegate:null,
    _runningScene:null,
    _szFPS:'',
    _frames:0,
    _totalFrames:0,
    _secondsPerFrame:0,

    _dirtyRegion:null,

    _scheduler:null,
    _actionManager:null,
    _touchDispatcher:null,
    _keyboardDispatcher:null,
    _accelerometer:null,

    _watcherFun:null,
    _watcherSender:null,

    /**
     * Constructor
     */
    ctor:function () {

    },

    /**
     * initializes cc.Director
     * @return {Boolean}
     */
    init:function () {
        // scenes
        //TODO these are already set to null, so maybe we can remove them in the init?
        this._runningScene = null;
        this._nextScene = null;
        this._notificationNode = null;

        this._oldAnimationInterval = this._animationInterval = 1.0 / cc.defaultFPS;
        this._scenesStack = [];
        // Set default projection (3D)
        this._projection = cc.DIRECTOR_PROJECTION_DEFAULT;
        // projection delegate if "Custom" projection is used
        this._projectionDelegate = null;

        //FPS
        this._accumDt = 0;
        this._frameRate = 0;
        this._displayStats = false;//can remove
        this._totalFrames = this._frames = 0;
        this._szFPS = "";
        this._lastUpdate = new cc.timeval();

        //Paused?
        this._paused = false;

        //purge?
        this._purgeDirecotorInNextLoop = false;
        this._winSizeInPixels = this._winSizeInPoints = cc.size(cc.canvas.width, cc.canvas.height);

        this._openGLView = null;
        this._contentScaleFactor = 1.0;
        this._isContentScaleSupported = false;

        this._watcherFun = null;
        this._watcherSender = null;

        //scheduler
        this._scheduler = new cc.Scheduler();
        //action manager
        this._actionManager = new cc.ActionManager();
        this._scheduler.scheduleUpdateForTarget(this._actionManager, cc.PRIORITY_SYSTEM, false);
        //touchDispatcher
        this._touchDispatcher = new cc.TouchDispatcher();
        this._touchDispatcher.init();

        //KeyboardDispatcher
        this._keyboardDispatcher = cc.KeyboardDispatcher.getInstance();

        //accelerometer
        //this._accelerometer = new cc.Accelerometer();

        return true;
    },

    /**
     * calculates delta time since last time it was called
     */
    calculateDeltaTime:function () {
        var now = new cc.timeval();
        now = cc.Time.gettimeofdayCocos2d();
        if (!now) {
            cc.log("error in gettimeofday");
            this._deltaTime = 0;
            return;
        }

        // new delta time.
        if (this._nextDeltaTimeZero) {
            this._deltaTime = 0;
            this._nextDeltaTimeZero = false;
        } else {
            this._deltaTime = (now.tv_sec - this._lastUpdate.tv_sec) + (now.tv_usec - this._lastUpdate.tv_usec) / 1000000.0;
            this._deltaTime = Math.max(0, this._deltaTime);
        }

        if (cc.DEBUG) {
            if (this._deltaTime > 0.2) {
                this._deltaTime = 1 / 60.0;
            }
        }
        this._lastUpdate = now;
    },

    /**
     * <p>
     *     converts a UIKit coordinate to an OpenGL coordinate<br/>
     *     Useful to convert (multi) touches coordinates to the current layout (portrait or landscape)
     * </p>
     * @param {cc.Point} point
     * @return {cc.Point}
     */
    convertToGL:function (point) {
        var newY = this._winSizeInPoints.height - point.y;
        return cc.p(point.x, newY);
    },

    /**
     * <p>converts an OpenGL coordinate to a UIKit coordinate<br/>
     * Useful to convert node points to window points for calls such as glScissor</p>
     * @param {cc.Point} point
     * @return {cc.Point}
     */
    convertToUI:function (point) {
        var oppositeY = this._winSizeInPoints.height - point.y;
        return cc.p(point.x, oppositeY);
    },

    //_fullRect:null,
    /**
     *  Draw the scene. This method is called every frame. Don't call it manually.
     */
    drawScene:function () {
        // calculate "global" dt
        this.calculateDeltaTime();

        //tick before glClear: issue #533
        if (!this._paused) {
            this._scheduler.update(this._deltaTime);
        }
        //this._fullRect = cc.rect(0, 0, cc.canvas.width, cc.canvas.height);
        //cc.renderContext.clearRect(this._fullRect.origin.x, this._fullRect.origin.y, this._fullRect.size.width, -this._fullRect.size.height);
        cc.renderContext.clearRect(0, 0, cc.canvas.width, -cc.canvas.height);

        /*
         var isSaveContext = false;
         //glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

         if (this._dirtyRegion) {
         //cc.renderContext.clearRect(0, 0, cc.canvas.width, -cc.canvas.height);

         var fullRect = cc.rect(0, 0, cc.canvas.width, cc.canvas.height);
         this._dirtyRegion = cc.Rect.CCRectIntersection(this._dirtyRegion, fullRect);

         if(cc.Rect.CCRectEqualToRect(cc.RectZero(), this._dirtyRegion)){
         this._dirtyRegion = null;
         }else{
         cc.renderContext.clearRect(0 | this._dirtyRegion.origin.x, -(0 | this._dirtyRegion.origin.y),
         0 | this._dirtyRegion.size.width, -(0 | this._dirtyRegion.size.height));

         if(!cc.Rect.CCRectEqualToRect(fullRect, this._dirtyRegion)){
         isSaveContext = true;
         cc.renderContext.save();
         cc.renderContext.beginPath();
         cc.renderContext.rect(0 | this._dirtyRegion.origin.x - 1, -(0 | this._dirtyRegion.origin.y - 1),
         0 | this._dirtyRegion.size.width + 2, -(0 | this._dirtyRegion.size.height + 2));
         cc.renderContext.clip();
         cc.renderContext.closePath();
         }
         }
         }
         */

        /* to avoid flickr, nextScene MUST be here: after tick and before draw.
         XXX: Which bug is this one. It seems that it can't be reproduced with v0.9 */
        if (this._nextScene) {
            this.setNextScene();
        }

        //kmGLPushMatrix();

        // draw the scene
        if (this._runningScene) {
            //if (this._dirtyRegion) {
            this._runningScene.visit();
            //}
        }

        /*
         if (this._dirtyRegion) {
         this._dirtyRegion = null;
         if(isSaveContext){
         cc.renderContext.restore();
         }
         }
         */

        // draw the notifications node
        if (this._notificationNode) {
            this._notificationNode.visit();
        }

        if (this._displayStats) {
            this._showStats();
        }

        if (this._watcherFun && this._watcherSender) {
            this._watcherFun.call(this._watcherSender);
        }

        //TODO OpenGL
        //kmGLPopMatrix();

        this._totalFrames++;

        // swap buffers
        if (this._openGLView) {
            this._openGLView.swapBuffers();
        }

        if (this._displayStats) {
            this._calculateMPF();
        }
    },

    addRegionToDirtyRegion:function (rect) {
        if (!rect)
            return;

        if (!this._dirtyRegion) {
            this._dirtyRegion = cc.rect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
            return;
        }
        this._dirtyRegion = cc.Rect.CCRectUnion(this._dirtyRegion,
            cc.rect(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height));
    },

    rectIsInDirtyRegion:function (rect) {
        if (!rect || !this._fullRect)
            return false;

        return cc.Rect.CCRectIntersectsRect(this._fullRect, rect);
    },

    /**
     * <p>
     *   Will enable Retina Display on devices that supports it. <br/>
     *   It will enable Retina Display on iPhone4 and iPod Touch 4.<br/>
     *   It will return YES, if it could enabled it, otherwise it will return NO.<br/>
     *   <br/>
     *   This is the recommened way to enable Retina Display.
     * </p>
     * @param {Boolean} enabled
     * @return {Boolean}
     */
    enableRetinaDisplay:function (enabled) {
        // Already enabled?
        if (enabled && this._contentScaleFactor == 2) {
            return true;
        }

        // Already diabled?
        if (!enabled && this._contentScaleFactor == 1) {
            return false;
        }

        // setContentScaleFactor is not supported
        if (!this._openGLView.canSetContentScaleFactor()) {
            return false;
        }

        // SD device
        if (this._openGLView.getMainScreenScale() == 1.0) {
            return false;
        }

        var newScale = (enabled) ? 2 : 1;
        this.setContentScaleFactor(newScale);

        this._createStatsLabel();
        return true;
    },

    /**
     * end director
     */
    end:function () {
        this._purgeDirecotorInNextLoop = true;
    },

    /**
     * <p>get the size in pixels of the surface. It could be different than the screen size.<br/>
     *   High-res devices might have a higher surface size than the screen size.<br/>
     *   Only available when compiled using SDK >= 4.0.
     * </p>
     * @return {Number}
     */
    getContentScaleFactor:function () {
        return this._contentScaleFactor;
    },

    /**
     * <p>
     *    This object will be visited after the main scene is visited.<br/>
     *    This object MUST implement the "visit" selector.<br/>
     *    Useful to hook a notification object, like CCNotifications (http://github.com/manucorporat/CCNotifications)
     * </p>
     * @return {cc.Node}
     */
    getNotificationNode:function () {
        return this._notificationNode;
    },

    /**
     * <p>
     *     returns the size of the OpenGL view in points.<br/>
     *     It takes into account any possible rotation (device orientation) of the window
     * </p>
     * @return {cc.Size}
     */
    getWinSize:function () {
        return this._winSizeInPoints;
    },

    /**
     * <p>
     *   returns the size of the OpenGL view in pixels.<br/>
     *   It takes into account any possible rotation (device orientation) of the window.<br/>
     *   On Mac winSize and winSizeInPixels return the same value.
     * </p>
     * @return {cc.Size}
     */
    getWinSizeInPixels:function () {
        return this._winSizeInPixels;
    },

    getZEye:function () {
        return (this._winSizeInPixels.height / 1.1566 / cc.CONTENT_SCALE_FACTOR());
    },

    /**
     * pause director
     */
    pause:function () {
        if (this._paused) {
            return;
        }

        this._oldAnimationInterval = this._animationInterval;
        // when paused, don't consume CPU
        this.setAnimationInterval(1 / 4.0);
        this._paused = true;
    },

    /**
     * <p>
     *     Pops out a scene from the queue.<br/>
     *     This scene will replace the running one.<br/>
     *     The running scene will be deleted. If there are no more scenes in the stack the execution is terminated.<br/>
     *     ONLY call it if there is a running scene.
     * </p>
     */
    popScene:function () {
        cc.Assert(this._runningScene != null, "running scene should not null");

        //this.addRegionToDirtyRegion(cc.rect(0, 0, cc.canvas.width, cc.canvas.height));

        this._scenesStack.pop();
        var c = this._scenesStack.length;

        if (c == 0) {
            this.end();
        }
        else {
            this._sendCleanupToScene = true;
            this._nextScene = this._scenesStack[c - 1];
        }
    },

    /**
     * Removes cached all cocos2d cached data. It will purge the CCTextureCache, CCSpriteFrameCache, CCLabelBMFont cache
     */
    purgeCachedData:function () {
        cc.LabelBMFont.purgeCachedData();
        //cc.TextureCache.getInstance().removeUnusedTextures();
    },

    /**
     * purge Director
     */
    purgeDirector:function () {
        // don't release the event handlers
        // They are needed in case the director is run again
        this._touchDispatcher.removeAllDelegates();

        if (this._runningScene) {
            this._runningScene.onExit();
            this._runningScene.cleanup();
        }

        this._runningScene = null;
        this._nextScene = null;

        // remove all objects, but don't release it.
        // runWithScene might be executed after 'end'.
        this._scenesStack = [];

        this.stopAnimation();

        // purge bitmap cache
        cc.LabelBMFont.purgeCachedData();

        // purge all managers
        cc.AnimationCache.purgeSharedAnimationCache();
        cc.SpriteFrameCache.purgeSharedSpriteFrameCache();
        cc.TextureCache.purgeSharedTextureCache();

        //CCShaderCache::purgeSharedShaderCache();
        //CCFileUtils::purgeFileUtils();
        //CCConfiguration::purgeConfiguration();
        //extension::CCNotificationCenter::purgeNotificationCenter();
        //extension::CCTextureWatcher::purgeTextureWatcher();
        //extension::CCNodeLoaderLibrary::purgeSharedCCNodeLoaderLibrary();
        //cc.UserDefault.purgeSharedUserDefault();
        //ccGLInvalidateStateCache();

        //CHECK_GL_ERROR_DEBUG();

        // OpenGL view
        this._openGLView.end();
        this._openGLView = null;
    },

    /**
     * <p>
     *    Suspends the execution of the running scene, pushing it on the stack of suspended scenes.<br/>
     *    The new scene will be executed.<br/>
     *    Try to avoid big stacks of pushed scenes to reduce memory allocation.<br/>
     *    ONLY call it if there is a running scene.
     * </p>
     * @param {cc.Scene} scene
     */
    pushScene:function (scene) {
        cc.Assert(scene, "the scene should not null");

        //this.addRegionToDirtyRegion(cc.rect(0, 0, cc.canvas.width, cc.canvas.height));

        this._sendCleanupToScene = false;

        this._scenesStack.push(scene);
        this._nextScene = scene;
    },

    /**
     * Replaces the running scene with a new one. The running scene is terminated. ONLY call it if there is a running scene.
     * @param {cc.Scene} scene
     */
    replaceScene:function (scene) {
        cc.Assert(scene != null, "the scene should not be null");

        //this.addRegionToDirtyRegion(cc.rect(0, 0, cc.canvas.width, cc.canvas.height));
        var i = this._scenesStack.length;

        this._sendCleanupToScene = true;
        this._scenesStack[i - 1] = scene;
        this._nextScene = scene;
    },

    /**
     * changes the projection size
     * @param {cc.Size} newWindowSize
     */
    reshapeProjection:function (newWindowSize) {
        if (this._openGLView) {
            this._winSizeInPoints = this._openGLView.getSize();
            this._winSizeInPixels = cc.size(this._winSizeInPoints.width * this._contentScaleFactor,
                this._winSizeInPoints.height * this._contentScaleFactor);

            this.setProjection(this._projection);
        }
    },

    /**
     * resume director
     */
    resume:function () {
        if (!this._paused) {
            return;
        }
        //this.addRegionToDirtyRegion(cc.rect(0, 0, cc.canvas.width, cc.canvas.height));

        this.setAnimationInterval(this._oldAnimationInterval);
        this._lastUpdate = cc.Time.gettimeofdayCocos2d();
        if (!this._lastUpdate) {
            cc.log("cocos2d: Director: Error in gettimeofday");
        }

        this._paused = false;
        this._deltaTime = 0;
    },

    /**
     * <p>
     *    Enters the Director's main loop with the given Scene.<br/>
     *    Call it to run only your FIRST scene.<br/>
     *    Don't call it if there is already a running scene.
     * </p>
     * @param {cc.Scene} scene
     */
    runWithScene:function (scene) {
        cc.Assert(scene != null, "running scene should not be null");
        cc.Assert(this._runningScene == null, "_runningScene should be null");

        //this.addRegionToDirtyRegion(cc.rect(0, 0, cc.canvas.width, cc.canvas.height));

        this.pushScene(scene);
        this.startAnimation();
    },

    /**
     * enables/disables OpenGL alpha blending
     * @param {Boolean} on
     */
    setAlphaBlending:function (on) {
        if (on) {
            //TODO OpenGL
            //ccGLEnable(CC_GL_BLEND);
            //ccGLBlendFunc(CC_BLEND_SRC, CC_BLEND_DST);
        }
        else {
            //glDisable(GL_BLEND);
        }
        //CHECK_GL_ERROR_DEBUG();
    },

    /**
     * <p>
     *   The size in pixels of the surface. It could be different than the screen size.<br/>
     *   High-res devices might have a higher surface size than the screen size.<br/>
     *   Only available when compiled using SDK >= 4.0.
     * </p>
     * @param {Number} scaleFactor
     */
    setContentScaleFactor:function (scaleFactor) {
        if (scaleFactor != this._contentScaleFactor) {
            this._contentScaleFactor = scaleFactor;
            this._winSizeInPixels = cc.size(this._winSizeInPoints.width * scaleFactor, this._winSizeInPoints.height * scaleFactor);

            if (this._openGLView) {
                this.updateContentScaleFactor();
            }

            // update projection
            this.setProjection(this._projection);
        }
    },

    /**
     * enables/disables OpenGL depth test
     * @param {Boolean} on
     */
    setDepthTest:function (on) {
        if (on) {
            /*TODO OpenGL Stuff
             ccglClearDepth(1.0f);
             glEnable(GL_DEPTH_TEST);
             glDepthFunc(GL_LEQUAL);
             //        glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);
             }
             else
             {
             glDisable(GL_DEPTH_TEST);*/
        }
        //CHECK_GL_ERROR_DEBUG();
    },

    /**
     * sets the OpenGL default values
     */
    setGLDefaultValues:function () {
        // This method SHOULD be called only after openGLView_ was initialized
        cc.Assert(this._openGLView, "opengl view should not be null");

        this.setAlphaBlending(true);
        this.setDepthTest(true);
        this.setProjection(this._projection);

        // set other opengl default values
        //TODO OpenGl
        //glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    },

    /**
     * set next delta time is zero
     * @param {Boolean} nextDeltaTimeZero
     */
    setNextDeltaTimeZero:function (nextDeltaTimeZero) {
        this._nextDeltaTimeZero = nextDeltaTimeZero;
    },

    /**
     * set next scene
     */
    setNextScene:function () {
        var runningIsTransition = this._runningScene ? this._runningScene instanceof cc.TransitionScene : false;

        var newIsTransition = this._nextScene ? this._nextScene instanceof cc.TransitionScene : false;

        // If it is not a transition, call onExit/cleanup
        if (!newIsTransition) {
            if (this._runningScene) {
                this._runningScene.onExit();
            }

            // issue #709. the root node (scene) should receive the cleanup message too
            // otherwise it might be leaked.
            if (this._sendCleanupToScene && this._runningScene) {
                this._runningScene.cleanup();
            }
        }

        this._runningScene = this._nextScene;

        this._nextScene = null;
        if ((!runningIsTransition) && (this._runningScene != null)) {
            this._runningScene.onEnter();
            this._runningScene.onEnterTransitionDidFinish();
        }
    },

    /**
     * set Notification Node
     * @param {cc.Node} node
     */
    setNotificationNode:function (node) {
        this._notificationNode = node;
    },

    /**
     * Set the CCEGLView, where everything is rendered
     * @param {*} openGLView
     */
    setOpenGLView:function (openGLView) {
        cc.Assert(openGLView, "opengl view should not be null");

        if (this._openGLView != openGLView) {
            // because EAGLView is not kind of CCObject
            delete this._openGLView; // [openGLView_ release]
            this._openGLView = openGLView;

            // set size
            this._winSizeInPoints = this._openGLView.getSize();
            this._winSizeInPixels = cc.size(this._winSizeInPoints.width * this._contentScaleFactor, this._winSizeInPoints.height * this._contentScaleFactor);

            this._createStatsLabel();

            if (this._openGLView) {
                this.setGLDefaultValues();
            }

            //CHECK_GL_ERROR_DEBUG();

            if (this._contentScaleFactor != 1) {
                this.updateContentScaleFactor();
            }

            this._openGLView.setTouchDelegate(this._touchDispatcher);
            this._touchDispatcher.setDispatchEvents(true);
        }
    },

    /**
     * Sets an OpenGL projection
     * @param {Number} projection
     */
    setProjection:function (projection) {
        var size = this._winSizeInPixels;
        var sizePoint = this._winSizeInPoints;

        if (this._openGLView) {
            this._openGLView.setViewPortInPoints(0, 0, sizePoint.width, sizePoint.height);
        }

        switch (projection) {
            case cc.DIRECTOR_PROJECTION_2D:
                //TODO OpenGL
                /* kmGLMatrixMode(KM_GL_PROJECTION);
                 kmGLLoadIdentity();
                 kmMat4 orthoMatrix;
                 kmMat4OrthographicProjection(&orthoMatrix, 0, size.width / CC_CONTENT_SCALE_FACTOR(), 0, size.height / CC_CONTENT_SCALE_FACTOR(), -1024, 1024 );
                 kmGLMultMatrix(&orthoMatrix);
                 kmGLMatrixMode(KM_GL_MODELVIEW);
                 kmGLLoadIdentity();*/
                break;
            case cc.DIRECTOR_PROJECTION_3D:
                //TODO OpenGl
                /* float zeye = this->getZEye();

                 kmMat4 matrixPerspective, matrixLookup;

                 kmGLMatrixMode(KM_GL_PROJECTION);
                 kmGLLoadIdentity();

                 // issue #1334
                 kmMat4PerspectiveProjection( &matrixPerspective, 60, (GLfloat)size.width/size.height, 0.1f, zeye*2);
                 // kmMat4PerspectiveProjection( &matrixPerspective, 60, (GLfloat)size.width/size.height, 0.1f, 1500);

                 kmGLMultMatrix(&matrixPerspective);

                 kmGLMatrixMode(KM_GL_MODELVIEW);
                 kmGLLoadIdentity();
                 kmVec3 eye, center, up;
                 kmVec3Fill( &eye, sizePoint.width/2, sizePoint.height/2, zeye );
                 kmVec3Fill( &center, sizePoint.width/2, sizePoint.height/2, 0.0f );
                 kmVec3Fill( &up, 0.0f, 1.0f, 0.0f);
                 kmMat4LookAt(&matrixLookup, &eye, &center, &up);
                 kmGLMultMatrix(&matrixLookup);*/
                break;
            case cc.DIRECTOR_PROJECTION_CUSTOM:
                if (this._projectionDelegate) {
                    this._projectionDelegate.updateProjection();
                }
                break;

            default:
                cc.log("cocos2d: Director: unrecognized projection");
                break;
        }

        this._projection = projection;
        //ccSetProjectionMatrixDirty();
    },

    /**
     * shows the FPS in the screen
     */
    _showStats:function () {
        this._frames++;
        this._accumDt += this._deltaTime;
        if (this._displayStats) {
            if (this._FPSLabel && this._SPFLabel && this._drawsLabel) {
                if (this._accumDt > cc.DIRECTOR_FPS_INTERVAL) {
                    this._SPFLabel.setString(this._secondsPerFrame.toFixed(3));

                    this._frameRate = this._frames / this._accumDt;
                    this._frames = 0;
                    this._accumDt = 0;

                    this._szFPS = ('' + this._frameRate.toFixed(1));
                    this._FPSLabel.setString(this._szFPS);

                    this._drawsLabel.setString((0 | cc.g_NumberOfDraws).toString());
                }
                this._FPSLabel.visit();
                this._SPFLabel.visit();
                this._drawsLabel.visit();
            } else {
                this._createStatsLabel();
            }
        }
        cc.g_NumberOfDraws = 0;
    },

    /**
     * update content scale factor
     */
    updateContentScaleFactor:function () {
        // [openGLView responseToSelector:@selector(setContentScaleFactor)]
        if (this._openGLView.canSetContentScaleFactor()) {
            this._openGLView.setContentScaleFactor(this._contentScaleFactor);
            this._isContentScaleSupported = true;
        }
        else {
            cc.log("cocos2d: setContentScaleFactor:'is not supported on this device");
        }
    },

    /**
     * <p>
     *    Whether or not the replaced scene will receive the cleanup message.<br>
     *    If the new scene is pushed, then the old scene won't receive the "cleanup" message.<br/>
     *    If the new scene replaces the old one, the it will receive the "cleanup" message.
     * </p>
     * @return {Boolean}
     */
    isSendCleanupToScene:function () {
        return this._sendCleanupToScene;
    },

    /**
     * Get current running Scene. Director can only run one Scene at the time
     * @return {cc.Scene}
     */
    getRunningScene:function () {
        return this._runningScene;
    },

    /**
     * Get the FPS value
     * @return {Number}
     */
    getAnimationInterval:function () {
        return this._animationInterval;
    },

    /**
     * Whether or not to display the FPS on the bottom-left corner
     * @return {Boolean}
     */
    isDisplayStats:function () {
        return this._displayStats;
    },

    /**
     * Display the FPS on the bottom-left corner
     * @param displayFPS
     */
    setDisplayStats:function (displayStats) {
        this._displayStats = displayStats;
    },

    /**
     * seconds per frame
     */
    getSecondsPerFrame:function () {
        return this._secondsPerFrame;
    },

    /**
     *  Get the CCEGLView, where everything is rendered
     * @return {*}
     */
    getOpenGLView:function () {
        return this._openGLView;
    },

    /**
     * is next delta time zero
     * @return {Boolean}
     */
    isNextDeltaTimeZero:function () {
        return this._nextDeltaTimeZero;
    },

    /**
     * Whether or not the Director is paused
     * @return {Boolean}
     */
    isPaused:function () {
        return this._paused;
    },

    /**
     * How many frames were called since the director started
     * @return {Number}
     */
    getTotalFrames:function () {
        return this._totalFrames;
    },

    /**
     * Sets an OpenGL projection
     * @return {Number}
     */
    getProjection:function () {
        return this._projection;
    },

    /**
     * <p>
     *     Pops out all scenes from the queue until the root scene in the queue. <br/>
     *     This scene will replace the running one.  <br/>
     *     The running scene will be deleted. If there are no more scenes in the stack the execution is terminated. <br/>
     *     ONLY call it if there is a running scene.
     * </p>
     */
    popToRootScene:function () {
        cc.Assert(this._runningScene != null, "A running Scene is needed");
        var c = this._scenesStack.length;

        if (c == 1) {
            this._scenesStack.pop();
            this.end();
        } else {
            while (c > 1) {
                var current = this._scenesStack.pop();
                if (current.isRunning()) {
                    current.onExit();
                }
                current.cleanup();
                c--;
            }
            this._nextScene = this._scenesStack[this._scenesStack.length - 1];
            this._sendCleanupToScene = false;
        }
    },

    setWatcherCallbackFun:function (pSender, func) {
        this._watcherFun = func;
        this._watcherSender = pSender;
    },

    /**
     * (cc.Scheduler associated with this director)
     */
    getScheduler:function () {
        return this._scheduler;
    },

    setScheduler:function (scheduler) {
        if (this._scheduler != scheduler) {
            this._scheduler = scheduler;
        }
    },

    getActionManager:function () {
        return this._actionManager;
    },
    setActionManager:function (actionManager) {
        if (this._actionManager != actionManager) {
            this._actionManager = actionManager;
        }
    },

    getTouchDispatcher:function () {
        return this._touchDispatcher;
    },
    setTouchDispatcher:function (touchDispatcher) {
        if (this._touchDispatcher != touchDispatcher) {
            this._touchDispatcher = touchDispatcher;
        }
    },

    getKeyboardDispatcher:function () {
        return this._keyboardDispatcher;
    },
    setKeyboardDispatcher:function (keyboardDispatcher) {
        this._keyboardDispatcher = keyboardDispatcher;
    },

    getAccelerometer:function () {
        return this._accelerometer;
    },
    setAccelerometer:function (accelerometer) {
        if (this._accelerometer != accelerometer) {
            this._accelerometer = accelerometer;
        }
    },

    _createStatsLabel:function () {
        this._FPSLabel = cc.LabelTTF.create("00.0", "Arial", 18, cc.size(60, 16), cc.TEXT_ALIGNMENT_RIGHT);
        this._SPFLabel = cc.LabelTTF.create("0.000", "Arial", 18, cc.size(60, 16), cc.TEXT_ALIGNMENT_RIGHT);
        this._drawsLabel = cc.LabelTTF.create("000", "Arial", 18, cc.size(60, 16), cc.TEXT_ALIGNMENT_RIGHT);

        this._drawsLabel.setPosition(cc.pAdd(cc.p(20, 48), cc.DIRECTOR_STATS_POSITION));
        this._SPFLabel.setPosition(cc.pAdd(cc.p(20, 30), cc.DIRECTOR_STATS_POSITION));
        this._FPSLabel.setPosition(cc.pAdd(cc.p(20, 10), cc.DIRECTOR_STATS_POSITION));
    },

    _calculateMPF:function () {
        var now = cc.Time.gettimeofdayCocos2d();

        this._secondsPerFrame = (now.tv_sec - this._lastUpdate.tv_sec) + (now.tv_usec - this._lastUpdate.tv_usec) / 1000000.0;
    }
});


/***************************************************
 * implementation of DisplayLinkDirector
 **************************************************/
// should we afford 4 types of director ??
// I think DisplayLinkDirector is enough
// so we now only support DisplayLinkDirector
/**
 * <p>
 *   DisplayLinkDirector is a Director that synchronizes timers with the refresh rate of the display.<br/>
 *   Features and Limitations:<br/>
 *      - Scheduled timers & drawing are synchronizes with the refresh rate of the display<br/>
 *      - Only supports animation intervals of 1/60 1/30 & 1/15<br/>
 * </p>
 * @class
 * @extends cc.Director
 */
cc.DisplayLinkDirector = cc.Director.extend(/** @lends cc.DisplayLinkDirector# */{
    invalid:false,

    /**
     * start Animation
     */
    startAnimation:function () {
        this._lastUpdate = cc.Time.gettimeofdayCocos2d();
        this.invalid = false;
        cc.Application.sharedApplication().setAnimationInterval(this._animationInterval);
    },

    /**
     * main loop of director
     */
    mainLoop:function () {
        if (this._purgeDirecotorInNextLoop) {
            this._purgeDirecotorInNextLoop = false;
            this.purgeDirector();
        }
        else if (!this.invalid) {
            this.drawScene();
        }
    },

    /**
     * stop animation
     */
    stopAnimation:function () {
        this.invalid = true;
    },

    /**
     * set Animation Interval
     * @param {Number} value
     */
    setAnimationInterval:function (value) {
        this._animationInterval = value;
        if (!this.invalid) {
            this.stopAnimation();
            this.startAnimation();
        }
    }
});

cc.s_SharedDirector = null;

cc.firstUseDirector = true;

/**
 * returns a shared instance of the director
 * @function
 * @return {cc.Director}
 */
cc.Director.getInstance = function () {
    if (cc.firstUseDirector) {
        cc.firstUseDirector = false;
        cc.s_SharedDirector = new cc.DisplayLinkDirector();
        cc.s_SharedDirector.init();
    }
    return cc.s_SharedDirector;
};

/**
 * is director first run
 * @type Boolean
 */
cc.firstRun = true;

/**
 * set default fps to 60
 * @type Number
 */
cc.defaultFPS = 60;

/*
 window.onfocus = function () {
 if (!cc.firstRun) {
 cc.Director.getInstance().addRegionToDirtyRegion(cc.rect(0, 0, cc.canvas.width, cc.canvas.height));
 }
 };
 */

/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
var cc = cc = cc || {};


/**
 A CCCamera is used in every CCNode.
 Useful to look at the object from different views.
 The OpenGL gluLookAt() function is used to locate the
 camera.

 If the object is transformed by any of the scale, rotation or
 position attributes, then they will override the camera.

 IMPORTANT: Either your use the camera or the rotation/scale/position properties. You can't use both.
 World coordinates won't work if you use the camera.

 Limitations:

 - Some nodes, like CCParallaxNode, CCParticle uses world node coordinates, and they won't work properly if you move them (or any of their ancestors)
 using the camera.

 - It doesn't work on batched nodes like CCSprite objects when they are parented to a CCSpriteBatchNode object.

 - It is recommended to use it ONLY if you are going to create 3D effects. For 2D effecs, use the action CCFollow or position/scale/rotate.

 */
cc.Camera = cc.Class.extend({
    /*protected:*/
    _eyeX:null,
    _eyeY:null,
    _eyeZ:null,
    _centerX:null,
    _centerY:null,
    _centerZ:null,
    _upX:null,
    _upY:null,
    _upZ:null,
    _dirty:null,

    /*public:*/
    ctor:function () {
        this.restore();
    },
    description:function () {
        return "<CCCamera | center =(" + this._centerX + "," + this._centerY + "," + this._centerZ + ")>";
    },
    /** sets the dirty value */
    setDirty:function (value) {
        this._dirty = value;
    },
    /** get the dirty value */
    getDirty:function () {
        return this._dirty;
    },

    /** sets the camera in the default position */
    restore:function () {
        this._eyeX = this._eyeY = 0.0;
        this._eyeZ = cc.Camera.getZEye();

        this._centerX = this._centerY = this._centerZ = 0.0;

        this._upX = 0.0;
        this._upY = 1.0;
        this._upZ = 0.0;

        this._dirty = false;
    },
    /** Sets the camera using gluLookAt using its eye, center and up_vector */
    locate:function () {
        if (this._dirty) {
            //TODO gl
            //gluLookAt(this._eyeX, this._eyeY, this._eyeZ,this._centerX, this._centerY, this._centerZ,this._upX, this._upY, this._upZ);
        }

    },
    /** sets the eye values in points */
    setEyeXYZ:function (eyeX, eyeY, eyeZ) {
        this._eyeX = eyeX * cc.CONTENT_SCALE_FACTOR;
        this._eyeY = eyeY * cc.CONTENT_SCALE_FACTOR;
        this._eyeZ = eyeZ * cc.CONTENT_SCALE_FACTOR;

        this._dirty = true;
    },
    /** sets the center values in points */
    setCenterXYZ:function (centerX, centerY, fenterZ) {
        this._centerX = centerX * cc.CONTENT_SCALE_FACTOR;
        this._centerY = centerY * cc.CONTENT_SCALE_FACTOR;
        this._centerZ = fenterZ * cc.CONTENT_SCALE_FACTOR;

        this._dirty = true;
    },
    /** sets the up values */
    setUpXYZ:function (upX, upY, upZ) {
        this._upX = upX;
        this._upY = upY;
        this._upZ = upZ;

        this._dirty = true;
    },

    /** get the eye vector values in points */
    getEyeXYZ:function (eyeX, eyeY, eyeZ) {
        eyeX = this._eyeX / cc.CONTENT_SCALE_FACTOR;
        eyeY = this._eyeY / cc.CONTENT_SCALE_FACTOR;
        eyeZ = this._eyeZ / cc.CONTENT_SCALE_FACTOR;
    },
    /** get the center vector values int points */
    getCenterXYZ:function (centerX, centerY, centerZ) {
        centerX = this._centerX / cc.CONTENT_SCALE_FACTOR;
        centerY = this._centerY / cc.CONTENT_SCALE_FACTOR;
        centerZ = this._centerZ / cc.CONTENT_SCALE_FACTOR;
    },
    /** get the up vector values */
    getUpXYZ:function (upX, upY, upZ) {
        upX = this._upX;
        upY = this._upY;
        upZ = this._upZ;
    },

    /*private:*/
    _DISALLOW_COPY_AND_ASSIGN:function (CCCamera) {

    }
});
/** returns the Z eye */
cc.Camera.getZEye = function () {
    return cc.FLT_EPSILON;
};

//cc.CONTENT_SCALE_FACTOR = cc.Director.getInstance().getContentScaleFactor();
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * Priority level reserved for system services.
 * @constant
 * @type Number
 */
cc.PRIORITY_SYSTEM = (-2147483647 - 1);

/**
 * Minimum priority level for user scheduling.
 * @constant
 * @type Number
 */
cc.PRIORITY_NON_SYSTEM = cc.PRIORITY_SYSTEM + 1;

/**
 * Verify Array's Type
 * @param {Array} arr
 * @param {function} type
 * @return {Boolean}
 * @function
 */
cc.ArrayVerifyType = function (arr, type) {
    if (arr && arr.length > 0) {
        for (var i = 0; i < arr.length; i++) {
            if (!(arr[i] instanceof  type)) {
                cc.log("element type is wrong!");
                return false;
            }
        }
    }
    return true;
};

/**
 * Removes object at specified index and pushes back all subsequent objects.Behaviour undefined if index outside [0, num-1].
 * @function
 * @param {Array} arr Source Array
 * @param {Number} index index of remove object
 */
cc.ArrayRemoveObjectAtIndex = function (arr, index) {
    arr.splice(index, 1);
};

/**
 * Searches for the first occurance of object and removes it. If object is not found the function has no effect.
 * @function
 * @param {Array} arr Source Array
 * @param {*} delObj  remove object
 */
cc.ArrayRemoveObject = function (arr, delObj) {
    for (var i = 0; i < arr.length; i++) {
        if (arr[i] == delObj) {
            arr.splice(i, 1);
        }
    }
};

/**
 * Removes from arr all values in minusArr. For each Value in minusArr, the first matching instance in arr will be removed.
 * @function
 * @param {Array} arr Source Array
 * @param {Array} minusArr minus Array
 */
cc.ArrayRemoveArray = function (arr, minusArr) {
    for (var i = 0; i < minusArr.length; i++) {
        cc.ArrayRemoveObject(arr, minusArr[i]);
    }
};

/**
 * Returns index of first occurence of value, -1 if value not found.
 * @function
 * @param {Array} arr Source Array
 * @param {*} value find value
 * @return {Number} index of first occurence of value
 */
cc.ArrayGetIndexOfValue = function (arr, value) {
    for (var i = 0; i < arr.length; i++) {
        if (arr[i] == value) {
            return i;
        }
    }
    return -1;
};

/**
 * append an object to array
 * @function
 * @param {Array} arr
 * @param {*} addObj
 */
cc.ArrayAppendObject = function (arr, addObj) {
    arr.push(addObj);
};

/**
 * Inserts an object at index
 * @function
 * @param {Array} arr
 * @param {*} addObj
 * @param {Number} index
 * @return {Array}
 */
cc.ArrayAppendObjectToIndex = function (arr, addObj, index) {
    var part1 = arr.slice(0, index);
    var part2 = arr.slice(index);
    part1.push(addObj);
    arr = (part1.concat(part2));
    return arr;
};

/**
 * Returns index of first occurence of object, -1 if value not found.
 * @function
 * @param {Array} arr Source Array
 * @param {*} findObj find object
 * @return {Number} index of first occurence of value
 */
cc.ArrayGetIndexOfObject = function (arr, findObj) {
    for (var i = 0; i < arr.length; i++) {
        if (arr[i] == findObj)
            return i;
    }
    return -1;
};

/**
 * Returns a Boolean value that indicates whether value is present in the array.
 * @function
 * @param {Array} arr
 * @param {*} findObj
 * @return {Boolean}
 */
cc.ArrayContainsObject = function (arr, findObj) {
    return cc.ArrayGetIndexOfObject(arr, findObj) != -1;
};

/**
 * find object from array by target
 * @param {Array} arr source array
 * @param {cc.ListEntry|cc.HashUpdateEntry|cc.HashSelectorEntry} findInt find target
 * @return {cc.ListEntry|cc.HashUpdateEntry|cc.HashSelectorEntry}
 */
cc.HASH_FIND_INT = function (arr, findInt) {
    if (arr == null) {
        return null;
    }
    for (var i = 0; i < arr.length; i++) {
        if (arr[i].target == findInt) {
            return arr[i];
        }
    }
    return null;
};

//data structures
/**
 * A list double-linked list used for "updates with priority"
 * @Class
 * @Construct
 * @param {cc.ListEntry} prev
 * @param {cc.ListEntry} next
 * @param {cc.Class} target not retained (retained by hashUpdateEntry)
 * @param {Number} priority
 * @param {Boolean} paused
 * @param {Boolean} markedForDeletion selector will no longer be called and entry will be removed at end of the next tick
 */
cc.ListEntry = function (prev, next, target, priority, paused, markedForDeletion) {
    this.prev = prev;
    this.next = next;
    this.target = target;
    this.priority = priority;
    this.paused = paused;
    this.makedForDeletion = markedForDeletion;
};

/**
 *  a update entry list
 * @Class
 * @Construct
 * @param {cc.ListEntry} list Which list does it belong to ?
 * @param {cc.ListEntry} entry entry in the list
 * @param {cc.Class} target hash key (retained)
 * @param {Array} hh
 */
cc.HashUpdateEntry = function (list, entry, target, hh) {
    this.list = list;
    this.entry = entry;
    this.target = target;
    this.hh = hh;
};

//
/**
 * Hash Element used for "selectors with interval"
 * @Class
 * @Construct
 * @param {Array} timers
 * @param {cc.Class} target  hash key (retained)
 * @param {Number} timerIndex
 * @param {cc.Timer} currentTimer
 * @param {Boolean} currentTimerSalvaged
 * @param {Boolean} paused
 * @param {Array} hh
 */
cc.HashSelectorEntry = function (timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused, hh) {
    this.timers = timers;
    this.target = target;
    this.timerIndex = timerIndex;
    this.currentTimer = currentTimer;
    this.currentTimerSalvaged = currentTimerSalvaged;
    this.paused = paused;
    this.hh = hh;
};

/**
 * Light weight timer
 * @class
 * @extends cc.Class
 */
cc.Timer = cc.Class.extend(/** @lends cc.Timer# */{
    _interval:0.0,
    _selector:"",

    _target:null,
    _elapsed:0.0,

    _runForever:false,
    _useDelay:false,
    _timesExecuted:0,
    _repeat:0, //0 = once, 1 is 2 x executed
    _delay:0,

    /**
     * cc.Timer's Constructor
     * Constructor
     */
    ctor:function () {
    },

    /**
     * returns interval of timer
     * @return {Number}
     */
    getInterval:function () {
        return this._interval;
    },

    /**
     * Initializes a timer with a target, a selector and an interval in seconds.
     * @param {cc.Class} target target
     * @param {String|function} selector Selector
     * @param {Number} seconds second
     * @return {Boolean} <tt>true</tt> if inintialized
     * * */
    initWithTarget:function (target, selector, seconds, repeat, delay) {
        try {
            this._target = target;
            this._selector = selector;
            this._elapsed = -1;
            this._interval = seconds || 0;
            this._delay = delay || 0;
            this._useDelay = this._delay > 0;
            this._repeat = (repeat == null) ? cc.REPEAT_FOREVER : repeat;
            this._runForever = (this._repeat == cc.REPEAT_FOREVER);
            return true;
        } catch (e) {
            return false;
        }
    },

    /**
     * triggers the timer
     * @param {Number} dt delta time
     */
    update:function (dt) {
        if (this._elapsed == -1) {
            this._elapsed = 0;
            this._timesExecuted = 0;
        } else {
            if (this._runForever && !this._useDelay) {
                //standard timer usage
                this._elapsed += dt;

                if (this._elapsed >= this._interval) {
                    if (this._selector) {
                        if (typeof(this._selector) == "string") {
                            this._target[this._selector](this._elapsed);
                        } else{ // if (typeof(this._selector) == "function") {
                            this._selector.call(this._target, this._elapsed);
                        }
                    }
                    this._elapsed = 0;
                }
            } else {
                //advanced usage
                this._elapsed += dt;
                if (this._useDelay) {
                    if (this._elapsed >= this._delay) {
                        if (this._target && this._selector) {
                            if (typeof(this._selector) == "string") {
                                this._target[this._selector](this._elapsed);
                            } else{ // if (typeof(this._selector) == "function") {
                                this._selector.call(this._target, this._elapsed);
                            }
                        }
                        this._elapsed = this._elapsed - this._delay;
                        this._timesExecuted += 1;
                        this._useDelay = false;
                    }
                } else {
                    if (this._elapsed >= this._interval) {
                        if (this._target && this._selector) {
                            if (typeof(this._selector) == "string") {
                                this._target[this._selector](this._elapsed);
                            } else{  //if (typeof(this._selector) == "function") {
                                this._selector.call(this._target, this._elapsed);
                            }
                        }
                        this._elapsed = 0;
                        this._timesExecuted += 1;
                    }
                }

                if (this._timesExecuted > this._repeat) {
                    cc.Director.getInstance().getScheduler().unscheduleSelector(this._selector, this._target);
                }
            }
        }
    }
});

/**
 * Allocates a timer with a target, a selector and an interval in seconds.
 * @function
 * @param {cc.Class} target
 * @param {String|function} selector Selector
 * @param {Number} seconds
 * @return {cc.Timer} a cc.Timer instance
 * */
cc.Timer.timerWithTarget = function (target, selector, seconds) {
    if (arguments < 2)
        throw new Error("timerWithTarget'argument can't is null");

    var timer = new cc.Timer();
    if (arguments.length == 2) {
        timer.initWithTarget(target, selector, 0, cc.REPEAT_FOREVER, 0);
    } else {
        timer.initWithTarget(target, selector, seconds, cc.REPEAT_FOREVER, 0);
    }
    return timer;
};

cc._sharedScheduler = null;
/**
 * <p>
 *    Scheduler is responsible of triggering the scheduled callbacks.<br/>
 *    You should not use NSTimer. Instead use this class.<br/>
 *    <br/>
 *    There are 2 different types of callbacks (selectors):<br/>
 *       - update selector: the 'update' selector will be called every frame. You can customize the priority.<br/>
 *       - custom selector: A custom selector will be called every frame, or with a custom interval of time<br/>
 *       <br/>
 *    The 'custom selectors' should be avoided when possible. It is faster, and consumes less memory to use the 'update selector'. *
 * </p>
 * @class
 * @extends cc.Class
 *
 * @example
 * //register a schedule to scheduler
 * cc.Director.getInstance().getScheduler().scheduleSelector(selector, this, interval, !this._isRunning);
 */
cc.Scheduler = cc.Class.extend(/** @lends cc.Scheduler# */{
    _timeScale:1.0,
    _updatesNegList:null, // list of priority < 0
    _updates0List:null, // list priority == 0
    _updatesPosList:null, // list priority > 0
    _hashForUpdates:null, // hash used to fetch quickly the list entries for pause,delete,etc

    _hashForSelectors:null, //Used for "selectors with interval"

    _currentTarget:null,
    _currentTargetSalvaged:false,
    _updateHashLocked:false, //If true unschedule will not remove anything from a hash. Elements will only be marked for deletion.

    /**
     * Constructor
     */
    ctor:function () {
        this._timeScale = 1.0;

        this._updatesNegList = [];
        this._updates0List = [];
        this._updatesPosList = [];

        this._hashForUpdates = [];
        this._hashForSelectors = [];

        this._currentTarget = null;
        this._currentTargetSalvaged = false;
        this._updateHashLocked = false;
    },

    //-----------------------private method----------------------
    _removeHashElement:function (element) {
        element.Timer = null;
        element.target = null;
        cc.ArrayRemoveObject(this._hashForSelectors, element);
        element = null;
    },

    /**
     * find Object from Array
     * @private
     * @param {Array} Source Array
     * @param {cc.Class} destination object
     * @return {cc.ListEntry} object if finded, or return null
     */
    _findElementFromArray:function (array, target) {
        for (var i = 0; i < array.length; i++) {
            if (array[i].target == target) {
                return array[i];
            }
        }
        return null;
    },

    _removeUpdateFromHash:function (entry) {
        var element = this._findElementFromArray(this._hashForUpdates, entry.target);
        if (element) {
            //list entry
            cc.ArrayRemoveObject(element.list, element.entry);
            element.entry = null;

            //hash entry
            element.target = null;
            cc.ArrayRemoveObject(this._hashForUpdates, element);
        }
    },

    _priorityIn:function (ppList, target, priority, paused) {
        var listElement = new cc.ListEntry(null, null, target, priority, paused, false);

        // empey list ?
        if (!ppList) {
            ppList = [];
            ppList.push(listElement);
        } else {
            var added = false;
            for (var i = 0; i < ppList.length; i++) {
                if (priority < ppList[i].priority) {
                    ppList = cc.ArrayAppendObjectToIndex(ppList, listElement, i);
                    added = true;
                    break;
                }
            }

            // Not added? priority has the higher value. Append it.
            if (!added) {
                ppList.push(listElement);
            }
        }

        //update hash entry for quick access
        var hashElement = new cc.HashUpdateEntry(ppList, listElement, target, null);
        this._hashForUpdates.push(hashElement);
    },

    _appendIn:function (ppList, target, paused) {
        var listElement = new cc.ListEntry(null, null, target, 0, paused, false);
        ppList.push(listElement);

        //update hash entry for quicker access
        var hashElement = new cc.HashUpdateEntry(ppList, listElement, target, null);
        this._hashForUpdates.push(hashElement);
    },

    //-----------------------public method-------------------------
    /**
     * <p>
     *    Modifies the time of all scheduled callbacks.<br/>
     *    You can use this property to create a 'slow motion' or 'fast forward' effect.<br/>
     *    Default is 1.0. To create a 'slow motion' effect, use values below 1.0.<br/>
     *    To create a 'fast forward' effect, use values higher than 1.0.<br/>
     *    @warning It will affect EVERY scheduled selector / action.
     * </p>
     * @param {Number} timeScale
     */
    setTimeScale:function (timeScale) {
        this._timeScale = timeScale;
    },

    /**
     * returns time scale of scheduler
     * @return {Number}
     */
    getTimeScale:function () {
        return this._timeScale;
    },

    /**
     * 'update' the scheduler. (You should NEVER call this method, unless you know what you are doing.)
     * @param {Number} dt delta time
     */
    update:function (dt) {
        this._updateHashLocked = true;

        if (this._timeScale != 1.0) {
            dt *= this._timeScale;
        }

        //Iterate all over the Updates selectors
        var tmpEntry;
        var i;
        for (i = 0; i < this._updatesNegList.length; i++) {
            tmpEntry = this._updatesNegList[i];
            if ((!tmpEntry.paused) && (!tmpEntry.makedForDeletion)) {
                tmpEntry.target.update(dt);
            }
        }

        // updates with priority == 0
        for (i = 0; i < this._updates0List.length; i++) {
            tmpEntry = this._updates0List[i];
            if ((!tmpEntry.paused) && (!tmpEntry.makedForDeletion)) {
                tmpEntry.target.update(dt);
            }
        }

        // updates with priority > 0
        for (i = 0; i < this._updatesPosList.length; i++) {
            tmpEntry = this._updatesPosList[i];
            if ((!tmpEntry.paused) && (!tmpEntry.makedForDeletion)) {
                tmpEntry.target.update(dt);
            }
        }

        //Interate all over the custom selectors
        var elt;
        for (i = 0; i < this._hashForSelectors.length; i++) {
            this._currentTarget = this._hashForSelectors[i];
            elt = this._currentTarget;
            this._currentTargetSalvaged = false;

            if (!this._currentTarget.paused) {
                // The 'timers' array may change while inside this loop
                for (elt.timerIndex = 0; elt.timerIndex < elt.timers.length; elt.timerIndex++) {
                    elt.currentTimer = elt.timers[elt.timerIndex];
                    elt.currentTimerSalvaged = false;

                    elt.currentTimer.update(dt);
                    elt.currentTimer = null;
                }
            }

            if ((this._currentTargetSalvaged) && (this._currentTarget.timers.length == 0)) {
                this._removeHashElement(this._currentTarget);
            }
        }

        //delete all updates that are marked for deletion
        // updates with priority < 0
        for (i = 0; i < this._updatesNegList.length; i++) {
            if (this._updatesNegList[i].makedForDeletion) {
                this._removeUpdateFromHash(tmpEntry);
            }
        }

        // updates with priority == 0
        for (i = 0; i < this._updates0List.length; i++) {
            if (this._updates0List[i].makedForDeletion) {
                this._removeUpdateFromHash(tmpEntry);
            }
        }

        // updates with priority > 0
        for (i = 0; i < this._updatesPosList.length; i++) {
            if (this._updatesPosList[i].makedForDeletion) {
                this._removeUpdateFromHash(tmpEntry);
            }
        }

        this._updateHashLocked = false;
        this._currentTarget = null;
    },

    /**
     * <p>
     *   The scheduled method will be called every 'interval' seconds.</br>
     *   If paused is YES, then it won't be called until it is resumed.<br/>
     *   If 'interval' is 0, it will be called every frame, but if so, it recommened to use 'scheduleUpdateForTarget:' instead.<br/>
     *   If the selector is already scheduled, then only the interval parameter will be updated without re-scheduling it again.<br/>
     *   repeat let the action be repeated repeat + 1 times, use kCCRepeatForever to let the action run continiously<br/>
     *   delay is the amount of time the action will wait before it'll start<br/>
     * </p>
     * @param {function} selector
     * @param {cc.Class} target
     * @param {Number} interval
     * @param {Boolean} paused
     * @example
     * //register a schedule to scheduler
     * cc.Director.getInstance().getScheduler().scheduleSelector(selector, this, interval, !this._isRunning);
     */
    scheduleSelector:function (selector, target, interval, paused, repeat, delay) {
        cc.Assert(selector, "scheduler.scheduleSelector() Argument selector must be non-NULL");
        cc.Assert(target, "scheduler.scheduleSelector() Argument target must be non-NULL");

        repeat = (repeat == null) ? cc.REPEAT_FOREVER : repeat;
        delay = delay || 0;

        var element = cc.HASH_FIND_INT(this._hashForSelectors, target);

        if (!element) {
            // Is this the 1st element ? Then set the pause level to all the selectors of this target
            element = new cc.HashSelectorEntry(null, target, 0, null, null, paused, null);
            this._hashForSelectors.push(element);
        } else {
            cc.Assert(element.paused == paused, "Sheduler.scheduleSelector()");
        }

        var timer;
        if (element.timers == null) {
            element.timers = [];
        } else {
            for (var i = 0; i < element.timers.length; i++) {
                timer = element.timers[i];
                if (selector == timer._selector) {
                    cc.log("CCSheduler#scheduleSelector. Selector already scheduled. Updating interval from:"
                        + timer.getInterval().toFixed(4) + " to " + interval.toFixed(4));
                    timer._interval = interval;
                    return;
                }
            }
        }

        timer = new cc.Timer();
        timer.initWithTarget(target, selector, interval, repeat, delay);
        element.timers.push(timer);
    },

    /**
     * <p>
     *    Schedules the 'update' selector for a given target with a given priority.<br/>
     *    The 'update' selector will be called every frame.<br/>
     *    The lower the priority, the earlier it is called.
     * </p>
     * @param {cc.Class} target
     * @param {Number} priority
     * @param {Boolean} paused
     * @example
     * //register this object to scheduler
     * cc.Director.getInstance().getScheduler().scheduleUpdateForTarget(this, priority, !this._isRunning);
     */
    scheduleUpdateForTarget:function (target, priority, paused) {
        var hashElement = cc.HASH_FIND_INT(this._hashForUpdates, target);

        if (hashElement) {
            if (cc.COCOS2D_DEBUG >= 1) {
                cc.Assert(hashElement.entry.markedForDeletion, "");
            }
            // TODO: check if priority has changed!
            hashElement.entry.markedForDeletion = false;
            return;
        }

        // most of the updates are going to be 0, that's way there
        // is an special list for updates with priority 0
        if (priority == 0) {
            this._appendIn(this._updates0List, target, paused);
        } else if (priority < 0) {
            this._priorityIn(this._updatesNegList, target, priority, paused);
        } else {
            // priority > 0
            this._priorityIn(this._updatesPosList, target, priority, paused);
        }
    },

    /**
     * <p>
     *   Unschedule a selector for a given target.<br/>
     *   If you want to unschedule the "update", use unscheudleUpdateForTarget.
     * </p>
     * @param {function} selector
     * @param {cc.Class} target
     * @example
     * //unschedule a selector of target
     * cc.Director.getInstance().getScheduler().unscheduleSelector(selector, this);
     */
    unscheduleSelector:function (selector, target) {
        // explicity handle nil arguments when removing an object
        if ((target == null) || (selector == null)) {
            return;
        }

        var element = cc.HASH_FIND_INT(this._hashForSelectors, target);
        if (element != null) {
            for (var i = 0; i < element.timers.length; i++) {
                var timer = element.timers[i];
                if (selector == timer._selector) {
                    if ((timer == element.currentTimer) && (!element.currentTimerSalvaged)) {
                        element.currentTimerSalvaged = true;
                    }
                    cc.ArrayRemoveObjectAtIndex(element.timers, i);
                    //update timerIndex in case we are in tick;, looping over the actions
                    if (element.timerIndex >= i) {
                        element.timerIndex--;
                    }

                    if (element.timers.length == 0) {
                        if (this._currentTarget == element) {
                            this._currentTargetSalvaged = true;
                        } else {

                            this._removeHashElement(element);
                        }
                    }
                    return;
                }
            }
        }
    },

    /**
     * Unschedules the update selector for a given target
     * @param {cc.Class} target
     * @example
     * //unschedules the "update" method.
     * cc.Director.getInstance().getScheduler().unscheduleUpdateForTarget(this);
     */
    unscheduleUpdateForTarget:function (target) {
        if (target == null) {
            return;
        }

        var element = cc.HASH_FIND_INT(this._hashForUpdates, target);
        if (element != null) {
            if (this._updateHashLocked) {
                element.entry.markedForDeletion = true;
            } else {
                this._removeUpdateFromHash(element.entry);
            }
        }
    },

    /**
     * Unschedules all selectors for a given target. This also includes the "update" selector.
     * @param {cc.Class} target
     */
    unscheduleAllSelectorsForTarget:function (target) {
        //explicit NULL handling
        if (target == null) {
            return;
        }

        var element = cc.HASH_FIND_INT(this._hashForSelectors, target);
        if (element) {
            if ((!element.currentTimerSalvaged) && (cc.ArrayContainsObject(element.timers, element.currentTimer))) {
                element.currentTimerSalvaged = true;
            }
            element.timers.length = 0;

            if (this._currentTarget == element) {
                this._currentTargetSalvaged = true;
            } else {
                this._removeHashElement(element);
            }
        }
        // update selector
        this.unscheduleUpdateForTarget(target);
    },

    /**
     *  <p>
     *      Unschedules all selectors from all targets. <br/>
     *      You should NEVER call this method, unless you know what you are doing.
     *  </p>
     */
    unscheduleAllSelectors:function () {
        this.unscheduleAllSelectorsWithMinPriority(cc.PRIORITY_SYSTEM);
    },

    /**
     * <p>
     *    Unschedules all selectors from all targets with a minimum priority.<br/>
     *    You should only call this with kCCPriorityNonSystemMin or higher.
     * </p>
     * @param {Number} minPriority
     */
    unscheduleAllSelectorsWithMinPriority:function (minPriority) {
        // Custom Selectors
        var i;
        for (i = 0; i < this._hashForSelectors.length; i++) {
            // element may be removed in unscheduleAllSelectorsForTarget
            this.unscheduleAllSelectorsForTarget(this._hashForSelectors[i].target);
        }

        //updates selectors
        if (minPriority < 0) {
            for (i = 0; i < this._updatesNegList.length; i++) {
                this.unscheduleUpdateForTarget(this._updatesNegList[i].target);
            }
        }

        if (minPriority <= 0) {
            for (i = 0; i < this._updates0List.length; i++) {
                this.unscheduleUpdateForTarget(this._updates0List[i].target);
            }
        }

        for (i = 0; i < this._updatesPosList.length; i++) {
            if (this._updatesPosList[i].priority >= minPriority) {
                this.unscheduleUpdateForTarget(this._updatesPosList[i].target);
            }
        }
    },

    /**
     * <p>
     *  Pause all selectors from all targets.<br/>
     *  You should NEVER call this method, unless you know what you are doing.
     * </p>
     */
    pauseAllTargets:function () {
        return this.pauseAllTargetsWithMinPriority(cc.PRIORITY_SYSTEM);
    },

    /**
     * Pause all selectors from all targets with a minimum priority. <br/>
     * You should only call this with kCCPriorityNonSystemMin or higher.
     * @param minPriority
     */
    pauseAllTargetsWithMinPriority:function (minPriority) {
        var idsWithSelectors = [];

        var i, element;
        // Custom Selectors
        for (i = 0; i < this._hashForSelectors.length; i++) {
            element = this._hashForSelectors[i];
            if (element) {
                element.paused = true;
                idsWithSelectors.push(element.target);
            }
        }

        // Updates selectors
        if (minPriority < 0) {
            for (i = 0; i < this._updatesNegList.length; i++) {
                element = this._updatesNegList[i];
                if (element) {
                    element.paused = true;
                    idsWithSelectors.push(element.target);
                }
            }
        }

        if (minPriority <= 0) {
            for (i = 0; i < this._updates0List.length; i++) {
                element = this._updates0List[i];
                if (element) {
                    element.paused = true;
                    idsWithSelectors.push(element.target);
                }
            }
        }

        for (i = 0; i < this._updatesPosList.length; i++) {
            element = this._updatesPosList[i];
            if (element) {
                element.paused = true;
                idsWithSelectors.push(element.target);
            }
        }

        return idsWithSelectors;
    },

    /**
     * Resume selectors on a set of targets.<br/>
     * This can be useful for undoing a call to pauseAllSelectors.
     * @param targetsToResume
     */
    resumeTargets:function (targetsToResume) {
        if (!targetsToResume)
            return;

        for (var i = 0; i < targetsToResume.length; i++) {
            this.resumeTarget(targetsToResume[i]);
        }
    },

    /**
     * <p>
     *    Pauses the target.<br/>
     *    All scheduled selectors/update for a given target won't be 'ticked' until the target is resumed.<br/>
     *    If the target is not present, nothing happens.
     * </p>
     * @param {cc.Class} target
     */
    pauseTarget:function (target) {
        cc.Assert(target != null, "Scheduler.pauseTarget():entry must be non nil");

        //customer selectors
        var element = cc.HASH_FIND_INT(this._hashForSelectors, target);
        if (element) {
            element.paused = true;
        }

        //update selector
        var elementUpdate = cc.HASH_FIND_INT(this._hashForUpdates, target);
        if (elementUpdate) {
            cc.Assert(elementUpdate.entry != null, "Scheduler.pauseTarget():entry must be non nil");
            elementUpdate.entry.paused = true;
        }
    },

    /**
     * Resumes the target.<br/>
     * The 'target' will be unpaused, so all schedule selectors/update will be 'ticked' again.<br/>
     * If the target is not present, nothing happens.
     * @param {cc.Class} target
     */
    resumeTarget:function (target) {
        cc.Assert(target != null, "");

        // custom selectors
        var element = cc.HASH_FIND_INT(this._hashForSelectors, target);

        if (element) {
            element.paused = false;
        }

        //update selector
        var elementUpdate = cc.HASH_FIND_INT(this._hashForUpdates, target);

        if (elementUpdate) {
            cc.Assert(elementUpdate.entry != null, "Scheduler.resumeTarget():entry must be non nil");
            elementUpdate.entry.paused = false;
        }
    },

    /**
     * Returns whether or not the target is paused
     * @param {cc.Class} target
     * @return {Boolean}
     */
    isTargetPaused:function (target) {
        cc.Assert(target != null, "Scheduler.isTargetPaused():target must be non nil");

        // Custom selectors
        var element = cc.HASH_FIND_INT(this._hashForSelectors, target);
        if (element) {
            return element.paused;
        }
        return false;
    }
});


/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * A class to pre-load resources before engine start game main loop.
 * @class
 * @extends cc.Class
 */
cc.Loader = cc.Class.extend(/**  @lends cc.Loader# */{
    resourceCount:0,
    loadedResourceCount:0,
    timer:0,

    /**
     *  Check the loading status
     */
    isLoadedComplete:function () {
        var loaderCache = cc.Loader.shareLoader();
        if (loaderCache.loadedResourceCount == loaderCache.resourceCount) {
            if (loaderCache.onload) {
                loaderCache.timer = setTimeout(loaderCache.onload, 16);
            } else {
                cc.Assert(0, "cocos2d:no load callback defined");
            }
        } else {
            if (loaderCache.onloading) {
                loaderCache.timer = setTimeout(loaderCache.onloading, 16);
            }
            else {
                cc.LoaderScene.shareLoaderScene().draw();
            }
            loaderCache.timer = setTimeout(loaderCache.isLoadedComplete, 16);
        }
    },

    /**
     * Callback when loading resource error
     * @param {String} name
     * @example
     * //example
     * cc.Loader.shareLoader().onResLoadingErr(name);
     */
    onResLoadingErr:function (name) {
        cc.log("cocos2d:Failed loading resource: " + name);
    },

    /**
     *Callback when a resource file loaded.
     * @example
     * //example
     * cc.Loader.shareLoader().onResLoaded();
     */
    onResLoaded:function () {
        this.loadedResourceCount++;
    },

    /**
     *  For loading percentage
     *  You can use this method to create a custom loading screen.
     * @return {Number}
     * @example
     * //example
     * cc.log(cc.Loader.shareLoader().getProgressBar() + "%");
     */
    getProgressBar:function () {
        var per = this.loadedResourceCount / this.resourceCount;
        per = parseInt(per * 100);
        return per;
    },

    /**
     * status when resources loading success
     * @example
     *  //example
     * cc.Loader.shareLoader().onload = function () {
     *      cc.AppController.shareAppController().didFinishLaunchingWithOptions();
     * };
     */
    onload:undefined,

    /**
     *  status when res loading error
     * @example
     * //example
     * cc.Loader.shareLoader().onerror = function () {
     *      //do something
     * };
     */
    onerror:undefined,

    /**
     *  status when res loading
     * @example
     * //example
     * cc.Loader.shareLoader().onloading = function () {
     *       cc.LoaderScene.shareLoaderScene().draw();
     * };
     */
    onloading:undefined,

    /**
     * Pre-load the resources before engine start game main loop.
     * There will be some error without pre-loading resources.
     * @param {object} res
     * @example
     * //example
     * var res = [
     *               {type:"image", src:"hello.png"},
     *               {type:"tmx", src:"hello.tmx"}
     *     ]
     * cc.Loader.shareLoader().preload(res);
     */
    preload:function (res) {
        var sharedTextureCache = cc.TextureCache.getInstance();
        var sharedEngine = cc.AudioEngine.getInstance();
        var shareParser = cc.SAXParser.shareParser();

        for (var i = 0; i < res.length; i++) {
            switch (res[i].type) {
                case "image":
                    sharedTextureCache.addImage(res[i].src);
                    this.resourceCount += 1;
                    break;
                case "bgm":
                    sharedEngine.preloadBackgroundMusic(res[i].src);
                    this.resourceCount += 1;
                    break;
                case "effect":
                    sharedEngine.preloadEffect(res[i].src);
                    this.resourceCount += 1;
                    break;
                case "plist":
                case "tmx":
                case "fnt":
                    shareParser.preloadPlist(res[i].src);
                    this.resourceCount += 1;
                    break;
                case "tga":
                    //cc.log("cocos2d:not implemented yet")
                    break;
                default:
                    throw "cocos2d:unknow type : " + res[i].type;
                    break;
            }
        }
        this.isLoadedComplete();
    }
});

/**
 * Share Loader
 * @return {cc.Loader}
 */
cc.Loader.shareLoader = function () {
    if (!cc.shareLoader) {
        cc.shareLoader = new cc.Loader();
    }
    return cc.shareLoader;
};

/**
 * Default loading screen, you can customize the loading screen.
 * @class
 * @extends cc.Class
 */
cc.LoaderScene = cc.Class.extend(/**  @lends cc.LoaderScene# */{
    _logo:new Image(),

    /**
     * Constructor
     */
    ctor:function () {
        //this._logo.src = "data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAABBAAD/4QMpaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjAtYzA2MCA2MS4xMzQ3NzcsIDIwMTAvMDIvMTItMTc6MzI6MDAgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkU2RTk0OEM5OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkU2RTk0OEM4OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzUgV2luZG93cyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuZGlkOjU1RUQ3MTcwQjQ4REUxMTE4RkUxODUzMUE4ODZGQ0I4IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU1RUQ3MTcwQjQ4REUxMTE4RkUxODUzMUE4ODZGQ0I4Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+/+4ADkFkb2JlAGTAAAAAAf/bAIQABQQEBAQEBQQEBQcFBAUHCQYFBQYJCggICQgICg0KCwsLCwoNDAwMDQwMDA8PEREPDxcWFhYXGRkZGRkZGRkZGQEGBgYKCQoTDQ0TFhEOERYZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZ/8AAEQgAyACgAwERAAIRAQMRAf/EAMQAAAEEAwEBAAAAAAAAAAAAAAcABAUGAQMIAgkBAQACAwEBAAAAAAAAAAAAAAABAwIEBgUHEAABAwICBAcKCQkFBQkAAAABAgMEAAURBiExEgdBUXEiMrITYXIzc5MUNBU2CIGRodFCUpLSVLFigqIjQ3QWF/DBUyRWwqOzNSbhY0SEpCV1RhgRAAIBAwAGBgYJBAIDAAAAAAABAhEDBCExQXESBVFhMnIzFZGhUhMUNLHB0eEiQmIjBoFTYxbwonMkJf/aAAwDAQACEQMRAD8A5loBUAqAVAKgM4UAsKAyE40BtDaRhtEJ2jspx0YnioRU9qjKTwUFTSpBHBQk8YUAqAVALCgFhQCoDFAKgFQCoDNALCgM4UAsKAzhQHoJoDY2nE0IY5nwlP2qTsjFbaO1Thxo0/kqaGFdJAW2/uR9lqWkvxtQP7xI7h4eQ0qZNFl7GPMYEmIsOsq4U6weIjgNTQxqMXGFIOkViZ1NJSRQkxhQCwoBYUAsKAxhQCwoDGFAIUB7CcaA9homgPYYVxUIqZDCuKgqZ7BXFQVPQYVxUFRyxFUVDRUpGLkTDsmBaIK5FyVstLSpCGhpW4SMNlIrPUVvS9BK+7pZcu50v993f5iiofi3y3KkW9a9DjMuEvaSptY5yVdktYOGusC4jc/7sMzbqri/Ohlcywoc7J14jFTRJ0NyUjQMfouDQe4dFTuMK7GREKTDvccvRuY+gft456STxjjT3aayNKND0RSDqqDNMblhQ4KgmouwVxUFTHYK4qCpgsKoDBZUKCp4KMKCp4IoSYTQDuO12hAFEYtm9c6zxHCxKlJQ6npJAUrA8R2QayRjpNgvGXPxo+w592mgijPQvOW/xo8m592mgUZn11lv8aPJufdpoFJGRe8tg+mjybn3aaB+I9O5my9EjrejvedSEj9mwlC07Su6VAADjqaox4Wy1bsN0F53mibnzN7jtvyDaGnZMiQOYuUmMkrUxFx6KBs4Lc4ODFWrFstSoT+53dhm6yHK+/GCwU2ZN5KJFobSoyEWd9Xm65SccStCNtWI17I2tIqDI7C3gZbanw3Lm0yh5SGy1PjrSFoejK0ELSdCtnh7lFoMZRTVGcO70N1MvJzqs55LCzYUK2psMYrcgFR4eFcZR0Ano6lcdZ00VRUpaeGRVI2Z7DMiodmO+aS9TrJStQx40lIOg0qmTwtGDest4+nDybn3aaCaMXrrLn40fYc+7UaBRmPXOXPxo8m592mgUYject4emj7Dn3aaBSRpXd8vnQmYCT+Ysf7NNAoxPsoKUuNELbWNpKknEEHhFQzJDBYw0VBkjwnXQkmbYgKWnlqUVyB9JxMl8nSe0Xif0jQyJS15WzJe2FSbRaJc2Mk7JeYaUpG0NY2tWNWQsznpSbNe7l2bTpOSi94//p5nn/Ttw8iay+Gu+y/QVeZY39yPpF/TzPP+nLh5E0+Gu+y/QPMsb+5H0jG6ZUzLZIwl3i0yoEVSw2l6QjYSVkYhIJ4dFYzszjrVC2zl2brpCSk+oLXu+7i5O9K6+ur2hcfI9tdCZTgxQqY8nT5u0fq/4ixqGgaToqZsnc+c8qetckuZGsTSbfbrgli1OebANojW4qSJGwkYAfsEqQnukUJLVb4EO1wYtst7KY8CGyiNFjoGCUNNJCUpA4gBQDgpSpJSoApIwKTqIOgigAtmW0Gw3Z6MlCVwZCVKabcAUhbDmhTawdCk/RI4qlNp1RhO2pqjOPd8+6lOUJAzNl1pRyjcHdhTIxUYElWnsVH/AA1fu1HvTp15uK1rUVW7jrwy7S9YNrVlXMl8jql2e1SZ8ZC+zW7HRtpSsDHA4ajhSFqctSqRey7Vp0nJRfWP/wCnmef9OXDyJrP4a77L9BT5ljf3I+kX9PM8/wCnLh5E0+Gu+y/QPMsb+5H0nh3IOdmW1vO5duCW0AqWrsFHADWcBiafDXV+V+glcxxpOiuR9JWyCCQdBGgg1UbZe7KjasEZR06XAOQLNSY10jZ0YE1gWI0p10JJ+0eETyiskVSBxJ9If8YvrGoZmjsrIrTbGS8vNMoDbfq9hWykYDaWgKUeUqOJrp8VUtRp0HzDmsnLKuN+0WHE1sHn0MKWltCnHFhDaAVLWo4BKUjEkniApWhKi26LWwAsQLx7we82Nly0uOMZZglSlyQMUsQkKAdkqGrtHTzUA9wcdc1mZLuz/StR9K5Ry1YllJ9uWmX2f0PoHl2yWjKllg5esUZES1W5pLEZlPAka1KP0lKPOUTrNah6xK9tyUBUd5uZG8s7vc031xewYdskFlSTsntnEFtoAjhLik0AOPd+3lZmvNubyTvEiPws5QYLVwt78xJQ5cbW4AEP6ek43iErPDoJ07VAE7O1uTc7Ot9tIMqDi+3hrKB00/Fp+ChDBA83b58SVa7rHTLtFwaMedFXqW2rhHEpJ5yTwGsoSpuKb1vjVV2lqOZFNXLcTvDct0pxcrKlyCVtvjU/CWr9m8ODtWDoUOXjFbdi87Fz9LPMz8SOdYpquR1dT+8vEfPzTu9peX25CXbRIgNxI60KxbMoDzgKB/OCtivSjlVyeGv4dRzc+VNcu941S4pVe7UFDE16JzlDOJGo4UFDjreQy0xnzMTTKEttiashCRgAVAKOA7pNcxlKl2W8+ocrk5YttvXwkrYx/wBORu+c65qnYbm0ZP8ASNYFiNKNdCSes/hE8orJFUwcSvSJHjF9Y1DM0djZKd/6Ry+OK3Rv+GK6rGX7Udx8q5lKmVc7z+ksgUDqq01VKoKN9+blWaxN5ehObNwvIPblPSREScFeVVzeTGvN5lf4Y8C1s6X+N4PvLruy7MNW/wC4Pfu97u2t3ORmHJrQRma/hE+7KUOe2gjFiP3OzQcVD6xNeCd2Fl26RGHo8d6Q23IlqUiK0tQC3VISVqCE61bKRicNQoSbvOhx0BC5jsdszVFiW+8gv2yNMZnvQtHZyFxiVNId+s2lzBZT9IgY6KA33O2W67TbZcpKNm52d8ybdNbwDre2kodbx4WnkEpWjUdesCgJMyUEEK0pIwIPCDwUAEb1G9WXWXC/dtOEtHjbVzk/IamhBTt4OUW94WT5NnbQDmC1hc6wunpFaR+0j4/VdSNHdwq6H4o8O1ajSuv3U1P8r1nHUJy4W2Q1d46FtuW+S2Q6QRsPoO2lCuI8w6KrUmnXoNqcFOLi9Ukdq2i5sXq1QbvGOLE9hEhHc2xiR+icRXVW5qcU1tR8qybDs3ZQf5XQe1mUHH2872/zH/GHqprmcvxpbz6byr5S33SSsXs5F75zrmqNhu7Rk/0jWDLUaE66Ek/Z/CJ5RWSKpA4lekSPGL6xqGZo6syvMWzk21qQcFt2ttSDxKSziPlFdXYdLCf6T5VnxUs6aep3PrHeRs4R822Ji5JKW5bf7K4s4+DeSNJ71Q5wrHFyFdhXo1mXNeXTw77guzLsv/m0HWRbeN7W/Dz+Yntsv2hwzXEK0oMWEoJYbPjXdnHlNc5k3feXGz6NyzFWPjxhtpV7ztty4IbS4++4G2m0qcdcVoSlCRtKUe4AMa1zfOW7Rm3Nmad9mUt4NwivRsiz5kyx5WU5oQWgwtO3s8Cn1c7aw52odGpB1L52eOoAvO+7SoNbVzYfLyWHkOlhwsPhCgrYdSAVIVhqUARooDZ533aAoGfUhMuJNH75stLP5zZxHyGpBU408xZDUlCtlTSgva7g1/JWUZcLTK7ttTg49IJ7tlmNfsn50ukaImO9fJ0i/wBuYSnZKWoqipoYcBdbDiv0qmvFJlUY+7hGuwdbibybhlB62OKxdtMlSEA6+xfHaJ+JW1XuctuVt06GcX/JsfgyFP2160FavROcOPt53t/mP+MPVTXM5fjS3n03lXylvuknYvZyL3zvXNUbDe2jJ/pGsCxGhGuhJPWjwieUVkiuQOJXpEjxi+sahmSOmrA4U5Ngf/FJ/wCDXVWH+wu6fMc23/70n/k+s57y7me55aVNNuXgi4RXIkhsk4YLSQlY/OQTiK5qzflbrw7UfQ8vCt5CjxrsSUkdP+67Y0W3KV0zE4nCReJfm7Kzr83hjD5XFq+KqTdDHmmI9fbK9Ym3FNMXRSIs95s4KTDUcZGyeBS2wWx31AO5EC1yIMW2qitogwVsOQGWxshhcQgslvDolGGjuUBIGVjicaAY3i+s2W03C8vkdjbor0tYPCGUFeHwkYUABtwGYcxwrncbdmxl1gZyC8z2WS9jsyHCopkbB4yjZVs68E46qA6H85oCr5xfblWZqQ0oLS2+kpUOJQKT8tAD1TgWkoUAUqBSoHUQdBFAOIK2jJjsuAebrUllaODs18wjDi2TWUO0im+q23uAxuc27BvAzHlZw4DZfZCTwrhPkD9UmvS5bLhuuJzv8igrmLC50P6ToGvcOHOPt53t/mP+MPVTXM5fjS3n03lXylvuknYvZuL3zvXNUbDd2jJ/pGsC1GhGuhJP2jwieUVkiuQN5XpEjxi+sahmSOkLC7jlGC3wm2JSPhZrqLPgLunz3LS+Ll3/AKwc7sckR895fzdbEBKL3Dbiy7Q8rRg6kuBTZP1XRzT3cDXLH0NHSu6N2LG3d2KFGxQ7CbcjT2VDZW3MQ6rt0LSdIUlZ+KoJLyJXBUgiZObsvwnSxJusZt4HBSC4CQe7s44UBIx7pGmNB+I+3IZVqcaUFp+MUBA54juXnKlzszRIVcwzCURrDbz7aXD9jaoCZXHt6mokcx0Fm3qQqAMBiyWk7CCgjSkhOjRwaKAdedHHRQA0v2abbbHrxZpk5ptLj6X2EFeJSoqClDAY4Yg0BCx7jGlt9rFfQ+3wqbUFAcuGqgN6JOytKhrCgR8BonpMZqqYNV4Wz3jpSUc1uZMcJA4RLi9of1jXoY74cldZz+dHj5bLqX0MPZroDganH2872/zH/GHqprmcvxpbz6byr5S33STsXs3G753rmqNhvbRk/wBI1gWI0I10JJ+0dNPKKyRXMG8n0h/xi+sahmSOhMtOA2C1tnUYbSfjQBXVY6raW4+fZypkzf6vrIj3epPmWasw29RwU5ExA7rD+H+1XKzVGfQYOsUw/RoTMK6TLjEV2SbkEruEcdBchsbKXxxLUjmr+tgDrFQZFYzvmKUP/ZoDpa2k7U11BwVgrU2CNWjSqgBfLl2m1kJnzGIqjpCHFAKP6IxNQCVy5fm2ZHneXri06tPhW2VhSVJ4lo4vgoAzWq9N3WGiSgbC+i80dOwsaxycVSB95yeOgKTmzM8o9pbbc6WW0AiXJScD3UJV9EDhNQwAq73OyC4LSmfHUohO0UrCudw4qGI+WgNsGQ9CdRNgO4HWFIOKFjiOGgipARodwRMjNSUYgODSniUNBHwGo2kPUVDMRx94WApOsvwtrl81SDXoWvmI/wBDwLjry6b6pfSH010KPn5x9vO9v8x/xh6qa5nL8aW8+m8q+Ut90k7F7Nxu+c65qjYb20ZP9I1gWI0I10JJ+0eETyiskVSBvK9If8YvrGoZmg75ddwsls7kVrqiuoxn+3HccNn263p7yt5Gk+ot7ymVHZbnOSI3cwkI7RH6wFc9lw4bsl1nYYM+OxF9R0gJOnXWubYGN42YnLHFfmNEG5XB9bUUq07IHSXh+aMMO7UIMALrrr7q3nlqdecO044s7SlE8JJrIxqe4z8mG+iTFcWxIbO0262dlQI7ooKnSW6jOBv0VxL5Si4x9lqc2nQF449m6BwbWBB7tYmQS5MxTbDi0K5+ydjlPD8FSDlPPmcZF8nvW+A6pFmYWUc04GQtJwLi+NOPRFCGykYEcGAqSKkxYbw5apaErUTBdUEvtHUMdG2OIioJDdYlFKCwDiC6kp/TwolpRjclSLfUyGQoXT3hFuAgtRJStpWOgJixdkknuEVv2NOSjnr74eVvpkvpYcGcw2KVcPVMS4x5Vy2FOKjR1h1SUI1lRRiEgd017qvQb4U9JxksO9G37yUXGPWco7zfb/MX8Yeqmudy/GlvPonKflLfdJOxezkXvneuao2G9tGT/SNYFiNCNdCSetHhE8tZIqkDiV6Q/wCMX1jUMzQZ7C7hZ7cMf/DN9UV0+O/247jj8yP7st5Us5qdtWYrXmGOMFpLbgI/xIygcPhTXk8yt0mpdJ7XJrtbTj7LOiI1zZmxmJsdQUxJbQ+0ocKXEhQ/LXm1PYAdvsC03a0I/cmK4tHFtKdwP5BREMGsGKZLgQPhrKKqyq7c4FUJsnc5miNYvXrsJIihrt1thYL6WsMdtTevDDTx1tvEdKnjrm8XOgy3TrdgZ6biJJ7OZGfbcHBzE9ok/AU1ptUPatz4lUMub7g5EynfZbKsHWYThQRrBXggH4NqoLDnzKWTrjmma3brYx20lYKsCQlKUp1qUo6ABx1fasuZ52ZmKytJI5y3eXjKDjbV0YSjtklTLragttYGg4KHCOEVlex3AqxOYK86FBcTs4itc9MO9hnMW+HapU4rKezYccQ2hTjitlIOASnEkmpjokqmGRGUrbjHW0CbMUS7tzZN6uKfNnLpJedS2VjtSHFFasQk6AAcDjUuVXUm1bUIKPQkH/crlL1FlxV7lN7NxvYDiQoYKRET4NP6Z55+Cvc5dY4IcT1yOG/ked7697uL/DD6fuAhvO9v8x/xh6qa8rK8aW86vlPylvuknYvZyN3znXNUbDe2jJ/pGsCxDdOuhJP2jwieWskVTBxJ9Jf8YvrGoMwr2V/C1wRjqYb6orpsfw1uOVyl+7Lea8zwvWtmebbG1Ij/AOYZHCSnpD4U1Xm2veW30rSWYF33V1V1PQTG6zMomWVVmeX/AJq2H9kDrVHWcR9hXN+KubZ1CHe9CyOX/Ljdyho7SdYlKddbTpUqG7htqA4ezUAo9ypQaAxaJSY8hDh4CCDyVnCXCzVyLbnBo6Onb9LdIy07FbgLTeH4xjrUVJMdJUjYUsfSOjUnCvTeVHhOajy25x9QPN1kBcm+XLMpSRCtUZUdtw6lSpfMSgHjSjaUa8uTqzqbEOGKQTpMZN9gXCxFQSq6RHojSidAdWnFv9cCsC5go3Z5z/kW9uuXCKpY2Vwp0foOoKVDawx+klSdRrdxryizxOZYcrmlExvW3lQc4IiRYEdTEKHtrSXikuLW4ACSE4gAAaKsychTWgo5fgzhLiYJLVbHr3dGIDIwDitp5zgQ0nStZ5BXnnQIMK5DacdghuO0nAFRwCWmxrPcCRQSaSqyp5atDu8rOyA4lQsMHBySo6MI6FaE98+r+2itvEx3enTYtZ5fNM9YlhzfbloW/wC46mSlCUJQ2kJbSAlCE6AlIGAAHEBXSpUPmrk5aWcgbzfb/Mf8YeqmuZy/GlvPpvKvlLfdJKxezcbvneuao2G9tGb/AEjWBYhunXQkn7R4RPLWSK5A4lekv+MX1jUMyQTLUcLbC8Q31RXS4/hx3HMZPiy3kih4pNXlFCmSzJylmBm829P+VdUVdmNCSFeEaPLrFc/m4/u51XZZ0WDke8hR9pBgtF/blMx7rbXQptY2kEgHWMFIWk/EoGtA3yBu+7HLuY31Tcu3JnLtwdJU9ap215kVnWWHk4lsE/QUNHBWRDQ2hbkJbLqF5lzXaoNvxxUITplSFpGsNowSMeWhHCi6retFvgxrFlyOYtihEqaDhBefdV033jwrV8gqCRki4gyCy2rntALUoHDZOPNHLQkhs62fLub5SJ7MlNmzYpOFxeUP8nKIACVqA0odI6RojFopB3bXFC9qferazGGtxDqnlEfmoSASakJE9AhW20MG32VC3FPkCTMdA7Z8jUAB0ED6vx0pXQRKUYqregrt/uUi6SW8r2IGTIkOBuStrSHF46Gkn6idajw8gqyMG3wrS2a0rqUXdufhhHT9/wBgdcjZdi5PszduaKVzHCHp8kfvHiMNH5qNSf8AtrqMXGVmFNu0+ac25lLMvOX5V2V1fay5Nv48NX0PNTOSt5Z2s/ZiPHMPVTXLZnjS3n1TlHydvuknY/ZuL3zvXNUbDf2jN/pGsCxDdOuhJPWfwieUVkiuQOZPpL/jF9Y1DMkEy1/8theIb6orpcfw47jmMnxZbx5V5QaJkRmdGciyBtNuDXwpI1KHdFV3bSuR4WWWrrtS4kVODcLpkycppaS/b3zipGpKwPpIP0Vjhrnb9iVqVGdLYyI3Y1Rf4GYrfc2g5GfGJ6Ta+aoHiIqgvHT60vtFAOyo6ULGghQ1HEUBGC9yW21tOjF9PNS5xHuioA3Yujkdt3Y0vunEuHgHz0A1MgkkqViTpJOvGgPbRU5tFOylCBi46rmoSONSjoFTGLZXcuxhrIO4356W4LNlxK5EiSeyXKbB7RzHQUND6KeNXDyVbFaeGOls1pKv47rSitn29YUMh5JYyvH88l7L17kJwccGlLKD+7Qesrh5K97Bw1aXE+0cbzrmUsr8EPDXr3l7Q6RXpJnMyttDtqQRQqaOXt4itvPF/Vxyz1U1yuZ40t59W5P8na7pL2P2bi9871zWvsN/aMn+kawLEaE66Ek9Z/CJ5RWSK5A5k+kv+MX1jUMyQTLX/wAsh+Ib6orpcfw47jl8nxZbxyp1CdZq5yRUkzQua2ngqt3UWK02MJkuLKZVHktJcaVrSeA8YPAaou3IyVJI2LUJwdYsqUiE7Ce7e3OqwGoY88dziUK8e7ZUXoeg9q1e4u0qMdxc0SmeZICgRoKmzgfhSdFa9DYqSHr2FIVtuSQlZ19olST8gNRwmLl1Hs3W2p6U5HIhK1H8gqeEx949iGz2ZLez6Ow5Kc4FOnsm/iGKjWSojBq49qiM1vXjMCktyHUx4QOIQBsNDkSNKjy1ZGEp9RXJ27OnXIIOVxZsvt4xG+0lrGDsxzAuEcQ+qnuCvWxVbtalp6Tns93sntOkegusa/tKw/urfV5M8WeJKJLsXGO7qVge7Vikac7XSPkuYjEHEVYmac7JzTn045yvh45R6qa5bM8aW8+mcoVMO33Scsfs5G753rmtfYb20ZP9I1gWI0J10JJ20eETyiskVzB1K9Jf8YvrGoZkgl2wY2yGP+4b6orpsfw1uOYyfFlvNrkfa1Gs3CpWp0GbsFZ1VTK0y6N1DJy3O8RqiVhs2I5CQ0ctrx+iaolitmxHMQ0ds63Okgnu1S8RlyzIjc2JR4FCsHhyM/jYmU5fUfrU+DkQ82I8ZsCknFLenjw+erI4bKpZ8SUYs0jRoNXRxmjUuZaZMxbO+CDgavjYZqTyETsW2upAxxFbEbLNK5fROxo5RhtK1VfCFDzr1zi1Eyw8EJA/LVpqs53z0cc33o8ck9UVzGX40t59B5Z8rb7pO2P2ci9851zWvsNzaMn+kawLEaU66Ek5aPCJ5RWSK5g7k+kveMX1jUElsteaYbEJmPLbcS6ykNgtgKCgnUdYwr1sfPjGCUlqPJyOXylNyi1pHn83Wnif+wPnq7zG31lHltzpQv5utP1X/sD56eY2+seWXeoX832nif8AsD56eY2+seW3eoX83Wj6r32B89PMbfWPLbvSjH822f6j3kx89PMLRPlt3pRj+bLN9R7yY+enmFoeXXelGRm2zjUh7yY+enmFojy270o3oznZ060PeTHz08wt9Y8su9Q5Rnuyp+jIHI2Pnp5jb6zF8quvoHCd4FjTwSfJj71SuZW+srfJ7r2o3p3jWAa0yfJj71T5na6yt8lvP2TcneVl4a0yvJD71T5na6yp8hvPbH0m3+qGXkJJS3LWoDEI7MDE8WJVR80tU1Mw/wBfvt6XEE93uK7vdJlzcQG1y3VOlAOISDqGPcFeJdm5zcuk6qxZVq3GC/KqFysns5F753rmsdhntGT3SNYFiNCddCSdtHhE8orJFcgdyfSH/GL6xqCToHLvu62B7J9izVnjeDByqrMTPnduhvoQQWSAoc9x1G0vZUCoAaMagyoaIfu92PMGeoWU8oZ+hXq2m2u3W73hhtCxFQy4Gw2ENuKClr2gRioYDE0FCft/uzZDv8lVqyzvat1zvjiHFRYTTTS1KU2CTiG3lK2RhpwGigoV7J3u7wrllh/NWec6QspQE3GRaY3apS4lb0R1bLhLji20jFbatkDgGNTUUNc/cNlqZmPLOWcjbw7fmWffpLzMotJRhEYYa7VTyg24sq0AgJ0YmoFCzo92nd09dfUDO92Au+KeMNNvDTJeMgHZ7PYD+1tbWjCgoV/Lnu2OS5mcP5uzZCy9ZcnzhbJFzKNtDrqkocSvnrbDaChxGs44nDgoKHnMW5PdfaLDc7pb97tsuU+FFdkRbc2lnbkOtpKktJ2XlHFZGyMBSooD7KOSss5gtJn3fNsayTA8przF8IKthIBC+ctPSxrcsWITjWUlE8nNzr1mfDC07iprRL3ndTbY9gm33L2aI17btxSZbTSEgBClAHBSVK5wBxwOurbmEuByjLioa+PzmUr0bd204OWolJ25zLFqcbYuueI8GQ42l1LUhtDailXCAXNWNZywIR7U0nuNe1z29dTduy5JOlUyNf3NyE5otdkjXlmRbLpFcnNXII0hpnDa5gJCidpOzgrA41g8B+8UU9DVS6PPofDyuSi1KDo49Zav/wA8wdf8xvYHUfNk/frZ8qXteo83/a/8frMH3eYWySMxug8BMZOGPd59R5V+r1D/AGv/AB+sCN9tD9hvE+yylpcfgPqYW430VbJ0KGPGNNeXcg4ScXsOrx7yvW4zjqki3WT2cjd851zWOwz2jJ7pGsCxGka6Ek5aPCJ5RWSK5A8lekP+MX1jQkPm++SH91m5xo6extS0/wC4j/NUGRj3VJIiZwzGoaNrL8hPxuIqGCF92d8Rt8tpeGA2Wp2nlZWKEl13ny+13BxmCccM6XNzDllzPnoiAf8Au3PCNvjy68NGyJXyx1ijB5sjwHvEsSNHteteP/m1GgD/AHXzLOLO+XIDd3hW69XW+RpbQnOBCeyTHjHbw1kYtFPNxwNESAvMnu85jsFguGYIt6tF4ZtbZkS40BxZdSynSpQ2k7J2Rpwx1aqVIKRlnIdxzPCduLUqNCgtOdkHpRI2lgAkDAcGPDW5Yw5XVxVSSPLzua28WSg1KUmtSL5GtbeScj5it8y5xJLl1U0GEx1YkqBCQnA6SeGt1WlYsSTkm5U1HiTyJZubanCElG3WtSv76HzIzJCWrSRbWh8SlVRzTxF3Ub38aTWPKvtsJNtmqF5yYcfB2B9A+FLNelbS47fcOdyLcnZyF/mX1mjMN4uWTswHNiHHpWXbkER7xC2irsXEjZbdaBOAxw/tjWORJ2LnvFphLX1GeDjxzsb4eSUbsNMJdK6GOsmSbzcZUvOV4dcbXdEBq227aPZsQ0nFJ2dW0rj+erMNSm3dn+bUuoq5soWoRxrS7Hal0yAhn9wu50vrh+lLUfkFeJmeNLednylUxLa/STNk9nI3fOdc1r7Dd2jJ7pGsC1Gka6Ek1afCp5RWSK5A+k+kP+MX1jUEhi3syg7u93YNE+Ctyh/umaEmPd2lCNme+LB6VlfT8a01DJoRW4WQI+9G2u46m5fytKoSWrP8wObnI7GOrNU9fxyZJ/voQU3cW+GN6FjdB6Ikau6wujCPFpfA33Mv4/8A2Za//UmgGe+J1L+8zMrqiOdJQdPiUCiBbN0EkMZG3nNg+FtaRo8W9QFTiv4brZkfHQZyTh+kivSj8o+8eLcj/wDRi/0FGbw7VvDDpp/KK89az2JamXfeg/298jKJ1QW0/rKr0OZeIu6jyORw4bL7zLxCmkXPLJx8HZ3UY8oar0IP8dvunjXrT91e/wDIjXdmJmZr2mHckKbyzbgHNjHDzt5Q0aR9FP8AbXS7bleu0kqW4+snGlHFscUHW9P/AKo35ZXdLG9KsT22/Z2f21rmKPRQo6WT3U41lixnbk4Ps7H9RhzCNvIhG6tFx9pfWCnN6+0zPd3PrSVH5BXi5fjS3nT8vVMeC/SWGy+zkbvnOuao2GztGLx5xrBliNYoSStscCXE8tSiuRQ5PpD2P+IvrGhIQrNvdvFqs8OzSbZAubMBHZRnZaCVpbGpJ1jQNGNQZVPCt7N3Rf4t/hWyBCcYjLhPRWUENPNOK2zt4YHEEDAilBUk077rqyVOQ7Dao0nAhD7aFBSSeHRhjShJE5f3rXux25y1vwod1jLkOSkeeIJKXHlFa9Wg4qJOrRQip6uG9a6yp9quUK12+2y7S8t5tUdsgOBxGwpC9WKSmgqSv9brkHe3Tl61CRjtB7ZVt7XHtdLH4aCpE2rerc4D1zlS7Vb7nLukozX3pLelKikICEa8EAJGFAbrvvevFztEy0RbXAtjU9BZkvRUELLZ0EDUNI0Y0oSVSzZmmWeK5CQy1IirX2gbeBwCuHVyVt2MqVqPDSqNLIw43ZcTbT6hzMze9MiuxTborYdTslxCecNOOI0VnPNclThSMLWAoSUuKToOVZ7luYFy3RXCAAFLBUcBy1n5i3rimVLlkVqlJDN7OF0cuUe4pS02YyFNNsJB2NhfSB4dOFVvNnxqXQXR5fbVtw11JD+oVz/CsfGv56u8zn0Gv5Ra6WY/qFc+CKxjwaV/PTzOfQPKLXSyqSpT02S9LkHaffWVuEaBia0JycpNvWz0oQUIqK1IuNnXhYI6fznOuaxeobRs6cVGsSxGuhJvZeLZBoYtGHIlokuqefYPaK0qKFFIJ48BU1IozItuX+GOvyqqnQNJn1bl78O55VVNA0i9W5e/Dr8qqo0DSL1bl38OvyqqaBpF6ty9+Hc8qqmgaRercu/hnPKqpoGkXqzLv4ZflVU0DSL1Zl78O55VVToGkXqzLv4dflVVGgaRercvfh3PKqpoFGL1bl38O55VVToGkXq3L34dzyqqaBpF6ty9+HX5VVRoGkx6ty9+Hc8qqmgaTCrZYfosL+FxVBRm9x9sIS0ykIaQNlCE6AAKE0GajiagkxQkVAKgFQCoBUAqAVAKgFQCoBUAqAVAKgFQCoBUAqAVAf/Z";
        this._logo.src = "data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAAlAAD/4QMpaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjAtYzA2MCA2MS4xMzQ3NzcsIDIwMTAvMDIvMTItMTc6MzI6MDAgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjM4MDBEMDY2QTU1MjExRTFBQTAzQjEzMUNFNzMxRkQwIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjM4MDBEMDY1QTU1MjExRTFBQTAzQjEzMUNFNzMxRkQwIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzUgV2luZG93cyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU2RTk0OEM4OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU2RTk0OEM5OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+/+4ADkFkb2JlAGTAAAAAAf/bAIQADQkJCQoJDQoKDRMMCwwTFhENDREWGhUVFhUVGhkUFhUVFhQZGR0fIB8dGScnKionJzk4ODg5QEBAQEBAQEBAQAEODAwOEA4RDw8RFA4RDhQVERISERUfFRUXFRUfKB0ZGRkZHSgjJiAgICYjLCwoKCwsNzc1NzdAQEBAQEBAQEBA/8AAEQgAyACgAwEiAAIRAQMRAf/EALAAAAEFAQEAAAAAAAAAAAAAAAQAAgMFBgcBAQEAAwEBAAAAAAAAAAAAAAAAAQMEAgUQAAIBAgIEBwoLBgQGAwAAAAECAwAEEQUhMRIGQVFxsTITFGGBwdEiQlKSMzWRoeFicqKyI1NzFYJjJDQWB9KjVCbxwkNkJWXik3QRAAIBAgMFBQcDBQEAAAAAAAABAhEDIRIEMUFRcTJhwVIUBZGhsSJyEzOB0ULhYpIjUxX/2gAMAwEAAhEDEQA/AMJSpUqAVKlXuFAeUq9wpUB5XuFe4V6ooDzZHDox0CnGMinzwl7Z8NajaHeoO3vmTBZBtp9YUIqTEV5ROxHKnWRnaU8VRMhFBUjpV7hSoSeUq9pUB5Sr2lhQHlKvcK8oBV7hSFSRrtaKAZs07YNPM1pG2xJIAw1jSeandry/8X4m8VCKkWwaWwam7Xl/4v1W8VLtmX/i/VbxUoKkWwakSM407tmX/i/VbxUmzGwjQsjdY41IARie/U0IbZO0kNtCXnOCkEBeFu4KI3Bs7DNb27ya+jDx3kJeEnpJJEcQVbWDsk17u5urd591ucZkWhym2Vnd9RkCDEpFxDRpbw0bunu5mlp2De2FMLYXOD2wB2xbOeraUcYGJ72mlSUiqzzdzMd3Z3mixltA2yzcK/NlHM1DQyRXce1HocdNOEfJXZ88y9ZojOqhiBszIRiHQ8Y4cK5TvHuzLljHNMqxNoDjLFraHHnjPxcNCGVbxEUzYNTx5jZSxhpW6qTzlwJ+DCvO2Zf+L9VvFSgqyHYNLYNTdssPxfibxUu15f8Ai/VPiqCakOwa82DU/a8v/F+JvFTDdWPBL8R8VKCvYRYV5UzoMAy6QdIIqI0B4KJtxiRQwou16QoGUkntH5Tz0RbZbmF2hktraSVBo2lUkY8tDye0flPPXTslVUyiyVRsjqUOA4yMT8dW2ram2m6UVTNq9S7EIyUVJydMTn/6DnP+im9Wl+g5z/opvVrpteEhQWY4AaSTwAVf5WPiZh/9S5/zj7zltzlmYWkfWXNvJDGTgGcYDHirR7i7mSbwXParsFMrgb7w6jKw/wCmnc9I14kF3vpvCljbMyWMOJL4aEiB8qU/ObUK7HYWVrl1pFZWiCOCBQqKOLjPGTrNZZqKbUXVHq2nNwTuJRk1VpbgXN8s7Rk5ym0UQQzhIG2NAjhxHWbI+gCBVjBBFbwxwQqEiiUJGg1BVGAFe7dV28WYLYZFmF2Th1UD7JGjymGyn1iK5OyzIBGB1HgrLZhamzumQAGJwSqnSCh1q3GOCodxt4cxurdcpzuN4cyhiWaF5Bg09udUmnWw1H/jV9nFuJ7Quo+8h8peThFA+047vduyMtk7fYqTl07YFdfUufMPzT5p71UdtlmYXaGS2t3mQHAsgxANdadYJopLe4QS2867EsZ4QfCNYrCFbjdDPmgkYyWFxgVf04ifJf6ScNdRUW1XBb6FU5TjF5EpSSrGu/s5lN+g5z/opvVpfoOc/wCim9WtdHnatvObJXDW7xLGhB8nrPaY9/HCr+tEdPCVaSeDoYLnqF63lzW4/PFSW3ecxbI84VSzWUwUaSdg0DXXK5nvAipnd6qgKvWnQO7pri9ZUEmm3Vl2j1kr8pRlFRyquBNZjGxQ/S56Y1S2fu9OVueon11Szahoou06QoQUXadIVCD2FJJ7R+U89dMydv8Axdn+TH9muZye0flPPXQstlK5Tbka1gUjlC1q0vVLkeb6r+O3Tx9xcY1nt8c0NrZCyiOE1108NYjGv1joo7Js1jzKyScYLIvkzL6LDwHXVJksH9Sb49dKNq0tj1jA6uriOCL+02FWX7iVtZX1/AzaHTyeoauKn2MX9W79zebiZCuR5MjSrhfXuEtwTrUeZH+yNfdrRNcxI6IzhXlJEak6WIGJ2Rw4ChWnChndtlVBLMdQA0k1gbXNMzzDfDLs6mjaPKppJbWwJ1bOwwxw43OnHh71YT3DpfWUJmFlb5jHHDdeXBHIsrRea5TSqvxqG04cNN62vetoCS4tre5mgnkGE9q+3DKOkuI2WX6LDQRRHWDh1UCtwj7QRg2wdl8Djgw1qe7XvW0BQ3kfZ7mSLgU+T9E6RVbnuVrnWVSWqj+Lt8ZbRuHEdKPkYVcZ2MJY5fSGyeVar45+rkWQHAqccalPE5km1htWK5nK4Wnt5FuUBUwOMG4nGkA/BXUrW4S6torlOjMgcd/xVn7rLo7zKs0uEjCNeSvdwoBhgsZxX1l2j36k3Lu+uyprdj5Vs5A+i/lD48a0aaVJOPi7jB6lbzWozpjB48pf1NDXNN4vfl7+Z4BXS65pvF78vfzPAK71XTHmZ/S/yT+jvJ7L3fHytz1E+upbL+Qj5W56jfXWRnsIYKLtekKEFGWvSFQgyjk9o/Keet3YthlMP/5x9msJJ7R+U89biyb/AMXEv7gD6tadL1T+kwepRrC39ZkLDMbiwMvUHRPG0bjlGg8ore/23sxBldxfMPLupNhT8yL/AORNZbdzJ484scytxgLqJY5LZj6Q2sV5G1Vud1mjjyG0ij0NEGSZToKyhjtqw4waztuiXA3qKTbSxltfGhbZlE95ZtZqxVbgiOZhrER9ph3Svk9+pJILZ4Y4DGBFCUMKjRsGPobPFhUfW0NJmljE2xJcIrcI2vFUEln1lRXd6lrazXT9GCNpD+yNqoI7mOVduNw6nzlOIoPOUa6yye1XXcbMR5GdQ3xY0BSbj31/FcTQZirJ+q431q7anbHCTZ72Bw7lbPrKBMcBWNNgbMBBh+bsjBdni0VJ1lARZs6yWiupxCuMDy6KpS2IwOo6DTr3Mre3e5tZZVUM4ZBjqOOJoWO4jkXajcOOMHGgDISvWIrdAkKR80+TzVl908bPPL3LzxOuHdifxVfiTAg92qI/w+/8gGgSyN/mR7XPVlp0lF/3L3mbVKtu5Hjbk/8AHE2Fc03i9+Xv5ngFdKNc13i9+Xv5ngFaNV0x5nn+l/kn9HeEWXu+PlbnqJ9dS2Xu9OVueon11kZ7CGCjLXpCgxRlr0hUIPYUcntH5Tz1s8vb+Bt1/dqPirGSe0flPPWusG/g4Py15q06XqlyMWvVYQ+ruI9xJOqzO9hOto/sP8tbGOFIrmWeM7IuMDMnAXXQJOUjQeOsJk0nY96ip0CYunrjaHx1t+srPJUbXBm2LrFPikwTOb+T+VhbZxGMrDXp83x1QSy2tucJpUjPETp+Cn5/ftaRvKvtp3Kx48HG3erHMzOxZiWZtLMdJNQSbbL71Vk6yynViOkqnEEfOWtPbXi3EQkGg6mXiNckjeSJxJGxR10qw0GtxuxmvbImD4CZMFlA4fRfv0BqesqqzTMZNMEDbIHtHH2QeCiZJSqMQdOGiue53mz3czQwsRbIcNHnkec3c4qAMuriz68gTIToxwOOnlp0MjxMJYW741Gs3RVldtbygE/dMcHX/moDaxTiWNZB53B3arb8/wC+4SOF4sf/AKxU9kcBsfOGHfoUHtG/RbzY5Die5HHhXdvavqiZ9Q8Jdlq4/gbKua7xe/L38zwCuhpf2Uk/Zo50kmwJKIdogDjw1VzzeL35e/meAVp1LTgqY4nn+mRauzqmqwrjzCLL3fHytz1E+upLL+Qj5W56jfXWRnroYKLtekKEFF2vSFQg9hSSe0flPPWosm/hIfoLzVl5PaPynnrRWb/w0X0F5q06XqlyM2sVYx5gmbFre/t71NY2T+0h8VbSO5SWNJUOKSAMp7jDGspmMPaLRlXS6eWve1/FRO7WYdbZm1Y/eW/R7qHxHRXGojlm3ulid6aVbaW+OALvgCLq2Hm9WxHKWqjhj6xsK1e8dm15l4niG1LZkswGsxtrPeOmsvayBJA1VItlWjptLuTdPMo7LtjRDq9naK4+WF9IrUW7BaHOljGqVHB7w2hzVoZt87d8vaNYSLl02CcRsDEbJbj71Uu7UBkvJ7/D7q2QoDxySaAO8MTXdxRVMpRp5XZOWdF/ms7R5XdyKfKWJsO/5PhrG5XlNxmEywW6bTnTxAAcJNbGSMXkM1pjgbiNo1PziPJ+Os7u7m/6ReM00ZOgxSpqYYHT3wRXMKN4ll9zUG4bQfNshu8sZVuEA2hirA4qe/VOwwrVbzbww5mI44UKRRYkbWG0S3JWctbd7u5WFfOOLHiUdJqmaipfLsIsObhWe001lMkMVvJNjhghIALMcBxCs7fxXQmkupx1bXDswGPlaTidVaEyKNXkoo4eBV+Sq7L7Vs9zcBgeyQ4GQ/MB1crmoim2orezqcowTuSeEY48jQ7oZX2PLzdyLhNd6RjrEY6I7+uspvH78vfzPAK6UAAAFGAGgAcArmu8Xvy9/M8ArTfio24RW5nnaG67uou3H/KPuqT2X8hHytz1G+upLL3enK3PUb66ys9RDBRdr0hQgou06QqEGUkntH5Tz1e238vF9BeaqKT2j8p56vbb+Xi+gvNWjTdUuRn1XTHmTh8KrJTJlt8t1CPIY44cGnpJVjTJYkmjaN9Ib4u7V923njTethRauZJV3PaW1rfLIiXEDYg6R4VYc9CXW7thfOZbKdbGZtLW8uPVY/u3GrkNUkM9zlcxUjbhfWOA90cRq4gv4LhdqN+VToNYWmnRm9NNVWNTyHc6VWBv8wt4YeHqm6xyPmroq1Z7WGFLSxTq7WLSuPSdjrkfumq5yHXDUeA92oO2SKpVumNAaoJLMXH3myp0rpJ4uKhc3tbDM5BMri1zAj79j7KTiY8TcdBpcsith0286o+sPCagEX9Pzg4zXUCp6QYse8oouCG3tk6m1BYv05W6T+IdyolxbHDAAa2OgDlNCz3ryN2WxBd5PJMg1t81eId2ukqnLlTBbfcuY+9uJLiRcvtPvHdsHK+cfRHcHDWsyawjyy0WBcDI3lTP6TeIcFV+S5OmXx9bJg1048o8Cj0V8Jq2DVu09nL80up7OxHi+oal3P8AXB/IsZS8T/YOV65zvCcc7vfzPAK3ivWCz445zeH954BXOr6I8yfSfyz+jvCLP3fHytz1G+upLP3fHytz1E+usbPaQ0UXadIUIKLtekKhB7Ckk9o/Keer22/l4/oLzVRSe0flPPV7b/y8X0F5q0abqlyM+q6Y8yQsBTDMor1o8aiaE1pbluMqS3sbLLHIhSRQyngqukhaJ9uBjo+H5aOa3ao2t34qouRlLajTalGP8v0IY8ylXQ+PKPFU/bYXOLPge6CKia0LaxTOxHu1Q7cuBd9yPEJ7TbjXKO8CajbMIF6CNIeNvJHjqIWJ7tSpYkalqVblwIdyG+RGXur0hXYJFxal+Dhq5y3slkv3Y2pD0pTr+QUClpJRUdo9XW4OLrTHtM16cZLLWkeC7y4jvlNEpcRtw1Ux27Ci448NZrTFy3nn3IQWxlgGrDZ3pza7/M8ArZo+ArF5171uvp+CqdV0R5l/psUrs2vB3hdl7vTlbnqJ9dS2Xu+PlbnqJ9dY2eshooq16QoQUXa9IVCD2FLJ7RuU89WNtmUSQqkgYMgw0accKrpPaPynnrZWG4Vi+VWmY5tnMWXG+XrIYnA0rhj0mdcTgdNdwnKDqjmduM1SRR/qlr8/4KX6pa8T/BVzDuLZXudRZblmbxXcPUNPc3KqCIwrbOzgrHEnHjoyD+3eSXkht7DeKG4umDGOJVUklfouThXfmbnZ7Cvy1vt9pmv1W1+d8FL9VteJvgq5yrcOGfLmzHN80iyyETPbptAEFo2ZG8pmUa1OFNn3Ky6W/sbDKM5hv5bx2WTZA+7RF2y52WOPJTzE+z2Dy1vt9pT/AKpacTerS/U7Tib1a04/t7kDXPY03jhN0W6sQ7K7W3q2dnrMccaDy/8At80kuZfqWYxWNtlcvUPPhiGYhWDeUy7IwYU8xPs9g8tb7faUn6pacTerTxm9oOBvVq3v9z927aynuId44LiWKNnjhAXF2UYhRg516qpsryjLr21665zFLSTaK9U2GOA87SwqY37knRU+BzOzags0s1Oyr+BKM6sxwP6tSDPLMen6vy0rvdm3Sxlu7K/S7WDDrFUDUTxgnTU826eXW7KlxmqQuwDBXUKcD+1Xee/wXuKX5XDGWLapSVcOyhEM/seJ/V+WnjeGx4pPV+Wkm6kKZlFay3Jlt7iFpYZY8ASVK6DjtDDA0f8A0Tl340/1f8Ndx8xJVWXB0KbktFFpNzdVXAC/qOwA0CQni2flrO3Vwbm5lnI2TKxbDirX/wBE5d+NcfV/wVR7xZPa5U9utvI8nWhmbbw0YEAYYAVxfhfy5rlKR4Fulu6X7mW1mzT8S4Yis/5CPlbnqJ9dSWfu9OVueon11mZvQ2i7XpChKKtekKhBlNJ7R+U89bDfGTb3a3ZX0Lcj6kdY+T2j8p560288m1kWQr6MJ+ylSAr+2cnV5renjs3H1loX+3j9XvbbtxLN9lqW4UnV5jdnjtXHxihtyZNjeSBu5J9k1BJe7xy7W5CJ/wCzuD/mTVTf2+fq97LJuLrPsNRueS7W6aJ/38x+vLVXuY+xvHaNxbf2GoCezf8A36j/APsSf8w1sLnqczTefJluYoLm5uo5F61sBshItP1cNFYe1f8A3ir/APfE/wCZUe9bB94r5jwuPsrQFhmG4l/Z2M17HdW90tuu3IkTHaCjWdIw0VVZdks9/C06yJFEp2dp+E1bbqybGTZ8vpQD7L1XRv8A7blT96Oda7tpNuuNE37Cq9KSisjyuUoxrStKllHbLlWTXsMs8chuSuwEPDqwoLe5y+YRE/gLzmqRekvKKtd4327yM/ulHxmrHJStySWVRyrjxKI2XC/CTlnlPPKTpTdFbP0L1bgrf5Lp0G3dPhQHwV0S1lzBsns3sESR8Crh9WAJGjSOKuU3E+zdZQ3oJh8IArdZXFDmOTpHa3i2+YrI2KtKy4ricBsBuHHgFXSo440+Wa2qqxjvM9uMoy+WvzWpLCWWWE28HxL6e43ojgkeSCBY1Ri5BGIUDT51cl3vm276BBqSEH4WbxV0tlkyXJcxTMb+OW6uY9mGHrCzDQwwAbTp2uKuTZ9N1uYsfRRR8WPhrm419mSSjRyiqxVK7y23B/ftuTm2oSdJyzNVw3BFn7vTlbnqF9dS2fu9OVueon11lZuQ2iLdsGFD05H2dNQGV0ntG5Tz1dWm9N1b2kVq8EVwsI2UaQaQOKhmitZGLOmk68DhSFvY+gfWNSAg7z3Qvo7yKCKIohiaNR5LKxx8qpxvjcqS0VpbxvwOAcRQPZ7D0G9Y0uz2HoH1jUCpLY7zXlpbm3eKO5QuzjrBqZji3x17PvNcyT288VvDBJbMWUovS2hslW7mFQ9nsPQPrGl2ew9A+saCod/WNxtbYsrfb17WBxx5ddD2281xC88klvDcSXEnWuzrqOGGC9zRUPZ7D0G9Y0uzWHoH1jQVCLreq6ntZbaO3it1mGy7RjTs1X2mYy20ZiCq8ZOODcdEdmsPQb1jS7PYegfWNdJuLqnQiSUlRqpFLmryxtH1Ma7Qw2gNNPOdSt0oI27p007s9h6B9Y0uz2HoH1jXX3Z+I4+1b8IJdX89xLHKQFMXQUahpxoiPN5P+onfU+A0/s9h6DesaXZ7D0D6xpG7OLbUtu0StW5JJx2bBsmbtiSiEk+cxoCWWSaVpZOk2vDVo0VYdnsPQb1jSNvZcCH1jSd2c+p1XAmFqEOmOPEfaH+BQd1ueo211IzrgFUYKNAAqI1WztCpUqVCRUqVKgFSpUqAVKlSoBUqVKgFSpUqAVKlSoBUqVKgFSpUqAVKlSoD/9k=";

        this._logo.width = 160;
        this._logo.height = 200;
    },

    /**
     * Draw loading screen
     */
    draw:function () {
        var logoWidth = (cc.canvas.width - this._logo.width) / 2;
        var logoHeight = (cc.canvas.height - this._logo.height) / 2;
        cc.renderContext.clearRect(0, -cc.canvas.height, cc.canvas.width, cc.canvas.height);
        cc.renderContext.fillStyle = "#202020";
        cc.renderContext.fillRect(0, -cc.canvas.height, cc.canvas.width, cc.canvas.height);
        cc.drawingUtil.drawImage(this._logo, cc.p(logoWidth, logoHeight));
        cc.renderContext.fillStyle = "#b2b4b3";
        cc.renderContext.font = 'Bold 12px Verdana';
        cc.renderContext.textAlign = 'left';
        cc.drawingUtil.fillText("Loading " + cc.Loader.shareLoader().getProgressBar() + "%", logoWidth + 30, logoHeight - 15);
    }
});

/**
 * Shared loader scene
 * @return {cc.LoaderScene}
 */
cc.LoaderScene.shareLoaderScene = function () {
    if (!cc.shareLoaderScene) {
        cc.shareLoaderScene = new cc.LoaderScene();
    }
    return cc.shareLoaderScene;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * <p>
 *   Drawing primitives Utility Class. this class is base class, it contain some render type version: Canvas, WebGL, DOM.<br/>
 *   this class contain some primitive Drawing Method: <br/>
 *     - drawPoint<br/>
 *     - drawLine<br/>
 *     - drawPoly<br/>
 *     - drawCircle<br/>
 *     - drawQuadBezier<br/>
 *     - drawCubicBezier<br/>
 *     You can change the color, width and other property by calling these WebGL API:<br/>
 *     glColor4ub(), glLineWidth(), glPointSize().<br/>
 * </p>
 * @class
 * @extends cc.Class
 * @warning These functions draws the Line, Point, Polygon, immediately. They aren't batched. <br/>
 *   If you are going to make a game that depends on these primitives, I suggest creating a batch.
 */
cc.DrawingPrimitive = cc.Class.extend(/** @lends cc.DrawingPrimitive# */{
    _renderContext:null,

    /**
     * set render context of drawing primitive
     * @param context
     */
    setRenderContext:function (context) {
        this._renderContext = context;
    },

    /**
     * returns render context of drawing primitive
     * @return {CanvasContext}
     */
    getRenderContext:function () {
        return this._renderContext;
    },

    /**
     * Constructor
     * @param {CanvasContext} renderContext
     */
    ctor:function (renderContext) {
        this._renderContext = renderContext;
    },

    /**
     * draws a point given x and y coordinate measured in points
     * @param {cc.Point} point
     */
    drawPoint:function (point) {
        cc.log("DrawingPrimitive.drawPoint() not implement!");
    },

    /**
     * draws an array of points.
     * @param {Array} points point of array
     * @param {Number} numberOfPoints
     */
    drawPoints:function (points, numberOfPoints) {
        cc.log("DrawingPrimitive.drawPoints() not implement!");
    },

    /**
     * draws a line given the origin and destination point measured in points
     * @param {cc.Point} origin
     * @param {cc.Point} destination
     */
    drawLine:function (origin, destination) {
        cc.log("DrawingPrimitive.drawLine() not implement!");
    },

    /**
     * draws a poligon given a pointer to cc.Point coordiantes and the number of vertices measured in points.
     * @param {Array} vertices a pointer to cc.Point coordiantes
     * @param {Number} numOfVertices the number of vertices measured in points
     * @param {Boolean} closePolygon The polygon can be closed or open
     * @param {Boolean} fill The polygon can be closed or open and optionally filled with current color
     */
    drawPoly:function (vertices, numOfVertices, closePolygon, fill) {
        cc.log("DrawingPrimitive.drawPoly() not implement!");
    },

    /**
     * draws a circle given the center, radius and number of segments.
     * @param {cc.Point} center center of circle
     * @param {Number} radius
     * @param {Number} angle angle in radians
     * @param {Number} segments
     * @param {Boolean} drawLineToCenter
     */
    drawCircle:function (center, radius, angle, segments, drawLineToCenter) {
        //WEBGL version
        if ((segments == "undefined") || (segments == 0)) {
            return;
        }
        var additionalSegment = 1;
        if (drawLineToCenter) {
            ++additionalSegment;
        }

        var coef = 2.0 * Math.PI / segments;

        var vertices = [];

        for (var i = 0; i <= segments; i++) {
            var rads = i * coef;
            var j = radius * Math.cos(rads + angle) + center.x;
            var k = radius * Math.sin(rads + angle) + center.y;
            var addPoint = cc.p(j * cc.CONTENT_SCALE_FACTOR(), k * cc.CONTENT_SCALE_FACTOR());
            vertices.push(addPoint);
        }

        if (drawLineToCenter) {
            var lastPoint = cc.p(center.x * cc.CONTENT_SCALE_FACTOR(), center.y * cc.CONTENT_SCALE_FACTOR());
            vertices.push(lastPoint);
        }

        this.drawPoly(vertices, segments + 2, true, false);
    },

    /**
     * draws a quad bezier path
     * @param {cc.Point} origin
     * @param {cc.Point} control
     * @param {cc.Point} destination
     * @param {Number} segments
     */
    drawQuadBezier:function (origin, control, destination, segments) {
        cc.log("DrawingPrimitive.drawQuadBezier() not implement!");
    },

    /**
     * draws a cubic bezier path
     * @param {cc.Point} origin
     * @param {cc.Point} control1
     * @param {cc.Point} control2
     * @param {cc.Point} destination
     * @param {Number} segments
     */
    drawCubicBezier:function (origin, control1, control2, destination, segments) {
        cc.log("DrawingPrimitive.drawCubicBezier() not implement!");
    },

    /**
     * draw a catmull rom line
     * @param {cc.PointArray} points
     * @param {Number} segments
     */
    drawCatmullRom:function (points, segments) {
        cc.log("DrawingPrimitive.drawCardinalSpline() not implement!");
    },

    /**
     * draw a cardinal spline path
     * @param {cc.PointArray} config
     * @param {Number} tension
     * @param {Number} segments
     */
    drawCardinalSpline:function (config, tension, segments) {
        cc.log("DrawingPrimitive.drawCardinalSpline() not implement!");
    }
});

/**
 * Canvas of DrawingPrimitive implement version
 * @class
 * @extends cc.DrawingPrimitive
 */
cc.DrawingPrimitiveCanvas = cc.DrawingPrimitive.extend(/** @lends cc.DrawingPrimitiveCanvas# */{
    /**
     * draws a point given x and y coordinate measured in points
     * @override
     * @param {cc.Point} point
     */
    drawPoint:function (point, size) {
        if (!size) {
            size = 1;
        }
        var newPoint = cc.p(point.x * cc.CONTENT_SCALE_FACTOR(), point.y * cc.CONTENT_SCALE_FACTOR());
        this._renderContext.beginPath();
        this._renderContext.arc(newPoint.x, -newPoint.y, size * cc.CONTENT_SCALE_FACTOR(), 0, Math.PI * 2, false);
        this._renderContext.closePath();
        this._renderContext.fill();
    },

    /**
     * draws an array of points.
     * @override
     * @param {Array} points point of array
     * @param {Number} numberOfPoints
     */
    drawPoints:function (points, numberOfPoints, size) {
        if (points == null) {
            return;
        }
        if (!size) {
            size = 1;
        }

        this._renderContext.beginPath();
        for (var i = 0; i < points.length; i++) {
            this._renderContext.arc(points[i].x * cc.CONTENT_SCALE_FACTOR(), -points[i].y * cc.CONTENT_SCALE_FACTOR(),
                size * cc.CONTENT_SCALE_FACTOR(), 0, Math.PI * 2, false);
        }
        this._renderContext.closePath();
        this._renderContext.fill();
    },

    /**
     * draws a line given the origin and destination point measured in points
     * @override
     * @param {cc.Point} origin
     * @param {cc.Point} destination
     */
    drawLine:function (origin, destination) {
        this._renderContext.beginPath();
        this._renderContext.moveTo(origin.x * cc.CONTENT_SCALE_FACTOR(), -origin.y * cc.CONTENT_SCALE_FACTOR());
        this._renderContext.lineTo(destination.x * cc.CONTENT_SCALE_FACTOR(), -destination.y * cc.CONTENT_SCALE_FACTOR());
        this._renderContext.closePath();
        this._renderContext.stroke();
    },

    /**
     * draws a poligon given a pointer to cc.Point coordiantes and the number of vertices measured in points.
     * @override
     * @param {Array} vertices a pointer to cc.Point coordiantes
     * @param {Number} numOfVertices the number of vertices measured in points
     * @param {Boolean} closePolygon The polygon can be closed or open
     * @param {Boolean} fill The polygon can be closed or open and optionally filled with current color
     */
    drawPoly:function (vertices, numOfVertices, closePolygon, fill) {
        if (fill == 'undefined') {
            fill = false;
        }

        if (vertices == null) {
            return;
        }
        if (vertices.length < 3) {
            throw new Error("Polygon's point must greater than 2");
        }

        var firstPoint = vertices[0];
        this._renderContext.beginPath();
        this._renderContext.moveTo(firstPoint.x * cc.CONTENT_SCALE_FACTOR(), -firstPoint.y * cc.CONTENT_SCALE_FACTOR());
        for (var i = 1; i < vertices.length; i++) {
            this._renderContext.lineTo(vertices[i].x * cc.CONTENT_SCALE_FACTOR(), -vertices[i].y * cc.CONTENT_SCALE_FACTOR());
        }
        if (closePolygon) {
            this._renderContext.closePath();
        }

        if (fill) {
            this._renderContext.fill();
        } else {
            this._renderContext.stroke();
        }
    },

    /**
     * draws a circle given the center, radius and number of segments.
     * @override
     * @param {cc.Point} center center of circle
     * @param {Number} radius
     * @param {Number} angle angle in radians
     * @param {Number} segments
     * @param {Boolean} drawLineToCenter
     */
    drawCircle:function (center, radius, angle, segments, drawLineToCenter) {
        this._renderContext.beginPath();
        var endAngle = angle - Math.PI * 2;
        this._renderContext.arc(0 | center.x, 0 | -(center.y), radius, -angle, -endAngle, false);
        if (drawLineToCenter) {
            this._renderContext.lineTo(0 | center.x, 0 | -(center.y));
        }
        this._renderContext.stroke();
    },

    /**
     * draws a quad bezier path
     * @override
     * @param {cc.Point} origin
     * @param {cc.Point} control
     * @param {cc.Point} destination
     * @param {Number} segments
     */
    drawQuadBezier:function (origin, control, destination, segments) {
        //this is OpenGL Algorithm
        var vertices = [];

        var t = 0.0;
        for (var i = 0; i < segments; i++) {
            var x = Math.pow(1 - t, 2) * origin.x + 2.0 * (1 - t) * t * control.x + t * t * destination.x;
            var y = Math.pow(1 - t, 2) * origin.y + 2.0 * (1 - t) * t * control.y + t * t * destination.y;
            vertices.push(cc.p(x * cc.CONTENT_SCALE_FACTOR(), y * cc.CONTENT_SCALE_FACTOR()));
            t += 1.0 / segments;
        }
        vertices.push(cc.p(destination.x * cc.CONTENT_SCALE_FACTOR(), destination.y * cc.CONTENT_SCALE_FACTOR()));

        this.drawPoly(vertices, segments + 1, false, false);
    },

    /**
     * draws a cubic bezier path
     * @override
     * @param {cc.Point} origin
     * @param {cc.Point} control1
     * @param {cc.Point} control2
     * @param {cc.Point} destination
     * @param {Number} segments
     */
    drawCubicBezier:function (origin, control1, control2, destination, segments) {
        //this is OpenGL Algorithm
        var vertices = [];

        var t = 0;
        for (var i = 0; i < segments; i++) {
            var x = Math.pow(1 - t, 3) * origin.x + 3.0 * Math.pow(1 - t, 2) * t * control1.x + 3.0 * (1 - t) * t * t * control2.x + t * t * t * destination.x;
            var y = Math.pow(1 - t, 3) * origin.y + 3.0 * Math.pow(1 - t, 2) * t * control1.y + 3.0 * (1 - t) * t * t * control2.y + t * t * t * destination.y;
            vertices.push(cc.p(x * cc.CONTENT_SCALE_FACTOR(), y * cc.CONTENT_SCALE_FACTOR()));
            t += 1.0 / segments;
        }
        vertices.push(cc.p(destination.x * cc.CONTENT_SCALE_FACTOR(), destination.y * cc.CONTENT_SCALE_FACTOR()));

        this.drawPoly(vertices, segments + 1, false, false);
    },

    /**
     * draw a CatmullRom curve
     * @override
     * @param {cc.PointArray} points
     * @param {Number} segments
     */
    drawCatmullRom:function (points, segments) {
        this.drawCardinalSpline(points, 0.5, segments);
    },

    /**
     * draw a cardinal spline path
     * @override
     * @param {cc.PointArray} config
     * @param {Number} tension
     * @param {Number} segments
     */
    drawCardinalSpline:function (config, tension, segments) {
        //lazy_init();
        cc.renderContext.strokeStyle = "rgba(255,255,255,1)";
        var points = [];
        var p, lt;
        var deltaT = 1.0 / config.count();

        for (var i = 0; i < segments + 1; i++) {
            var dt = i / segments;

            // border
            if (dt == 1) {
                p = config.count() - 1;
                lt = 1;
            } else {
                p = 0 | (dt / deltaT);
                lt = (dt - deltaT * p) / deltaT;
            }

            // Interpolate
            var newPos = cc.CardinalSplineAt(config.getControlPointAtIndex(p - 1), config.getControlPointAtIndex(p + 0),
                config.getControlPointAtIndex(p + 1), config.getControlPointAtIndex(p + 2), tension, lt);
            points.push(newPos);
        }
        this.drawPoly(points, segments + 1, false, false);
    },

    /**
     * draw an image
     * @override
     * @param {HTMLImageElement|HTMLCanvasElement} image
     * @param {cc.Point} sourcePoint
     * @param {cc.Size} sourceSize
     * @param {cc.Point} destPoint
     * @param {cc.Size} destSize
     */
    drawImage:function (image, sourcePoint, sourceSize, destPoint, destSize) {
        var len = arguments.length;
        switch (len) {
            case 2:
                var height = image.height;
                this._renderContext.drawImage(image, sourcePoint.x, -(sourcePoint.y + height));
                break;
            case 3:
                this._renderContext.drawImage(image, sourcePoint.x, -(sourcePoint.y + sourceSize.height), sourceSize.width, sourceSize.height);
                break;
            case 5:
                this._renderContext.drawImage(image, sourcePoint.x, sourcePoint.y, sourceSize.width, sourceSize.height, destPoint.x, -(destPoint.y + destSize.height),
                    destSize.width, destSize.height);
                break;
            default:
                throw new Error("Argument must be non-nil");
                break;
        }
    },

    /**
     * draw a star
     * @param {CanvasContext} ctx canvas context
     * @param {cc.Point} center
     * @param {Number} radius
     * @param {cc.Color3B|cc.Color4B|cc.Color4F} color
     */
    drawStar:function (ctx, center, radius, color) {
        var context = ctx || this._renderContext;
        context.save();
        context.translate(center.x, -center.y);
        context.rotate(cc.DEGREES_TO_RADIANS(45));
        if (color instanceof cc.Color4F) {
            color = new cc.Color3B(0 | (color.r * 255), 0 | (color.g * 255), 0 | (color.b * 255));
        }
        var colorStr = "rgba(" + color.r + "," + color.g + "," + color.b;
        context.fillStyle = colorStr + ",1)";

        var subRadius = radius / 10;

        context.beginPath();
        context.moveTo(-radius, 0);
        context.lineTo(0, -subRadius);
        context.lineTo(radius, 0);
        context.lineTo(0, subRadius);
        context.lineTo(-radius, 0);
        context.closePath();
        context.fill();

        context.beginPath();
        context.moveTo(0, -radius);
        context.lineTo(-subRadius, 0);
        context.lineTo(0, radius);
        context.lineTo(subRadius, 0);
        context.lineTo(0, -radius);
        context.closePath();
        context.fill();

        var g1 = context.createRadialGradient(0, 0, subRadius, 0, 0, radius);
        g1.addColorStop(0, colorStr + ", 1)");
        g1.addColorStop(0.3, colorStr + ", 0.8)");
        //g1.addColorStop(0.6, colorStr + ", 0.4)");
        g1.addColorStop(1.0, colorStr + ", 0.0)");
        context.fillStyle = g1;
        context.beginPath();
        var startAngle_1 = 0;
        var endAngle_1 = Math.PI * 2;
        context.arc(0, 0, radius, startAngle_1, endAngle_1, false);
        context.closePath();
        context.fill();

        context.restore();
    },

    /**
     * draw a color ball
     * @param {CanvasContext} ctx canvas context
     * @param {cc.Point} center
     * @param {Number} radius
     * @param {cc.Color3B|cc.Color4B|cc.Color4F} color
     */
    drawColorBall:function (ctx, center, radius, color) {
        var context = ctx || this._renderContext;
        if (color instanceof cc.Color4F) {
            color = new cc.Color3B(0 | (color.r * 255), 0 | (color.g * 255), 0 | (color.b * 255));
        }
        var colorStr = "rgba(" + color.r + "," + color.g + "," + color.b;
        var subRadius = radius / 10;

        var g1 = context.createRadialGradient(center.x, -center.y, subRadius, center.x, -center.y, radius);
        g1.addColorStop(0, colorStr + ", 1)");
        g1.addColorStop(0.3, colorStr + ", 0.8)");
        g1.addColorStop(0.6, colorStr + ", 0.4)");
        g1.addColorStop(1.0, colorStr + ", 0.0)");
        context.fillStyle = g1;
        context.beginPath();
        var startAngle_1 = 0;
        var endAngle_1 = Math.PI * 2;
        context.arc(center.x, -center.y, radius, startAngle_1, endAngle_1, false);
        context.closePath();
        context.fill();
    },

    /**
     * fill text
     * @param {String} strText
     * @param {Number} x
     * @param {Number} y
     */
    fillText:function (strText, x, y) {
        this._renderContext.fillText(strText, x, -y);
    }
});
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/


/**
 * Device oriented vertically, home button on the bottom
 * @constant
 * @type Number
 */
cc.ORIENTATION_PORTRAIT = 0;

/**
 * Device oriented vertically, home button on the top
 * @constant
 * @type Number
 */
cc.ORIENTATION_PORTRAIT_UPSIDE_DOWN = 1;

/**
 * Device oriented horizontally, home button on the right
 * @constant
 * @type Number
 */
cc.ORIENTATION_LANDSCAPE_LEFT = 2;

/**
 * Device oriented horizontally, home button on the left
 * @constant
 * @type Number
 */
cc.ORIENTATION_LANDSCAPE_RIGHT = 3;

//engine render type

/**
 * Canvas of render type
 * @constant
 * @type Number
 */
cc.CANVAS = 0;

/**
 * WebGL of render type
 * @constant
 * @type Number
 */
cc.WEBGL = 1;

/**
 * drawing primitive of game engine
 * @type cc.DrawingPrimitive
 */
cc.drawingUtil = null;

/**
 * main Canvas 2D Context of game engine
 * @type CanvasContext
 */
cc.renderContext = null;

/**
 * main Canvas of game engine
 * @type HTMLCanvasElement
 */
cc.canvas = null;

/**
 * This Div element contain all game canvas
 * @type HTMLDivElement
 */
cc.gameDiv = null;

/**
 * current render type of game engine
 * @type Number
 */
cc.renderContextType = cc.CANVAS;

/**
 * save original size of canvas, use for resize canvas
 * @type cc.Size
 */
cc.originalCanvasSize = cc.size(0, 0);

window.requestAnimFrame = (function () {
    return  window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame
})();


if (!window.console) {
    window.console = {};
    window.console.log = function () {
    };
    window.console.assert = function () {
    };
}

/**
 * <p>
 *   setup game main canvas,renderContext,gameDiv and drawingUtil with argument  <br/>
 *   <br/>
 *   can receive follow type of arguemnt: <br/>
 *      - empty: create a canvas append to document's body, and setup other option    <br/>
 *      - string: search the element by document.getElementById(),    <br/>
 *          if this element is HTMLCanvasElement, set this element as main canvas of engine, and set it's ParentNode as cc.gameDiv.<br/>
 *          if this element is HTMLDivElement, set it's ParentNode to cc.gameDiv， and create a canvas as main canvas of engine.   <br/>
 * </p>
 * @function
 * @example
 * //setup with null
 * cc.setup();
 *
 * // setup with HTMLCanvasElement, gameCanvas is Canvas element
 * // declare like this: <canvas id="gameCanvas" width="800" height="450"></canvas>
 * cc.setup("gameCanvas");
 *
 * //setup with HTMLDivElement, gameDiv is Div element
 * // declare like this: <div id="Cocos2dGameContainer" width="800" height="450"></div>
 * cc.setup("Cocos2dGameContainer");
 */
cc.setup = function (el, width, height) {
    var element = cc.$(el) || cc.$('#' + el);
    if (element.tagName == "CANVAS") {
        //it is already a canvas, we wrap it around with a div
        cc.container = cc.$new("DIV");
        cc.canvas = element;
        cc.canvas.parentNode.insertBefore(cc.container, cc.canvas);
        cc.canvas.appendTo(cc.container);
        cc.container.style.width = (width || cc.canvas.width || 480) + "px";
        cc.container.style.height = (height || cc.canvas.height || 320) + "px";
        cc.container.setAttribute('id', 'Cocos2dGameContainer');
    }
    else {//we must make a new canvas and place into this element
        if (element.tagName != "DIV") {
            cc.log("Warning: target element is not a DIV or CANVAS");
        }
        cc.canvas = cc.$new("CANVAS");
        cc.canvas.addClass("gameCanvas");
        cc.canvas.setAttribute("width", width || 480);
        cc.canvas.setAttribute("height", height || 320);
        cc.container = element;
    }
    cc.container.style.position = 'relative';
    cc.container.style.overflow = 'hidden';
    cc.container.top = '100%';
    cc.renderContext = cc.canvas.getContext("2d");
    cc.renderContextType = cc.CANVAS;
    if (cc.renderContextType == cc.CANVAS) {
        cc.renderContext.translate(0, cc.canvas.height);
        cc.drawingUtil = new cc.DrawingPrimitiveCanvas(cc.renderContext);
    }
    cc.originalCanvasSize = cc.size(cc.canvas.width, cc.canvas.height);

    cc.log(cc.ENGINE_VERSION);

    //binding window size
    /*
     cc.canvas.addEventListener("resize", function () {
     if (!cc.firstRun) {
     cc.Director.getInstance().addRegionToDirtyRegion(cc.rect(0, 0, cc.canvas.width, cc.canvas.height));
     }
     }, true);
     */
};

/**
 * Run main loop of game engine
 * @class
 * @extends cc.Class
 */
cc.Application = cc.Class.extend(/** @lends cc.Application# */{
    /**
     * Constructor
     */
    ctor:function () {
        this._animationInterval = 0;
        cc.Assert(!cc._sharedApplication, "CCApplication ctor");
        cc._sharedApplication = this;
    },

    /**
     * Callback by cc.Director for limit FPS.
     * @param {Number} interval The time, which expressed in second, between current frame and next.
     */
    setAnimationInterval:function (interval) {
        this._animationInterval = interval;
    },

    /**
     *  Get status bar rectangle in EGLView window.
     * @param {cc.Rect} rect
     * @deprecated
     */
    statusBarFrame:function (rect) {
        if (rect) {
            // Windows doesn't have status bar.
            rect = cc.rect(0, 0, 0, 0);
        }
    },

    /**
     * Run the message loop.
     * @return {Number}
     */
    run:function () {
        // Initialize instance and cocos2d.
        if (!this.applicationDidFinishLaunching()) {
            return 0;
        }
        // TODO, need to be fixed.
        if (window.requestAnimFrame && this._animationInterval == 1/60) {
            var callback = function () {
                cc.Director.getInstance().mainLoop();
                window.requestAnimFrame(callback);
            };
            cc.log(window.requestAnimFrame);
            window.requestAnimFrame(callback);
        }
        else {
            var callback = function () {
                cc.Director.getInstance().mainLoop();
            };
            setInterval(callback, this._animationInterval * 1000);
        }

    },
    _animationInterval:null
});

/**
 * Get current applicaiton instance.
 * @return {cc.Application}  Current application instance pointer.
 */
cc.Application.sharedApplication = function () {

    cc.Assert(cc._sharedApplication, "sharedApplication");
    return cc._sharedApplication;
};

/**
 * Get current language config
 * @return {Number} Current language config
 */
cc.Application.getCurrentLanguage = function () {
    var ret = cc.LANGUAGE_ENGLISH;

    var currentLang = navigator.language;
    currentLang = currentLang.toLowerCase();
    switch (currentLang) {
        case "zh-cn":
            ret = cc.LANGUAGE_CHINESE;
            break;
        case "fr":
            ret = cc.LANGUAGE_FRENCH;
            break;
        case "it":
            ret = cc.LANGUAGE_ITALIAN;
            break;
        case "de":
            ret = cc.LANGUAGE_GERMAN;
            break;
        case "es":
            ret = cc.LANGUAGE_SPANISH;
            break;
        case "ru":
            ret = cc.LANGUAGE_RUSSIAN;
            break;
    }

    return ret;
};

cc._sharedApplication = null;
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * a SAX Parser
 * @class
 * @extends cc.Class
 */
cc.SAXParser = cc.Class.extend(/** @lends cc.SAXParser# */{
    xmlDoc:null,
    parser:null,
    xmlList:[],
    plist:[],

    /**
     * parse a xml from a string (xmlhttpObj.responseText)
     * @param {String} textxml plist xml contents
     * @return {Array} plist object array
     */
    parse:function (textxml) {
        var textxml = this.getList(textxml);
        // get a reference to the requested corresponding xml file
        if (window.DOMParser) {
            this.parser = new DOMParser();
            this.xmlDoc = this.parser.parseFromString(textxml, "text/xml");
        } else // Internet Explorer (untested!)
        {
            this.xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
            this.xmlDoc.async = "false";
            this.xmlDoc.loadXML(textxml);
        }
        if (this.xmlDoc == null) {
            cc.log("xml " + this.xmlDoc + " not found!");
        }
        var plist = this.xmlDoc.documentElement;
        if (plist.tagName != 'plist') {
            throw "Not a plist file"
        }
        // Get first real node
        var node = null;
        for (var i = 0, len = plist.childNodes.length; i < len; i++) {
            node = plist.childNodes[i];
            if (node.nodeType == 1) {
                break
            }
        }
        this.plist = this._parseNode(node);
        return this.plist;
    },

    /**
     * parse a tilemap xml from a string (xmlhttpObj.responseText)
     * @param  {String} textxml  tilemap xml content
     * @return {Document} xml document
     */
    tmxParse:function (textxml) {
        var textxml = this.getList(textxml);
        // get a reference to the requested corresponding xml file
        if (window.DOMParser) {
            this.parser = new DOMParser();
            this.xmlDoc = this.parser.parseFromString(textxml, "text/xml");
        } else // Internet Explorer (untested!)
        {
            this.xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
            this.xmlDoc.async = "false";
            this.xmlDoc.loadXML(textxml);
        }
        if (this.xmlDoc == null) {
            cc.log("xml " + this.xmlDoc + " not found!");
        }
        return this.xmlDoc;
    },

    _parseNode:function (node) {
        var data = null;
        switch (node.tagName) {
            case 'dict':
                data = this._parseDict(node);
                break;
            case 'array':
                data = this._parseArray(node);
                break;
            case 'string':
                // FIXME - This needs to handle Firefox's 4KB nodeValue limit
                data = node.firstChild.nodeValue;
                break;
            case 'false':
                data = false;
                break;
            case 'true':
                data = true;
                break;
            case 'real':
                data = parseFloat(node.firstChild.nodeValue);
                break;
            case 'integer':
                data = parseInt(node.firstChild.nodeValue, 10);
                break;
        }

        return data;
    },

    _parseArray:function (node) {
        var data = [];
        for (var i = 0, len = node.childNodes.length; i < len; i++) {
            var child = node.childNodes[i];
            if (child.nodeType != 1) {
                continue;
            }
            data.push(this._parseNode(child));
        }
        return data;
    },

    _parseDict:function (node) {
        var data = {};

        var key = null;
        for (var i = 0, len = node.childNodes.length; i < len; i++) {
            var child = node.childNodes[i];
            if (child.nodeType != 1) {
                continue;
            }

            // Grab the key, next noe should be the value
            if (child.tagName == 'key') {
                key = child.firstChild.nodeValue;
            } else {
                // Parse the value node
                data[key] = this._parseNode(child);
            }
        }
        return data;
    },

    /**
     * Preload plist file
     * @param {String} filePath
     */
    preloadPlist:function (filePath) {
        if (window.XMLHttpRequest) {
            // for IE7+, Firefox, Chrome, Opera, Safari brower
            var xmlhttp = new XMLHttpRequest();
            // is xml file?
            if (xmlhttp.overrideMimeType)
                xmlhttp.overrideMimeType('text/xml');
        } else {
            // for IE6, IE5 brower
            xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
        }
        if (xmlhttp != null) {
            // load xml
            xmlhttp.open("GET", filePath, false);
            xmlhttp.send(null);
            this.xmlList[filePath] = xmlhttp.responseText;
            cc.Loader.shareLoader().onResLoaded();
        } else {
            alert("Your browser does not support XMLHTTP.");
        }
    },

    /**
     * get filename from filepath
     * @param {String} filePath
     * @return {String}
     */
    getName:function (filePath) {
        var startPos = filePath.lastIndexOf("/", filePath.length) + 1;
        var endPos = filePath.lastIndexOf(".", filePath.length);
        return filePath.substring(startPos, endPos);
    },

    /**
     * get file extension name from filepath
     * @param {String} filePath
     * @return {String}
     */
    getExt:function (filePath) {
        var startPos = filePath.lastIndexOf(".", filePath.length) + 1;
        return filePath.substring(startPos, filePath.length);
    },

    /**
     * get value by key from xmlList
     * @param {String} key
     * @return {String} xml content
     */
    getList:function (key) {
        if (this.xmlList != null) {
            return this.xmlList[key];
        } else {
            return null;
        }
    }
});

/**
 * get a singleton SAX parser
 * @function
 * @return {cc.SAXParser}
 */
cc.SAXParser.shareParser = function () {
    if (!cc.shareParser) {
        cc.shareParser = new cc.SAXParser();
    }
    return cc.shareParser;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * Controller of Game Application
 * @class
 * @extends cc.Class
 */
cc.AppController = cc.Class.extend(/** @lends cc.AppController# */{
    /**
     * did something when Finish Launching
     * @return {Boolean}
     */
    didFinishLaunchingWithOptions:function () {
        // Override point for customization after application launch.
        //var app = new cc.AppDelegate();
        cc.Application.sharedApplication().run();

        return true;
    },

    /**
     * <p>
     *  Sent when the application is about to move from active to inactive state. <br/>
     *  This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) <br/>
     *  or when the user quits the application and it begins the transition to the background state.     <br/>
     *  Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. <br/>
     *  Games should use this method to pause the game.
     * </p>
     */
    applicationWillResignActive:function () {
        cc.Director.getInstance().pause();
    },

    /**
     * <p>
     * Restart any tasks that were paused (or not yet started) while the application was inactive. <br/>
     * If the application was previously in the background, optionally refresh the user interface.
     * </p>
     */
    applicationDidBecomeActive:function () {
        cc.Director.getInstance().resume();
    },

    /**
     * <p>
     *   Use this method to release shared resources, save user data, invalidate timers, and store enough application state information <br/>
     *   to restore your application to its current state in case it is terminated later.<br/>
     *   If your application supports background execution, called instead of applicationWillTerminate: when the user quits.
     * </p>
     */
    applicationDidEnterBackground:function () {
        cc.Application.sharedApplication().applicationDidEnterBackground();
    },

    /**
     * <p>
     *     Called as part of  transition from the background to the inactive state: <br/>
     *      here you can undo many of the changes made on entering the background.
     * </p>
     */
    applicationWillEnterForeground:function () {
        cc.Application.sharedApplication().applicationWillEnterForeground();
    },

    /**
     * Called when the application is about to terminate. See also applicationDidEnterBackground.
     */
    applicationWillTerminate:function () {
    }
});

/**
 * Return Controller of Game Application
 * @return {cc.AppController}
 */
cc.AppController.shareAppController = function () {
    if (cc.sharedAppController == null) {
        cc.sharedAppController = new cc.AppController();
    }
    cc.Assert(cc.sharedAppController, "shareAppController");
    return cc.sharedAppController;
};

/**
 * cocos2d application instance
 * @type cc.AppController
 */
cc.sharedAppController = null;
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/


/**
 * default size for font size
 * @constant
 * @type Number
 */
cc.ITEM_SIZE = 32;

cc._fontSize = cc.ITEM_SIZE;
cc._fontName = "Arial";
cc._fontNameRelease = false;

/**
 * default tag for current item
 * @constant
 * @type Number
 */
cc.CURRENT_ITEM = 0xc0c05001;
/**
 * default tag for zoom action tag
 * @constant
 * @type Number
 */
cc.ZOOM_ACTION_TAG = 0xc0c05002;
/**
 * default tag for normal
 * @constant
 * @type Number
 */
cc.NORMAL_TAG = 8801;

/**
 * default selected tag
 * @constant
 * @type Number
 */
cc.SELECTED_TAG = 8802;

/**
 * default disabled tag
 * @constant
 * @type Number
 */
cc.DISABLE_TAG = 8803;

/**
 * Subclass cc.MenuItem (or any subclass) to create your custom cc.MenuItem objects.
 * @class
 * @extends cc.Node
 */
cc.MenuItem = cc.Node.extend(/** @lends cc.MenuItem# */{
    _listener:null,
    _selector:null,
    _isSelected:false,

    /**
     * MenuItem is selected
     * @return {Boolean}
     */
    isSelected:function () {
        return this._isSelected;
    },
    _isEnabled:false,

    /**
     * MenuItem is Enabled
     * @return {Boolean}
     */
    isEnabled:function () {
        return this._isEnabled;
    },

    /**
     * set enable value of MenuItem
     * @param {Boolean} enable
     */
    setEnabled:function (enable) {
        this._isEnabled = enable;
    },

    /**
     * @param {cc.Node} rec
     * @param {function|String} selector
     * @return {Boolean}
     */
    initWithCallback:function (rec, selector) {
        this.setAnchorPoint(cc.p(0.5, 0.5));
        this._listener = rec;
        this._selector = selector;
        this._isEnabled = true;
        this._isSelected = false;
        return true;
    },

    /**
     * return rect value of cc.MenuItem
     * @return {cc.Rect}
     */
    rect:function () {
        return cc.rect(this._position.x - this._contentSize.width * this._anchorPoint.x,
            this._position.y - this._contentSize.height * this._anchorPoint.y,
            this._contentSize.width, this._contentSize.height);
    },

    /**
     * same as setIsSelected(true)
     */
    selected:function () {
        this._isSelected = true;
    },

    /**
     * same as setIsSelected(false)
     */
    unselected:function () {
        this._isSelected = false;
    },

    /**
     * @param {cc.Node} rec
     * @param {function|String} selector
     */
    setCallback:function (rec, selector) {
        this._listener = rec;
        this._selector = selector;
    },

    /**
     * call the selector with target
     */
    activate:function () {
        if (this._isEnabled) {
            if (this._listener && (typeof(this._selector) == "string")) {
                this._listener[this._selector](this);
            } else if (this._listener && (typeof(this._selector) == "function")) {
                this._selector.call(this._listener, this);
            }
        }
    }
});

/**
 * creates an empty menu item with target and callback<br/>
 * Not recommended to use the base class, should use more defined menu item classes
 * @param {cc.Node} rec target
 * @param {function|String} selector callback
 * @return {cc.MenuItem}
 */
cc.MenuItem.create = function (rec, selector) {
    var ret = new cc.MenuItem();
    ret.initWithCallback(rec, selector);
    return ret;
};


/**
 *  Any cc.Node that supports the cc.LabelProtocol protocol can be added.<br/>
 * Supported nodes:<br/>
 * - cc.BitmapFontAtlas<br/>
 * - cc.LabelAtlas<br/>
 * - cc.LabelTTF<br/>
 * @class
 * @extends cc.MenuItem
 */
cc.MenuItemLabel = cc.MenuItem.extend(/** @lends cc.MenuItemLabel# */{

    /**
     * this identifies that this object have implemented RGBAProtocol
     * @type Boolean
     */
    RGBAProtocol:true,

    _disabledColor:new cc.Color3B(),

    /**
     * @return {cc.Color3B}
     */
    getDisabledColor:function () {
        return this._disabledColor;
    },

    /**
     * @param {cc.Color3B} color
     */
    setDisabledColor:function (color) {
        this._disabledColor = color;
    },
    _label:null,

    /**
     * return label of MenuItemLabel
     * @return {cc.Node}
     */
    getLabel:function () {
        return this._label;
    },

    /**
     * @param {cc.Node} label
     */
    setLabel:function (label) {
        if (label) {
            this.addChild(label);
            label.setAnchorPoint(cc.p(0, 0));
            this.setContentSize(label.getContentSize());
        }

        if (this._label) {
            this.removeChild(this._label, true);
        }

        this._label = label;
    },
    _orginalScale:0,

    /**
     * @param {Boolean} enabled
     */
    setEnabled:function (enabled) {
        if (this._isEnabled != enabled) {
            if (!enabled) {
                this._colorBackup = this._label.getColor();
                this._label.setColor(this._disabledColor);
            }
            else {
                this._label.setColor(this._colorBackup);
            }
        }
        this._super(enabled);
    },

    /**
     * @param {Number} opacity from 0-255
     */
    setOpacity:function (opacity) {
        this._label.setOpacity(opacity);
    },

    /**
     * @return {Number}
     */
    getOpacity:function () {
        return this._label.getOpacity();
    },

    /**
     * @param {cc.Color3B} color
     */
    setColor:function (color) {
        this._label.setColor(color);
    },

    /**
     * @return {cc.Color3B}
     */
    getColor:function () {
        return this._label.getColor
    },

    setOpacityModifyRGB:function (value) {
    },

    isOpacityModifyRGB:function () {
    },

    /**
     * @param {cc.Node} label
     * @param {cc.Node} target
     * @param {function|String} selector
     * @return {Boolean}
     */
    initWithLabel:function (label, target, selector) {
        this.initWithCallback(target, selector);
        this._originalScale = 1.0;
        this._colorBackup = cc.white();
        this._disabledColor = cc.c3b(126, 126, 126);
        this.setLabel(label);
        return true;
    },

    /**
     * @param {String} label
     */
    setString:function (label) {
        this._label.setString(label);
        this.setContentSize(this._label.getContentSize());
    },

    /**
     * activate the menu item
     */
    activate:function () {
        if (this._isEnabled) {
            this.stopAllActions();
            this.setScale(this._originalScale);
            this._super();
        }
    },

    /**
     * menu item is selected (runs callback)
     */
    selected:function () {
        if (this._isEnabled) {
            this._super();

            var action = this.getActionByTag(cc.ZOOM_ACTION_TAG);
            if (action) {
                this.stopAction(action);
            } else {
                this._originalScale = this.getScale();
            }

            var zoomAction = cc.ScaleTo.create(0.1, this._originalScale * 1.2);
            zoomAction.setTag(cc.ZOOM_ACTION_TAG);
            this.runAction(zoomAction);
        }
    },

    /**
     * menu item goes back to unselected state
     */
    unselected:function () {
        if (this._isEnabled) {
            this._super();
            this.stopActionByTag(cc.ZOOM_ACTION_TAG);
            var zoomAction = cc.ScaleTo.create(0.1, this._originalScale);
            zoomAction.setTag(cc.ZOOM_ACTION_TAG);
            this.runAction(zoomAction);
        }
    }
});

/**
 * @param {cc.Node} label
 * @param {cc.Node|Null} target
 * @param {function|String|Null} selector
 * @return {cc.MenuItemLabel}
 */
cc.MenuItemLabel.create = function (label, target, selector) {
    var ret = new cc.MenuItemLabel();
    ret.initWithLabel(label, target, selector);
    return ret;
};

/**
 * Helper class that creates a MenuItemLabel class with a LabelAtlas
 * @class
 * @extends cc.MenuItemLabel
 */
cc.MenuItemAtlasFont = cc.MenuItemLabel.extend(/** @lends cc.MenuItemAtlasFont# */{

    /**
     * @param {String} value
     * @param {String} charMapFile
     * @param {Number} itemWidth
     * @param {Number} itemHeight
     * @param {String} startCharMap a single character
     * @param {cc.Node|Null} target
     * @param {function|String|Null} selector
     * @return {Boolean}
     */
    initWithString:function (value, charMapFile, itemWidth, itemHeight, startCharMap, target, selector) {
        cc.Assert(value != null && value.length != 0, "value length must be greater than 0");
        var label = new cc.LabelAtlas();
        label.initWithString(value, charMapFile, itemWidth, itemHeight, startCharMap);
        if (this.initWithLabel(label, target, selector)) {
            // do something ?
        }
        return true;
    }
});

/**
 * create menu item from string with font
 * @param {String} value the text to display
 * @param {String} charMapFile the character map file
 * @param {Number} itemWidth
 * @param {Number} itemHeight
 * @param {String} startCharMap a single character
 * @param {cc.Node|Null} target
 * @param {function|String|Null} selector
 * @return {cc.MenuItemAtlasFont}
 * @example
 * // Example
 * var item = cc.MenuItemAtlasFont.create('text to display', 'font.fnt', 12, 32, ' ')
 *
 * //OR
 * var item = cc.MenuItemAtlasFont.create('text to display', 'font.fnt', 12, 32, ' ', game, game.run)
 */
cc.MenuItemAtlasFont.create = function (value, charMapFile, itemWidth, itemHeight, startCharMap, target, selector) {
    var ret = new cc.MenuItemAtlasFont();
    ret.initWithString(value, charMapFile, itemWidth, itemHeight, startCharMap, target, selector);
    return ret;
};


/**
 * Helper class that creates a CCMenuItemLabel class with a Label
 * @class
 * @extends cc.MenuItemLabel
 */
cc.MenuItemFont = cc.MenuItemLabel.extend(/** @lends cc.MenuItemFont# */{

    /**
     * @param {String} value text for the menu item
     * @param {cc.Node} target
     * @param {function|String} selector
     * @return {Boolean}
     */
    initWithString:function (value, target, selector) {
        cc.Assert(value != null && value.length != 0, "Value length must be greater than 0");

        this._fontName = cc._fontName;
        this._fontSize = cc._fontSize;

        var label = cc.LabelTTF.create(value, this._fontName, this._fontSize);
        if (this.initWithLabel(label, target, selector)) {
            // do something ?
        }
        return true;
    },

    /**
     * @param {Number} s
     */
    setFontSizeObj:function (s) {
        this._fontSize = s;
        this._recreateLabel();
    },

    /**
     *
     * @return {Number}
     */
    fontSizeObj:function () {
        return this._fontSize;
    },

    /**
     * @param {String} name
     */
    setFontNameObj:function (name) {
        this._fontName = name;
        this._recreateLabel();
    },

    /**
     * @return {String}
     */
    fontNameObj:function () {
        return this._fontName;
    },
    _recreateLabel:function () {
        var label = cc.LabelTTF.create(this._label.getString(),
            this._fontName, this._fontSize);
        this.setLabel(label);
    },
    _fontSize:0,
    _fontName:''
});

/**
 * a shared function to set the fontSize for menuitem font
 * @param {Number} fontSize
 */
cc.MenuItemFont.setFontSize = function (fontSize) {
    cc._fontSize = fontSize;
};

/**
 * a shared function to get the font size for menuitem font
 * @return {Number}
 */
cc.MenuItemFont.fontSize = function () {
    return cc._fontSize;
};

/**
 * a shared function to set the fontsize for menuitem font
 * @param name
 */
cc.MenuItemFont.setFontName = function (name) {
    if (cc._fontNameRelease) {
        cc._fontName = '';
    }
    cc._fontName = name;
    cc._fontNameRelease = true;
};

/**
 * a shared function to get the font name for menuitem font
 * @return {String}
 */
cc.MenuItemFont.fontName = function () {
    return cc._fontName
};

/**
 * create a menu item from string
 * @param {String} value the text to display
 * @param {cc.Node|Null} target the target to run callback
 * @param {String|function|Null} selector the callback to run, either in function name or pass in the actual function
 * @return {cc.MenuItemFont}
 * @example
 * // Example
 * var item = cc.MenuItemFont.create("Game start", Game, 'start')
 * //creates a menu item from string "Game start", and when clicked, it will run Game.start()
 *
 * var item = cc.MenuItemFont.create("Game start", Game, game.start)//same as above
 *
 * var item = cc.MenuItemFont.create("i do nothing")//create a text menu item that does nothing
 *
 * //you can set font size and name before or after
 * cc.MenuItemFont.setFontName('my Fancy Font');
 * cc.MenuItemFont.setFontSize(62);
 */
cc.MenuItemFont.create = function (value, target, selector) {
    var ret = new cc.MenuItemFont();
    ret.initWithString(value, target, selector);
    return ret;
};


/**
 * CCMenuItemSprite accepts CCNode<CCRGBAProtocol> objects as items.<br/>
 The images has 3 different states:<br/>
 - unselected image<br/>
 - selected image<br/>
 - disabled image<br/>
 * @class
 * @extends cc.MenuItem
 */
cc.MenuItemSprite = cc.MenuItem.extend(/** @lends cc.MenuItemSprite# */{
    /**
     * identifies that this class implements RGBAProtocol methods
     */
    RGBAProtocol:true,
    _normalImage:null,

    /**
     * @return {cc.Node}
     */
    getNormalImage:function () {
        return this._normalImage;
    },

    /**
     * @param {cc.Node} normalImage
     */
    setNormalImage:function (normalImage) {
        if (this._normalImage == normalImage) {
            return;
        }
        if (normalImage) {
            this.addChild(normalImage, 0, cc.NORMAL_TAG);
            normalImage.setAnchorPoint(cc.p(0, 0));
        }
        if (this._normalImage) {
            this.removeChild(this._normalImage, true);
        }

        this._normalImage = normalImage;
        this.setContentSize(this._normalImage.getContentSize());
        this._updateImagesVisibility();
    },
    _selectedImage:null,

    /**
     * @return {cc.Node}
     */
    getSelectedImage:function () {
        return this._selectedImage;
    },

    /**
     * @param {cc.Node} selectedImage
     */
    setSelectedImage:function (selectedImage) {
        if (this._selectedImage == selectedImage)
            return;

        if (selectedImage) {
            this.addChild(selectedImage, 0, cc.SELECTED_TAG);
            selectedImage.setAnchorPoint(cc.p(0, 0));
        }

        if (this._selectedImage) {
            this.removeChild(this._selectedImage, true);
        }

        this._selectedImage = selectedImage;
        this._updateImagesVisibility();
    },
    _disabledImage:null,

    /**
     * @return {cc.Sprite}
     */
    getDisabledImage:function () {
        return this._disabledImage;
    },

    /**
     * @param {cc.Sprite} disabledImage
     */
    setDisabledImage:function (disabledImage) {
        if (this._disabledImage == disabledImage)
            return;

        if (disabledImage) {
            this.addChild(disabledImage, 0, cc.DISABLE_TAG);
            disabledImage.setAnchorPoint(cc.p(0, 0));
        }

        if (this._disabledImage) {
            this.removeChild(this._disabledImage, true);
        }

        this._disabledImage = disabledImage;
        this._updateImagesVisibility();
    },

    /**
     * @param {cc.Sprite} normalSprite
     * @param {cc.Sprite} selectedSprite
     * @param {cc.Sprite} disabledSprite
     * @param {cc.Node} target
     * @param {function|String} selector
     * @return {Boolean}
     */
    initWithNormalSprite:function (normalSprite, selectedSprite, disabledSprite, target, selector) {
        this.initWithCallback(target, selector);
        this.setNormalImage(normalSprite);
        this.setSelectedImage(selectedSprite);
        this.setDisabledImage(disabledSprite);
        if (this._normalImage) {
            this.setContentSize(this._normalImage.getContentSize());
        }
        return true;
    },

    /**
     * @param {cc.Color3B} color
     */
    setColor:function (color) {
        this._normalImage.setColor(color);

        if (this._selectedImage) {
            this._selectedImage.setColor(color);
        }

        if (this._disabledImage) {
            this._disabledImage.setColor(color);
        }
    },

    /**
     * @return {cc.Color3B}
     */
    getColor:function () {
        return this._normalImage.getColor();
    },

    /**
     * @param {Number} opacity 0 - 255
     */
    setOpacity:function (opacity) {
        this._normalImage.setOpacity(opacity);

        if (this._selectedImage) {
            this._selectedImage.setOpacity(opacity);
        }

        if (this._disabledImage) {
            this._disabledImage.setOpacity(opacity);
        }
    },

    /**
     * @return {Number} opacity from 0 - 255
     */
    getOpacity:function () {
        return this._normalImage.getOpacity();
    },

    /**
     * menu item is selected (runs callback)
     */
    selected:function () {
        this._super();
        if (this._normalImage) {
            if (this._disabledImage) {
                this._disabledImage.setVisible(false);
            }

            if (this._selectedImage) {
                this._normalImage.setVisible(false);
                this._selectedImage.setVisible(true);
            }
            else {
                this._normalImage.setVisible(true);
            }
        }
    },

    /**
     * menu item goes back to unselected state
     */
    unselected:function () {
        this._super();

        if (this._normalImage) {
            this._normalImage.setVisible(true);

            if (this._selectedImage) {
                this._selectedImage.setVisible(false);
            }

            if (this._disabledImage) {
                this._disabledImage.setVisible(false);
            }
        }
    },

    /**
     * @param {Boolean} bEnabled
     */
    setEnabled:function (bEnabled) {
        if (this._isEnabled != bEnabled) {
            this._super(bEnabled);
            this._updateImagesVisibility();
        }
    },

    setOpacityModifyRGB:function (value) {
    },

    isOpacityModifyRGB:function () {
        return false;
    },

    _updateImagesVisibility:function () {
        if (this._isEnabled) {
            if (this._normalImage)
                this._normalImage.setVisible(true);
            if (this._selectedImage)
                this._selectedImage.setVisible(false);
            if (this._disabledImage)
                this._disabledImage.setVisible(false);
        } else {
            if (this._disabledImage) {
                if (this._normalImage)
                    this._normalImage.setVisible(false);
                if (this._selectedImage)
                    this._selectedImage.setVisible(false);
                if (this._disabledImage)
                    this._disabledImage.setVisible(true);
            } else {
                if (this._normalImage)
                    this._normalImage.setVisible(true);
                if (this._selectedImage)
                    this._selectedImage.setVisible(false);
                if (this._disabledImage)
                    this._disabledImage.setVisible(false);
            }
        }
    }
});

/**
 * create a menu item from sprite
 * @param {Image} normal normal state image
 * @param {Image|Null} selected selected state image
 * @param {Image|cc.Node|Null} three disabled state image OR target node
 * @param {String|function|cc.Node|Null} four callback function name in string or actual function, OR target Node
 * @param {String|function|Null} five callback function name in string or actual function
 * @return {cc.MenuItemSprite}
 * @example
 * // Example
 * var item = cc.MenuItemSprite.create(normalImage)//create a menu item from a sprite with no functionality
 *
 * var item = cc.MenuItemSprite.create(normalImage, selectedImage)//create a menu Item, nothing will happen when clicked
 *
 * var item = cc.MenuItemSprite.create(normalImage, SelectedImage, disabledImage)//same above, but with disabled state image
 *
 * var item = cc.MenuItemSprite.create(normalImage, SelectedImage, targetNode, 'callback')//create a menu item, when clicked runs targetNode.callback()
 *
 * var item = cc.MenuItemSprite.create(normalImage, SelectedImage, disabledImage, targetNode, targetNode.callback)
 * //same as above, but with disabled image, and passing in callback function
 */
cc.MenuItemSprite.create = function (normalSprite, selectedSprite, three, four, five) {
    var len = arguments.length;
    var normalSprite = arguments[0], selectedSprite = arguments[1], disabledImage, target, callback;
    var ret = new cc.MenuItemSprite();
    //when you send 4 arguments, five is undefined
    if (len == 5) {
        disabledImage = arguments[2], target = arguments[3], callback = arguments[4]
    }
    else if (len == 4) {
        target = arguments[2], callback = arguments[3];
    }
    else if (len <= 3) {
        disabledImage = arguments[2];
    }
    ret.initWithNormalSprite(normalSprite, selectedSprite, disabledImage, target, callback);
    return ret;
};


/**
 * cc.MenuItemImage accepts images as items.<br/>
 * The images has 3 different states:<br/>
 * - unselected image<br/>
 * - selected image<br/>
 * - disabled image<br/>
 * <br/>
 * For best results try that all images are of the same size<br/>
 * @class
 * @extends cc.MenuItemSprite
 */
cc.MenuItemImage = cc.MenuItemSprite.extend(/** @lends cc.MenuItemImage# */{
    /**
     * sets the sprite frame for the normal image
     * @param {cc.SpriteFrame} frame
     */
    setNormalSpriteFrame:function (frame) {
        this.setNormalImage(cc.Sprite.createWithSpriteFrameName(frame));
    },

    /**
     * sets the sprite frame for the selected image
     * @param {cc.SpriteFrame} frame
     */
    setSelectedSpriteFrame:function (frame) {
        this.setSelectedImage(cc.Sprite.createWithSpriteFrameName(frame));
    },

    /**
     * sets the sprite frame for the disabled image
     * @param {cc.SpriteFrame} frame
     */
    setDisabledSpriteFrame:function (frame) {
        this.setDisabledImage(cc.Sprite.createWithSpriteFrameName(frame));
    },

    /**
     * @return {Boolean}
     */
    initWithNormalImage:function (normalImage, selectedImage, disabledImage, target, selector) {
        var normalSprite = null;
        var selectedSprite = null;
        var disabledSprite = null;

        if (normalImage) {
            normalSprite = cc.Sprite.create(normalImage);
        }
        if (selectedImage) {
            selectedSprite = cc.Sprite.create(selectedImage);
        }
        if (disabledImage) {
            disabledSprite = cc.Sprite.create(disabledImage);
        }
        return this.initWithNormalSprite(normalSprite, selectedSprite, disabledSprite, target, selector);
    }
});

/**
 * creates a new menu item image
 * @param {String} normalImage file name for normal state
 * @param {String} selectedImage image for selected state
 * @param {String|cc.Node} three Disabled image OR target
 * @param {cc.Node|String|function|Null} four cc.Node target to run callback when clicked OR the callback
 * @param {String|function|Null} five callback function, either name in string, or pass the whole function
 * @return {cc.MenuItemImage}
 * @example
 * // Example
 * var item = cc.MenuItemImage.create('normal.png', 'selected.png', gameScene, 'run')
 * //create a dom menu item with normal and selected state, when clicked it will run the run function from gameScene object
 *
 * var item = cc.MenuItemImage.create('normal.png', 'selected.png', 'disabled.png',  gameScene, gameScene.run)
 * //same as above, but pass in the actual function and disabled image
 */
cc.MenuItemImage.create = function (normalImage, selectedImage, three, four, five) {
    if (arguments.length == 0) {
        return cc.MenuItemImage.create(null, null, null, null, null);
    }
    if (arguments.length == 4) {
        return cc.MenuItemImage.create(normalImage, selectedImage, null, three, four);
    }
    var ret = new cc.MenuItemImage();
    if (ret.initWithNormalImage(normalImage, selectedImage, three, four, five)) {
        return ret;
    }
    return null;
};


/**
 * A simple container class that "toggles" it's inner items<br/>
 * The inner items can be any MenuItem
 * @class
 * @extends cc.MenuItem
 */
cc.MenuItemToggle = cc.MenuItem.extend(/** @lends cc.MenuItemToggle# */{

    /**
     * this identifies this class implements RGBAProtocol methods
     */
    RGBAProtocol:true,
    _opacity:0,

    /**
     * @return {Number}
     */
    getOpacity:function () {
        return this._opacity;
    },

    /**
     * @param {Number} Opacity
     */
    setOpacity:function (Opacity) {
        this._opacity = Opacity;
        if (this._subItems && this._subItems.length > 0) {
            for (var it = 0; it < this._subItems.length; it++) {
                this._subItems[it].setOpacity(Opacity);
            }
        }
    },
    _color:new cc.Color3B(),

    /**
     * @return {cc.Color3B}
     */
    getColor:function () {
        return this._color;
    },

    /**
     * @param {cc.Color3B} Color
     */
    setColor:function (Color) {
        this._color = Color;
        if (this._subItems && this._subItems.length > 0) {
            for (var it = 0; it < this._subItems.length; it++) {
                this._subItems[it].setColor(Color);
            }
        }
    },
    _selectedIndex:0,

    /**
     * @return {Number}
     */
    getSelectedIndex:function () {
        return this._selectedIndex;
    },

    /**
     * @param {Number} SelectedIndex
     */
    setSelectedIndex:function (SelectedIndex) {
        if (SelectedIndex != this._selectedIndex) {
            this._selectedIndex = SelectedIndex;
            var currItem = this.getChildByTag(cc.CURRENT_ITEM);
            if (currItem) {
                currItem.removeFromParentAndCleanup(false);
            }

            var item = this._subItems[this._selectedIndex];
            this.addChild(item, 0, cc.CURRENT_ITEM);
            var s = item.getContentSize();
            this.setContentSize(s);
            item.setPosition(cc.p(s.width / 2, s.height / 2));
        }
    },
    _subItems:[],

    /**
     * similar to get children
     * @return {cc.MenuItem}
     */
    getSubItems:function () {
        return this._subItems;
    },

    /**
     * @param {cc.MenuItem} SubItems
     */
    setSubItems:function (SubItems) {
        this._subItems = SubItems;
    },

    /**
     * @param {cc.Node} args[0] the first item in the args array is a target
     * @param {function|String} args[1] the second item in the args array is the callback
     * @param {cc.MenuItem} args[2+] the rest in the array are cc.MenuItems
     * @return {Boolean}
     */
    initWithCallback:function (args) {
        if (args.length < 2) {
            return false;
        }
        var target = args[0], selector = args[1];
        this._super(target, selector);
        if (args.length == 2) {
            return false;
        }
        this._subItems = [];
        for (var i = 2; i < args.length; i++) {
            if (args[i]) {
                this._subItems.push(args[i]);
            }
        }
        this._selectedIndex = cc.UINT_MAX;
        this.setSelectedIndex(0);
        return true;
    },

    /**
     * @param {cc.MenuItem} item
     * @return {Boolean}
     */
    initWithItem:function (item) {
        this.initWithCallback(null, null);
        this._subItems = [];
        this._subItems.push(item);
        this._selectedIndex = cc.UINT_MAX;
        this.setSelectedIndex(0);
        return true;
    },

    /**
     * @param {cc.MenuItem} args[1+] items
     * @return {Boolean}
     */
    initWithItems:function (args) {
        this.initWithCallback(null, null);
        this._subItems = [];
        for (var i = 0; i < args.length; i++) {
            if (args[i]) {
                this._subItems.push(args[i]);
            }
        }
        this._selectedIndex = cc.UINT_MAX;
        this.setSelectedIndex(0);
        return true;
    },

    /**
     * @param {cc.MenuItem} item
     */
    addSubItem:function (item) {
        this._subItems.push(item);
    },

    /**
     * activate the menu item
     */
    activate:function () {
        // update index
        if (this._isEnabled) {
            var newIndex = (this._selectedIndex + 1) % this._subItems.length;
            this.setSelectedIndex(newIndex);
        }
        this._super();
    },

    /**
     * menu item is selected (runs callback)
     */
    selected:function () {
        this._super();
        this._subItems[this._selectedIndex].selected();
    },

    /**
     * menu item goes back to unselected state
     */
    unselected:function () {
        this._super();
        this._subItems[this._selectedIndex].unselected();
    },

    /**
     * @param {Boolean} enabled
     */
    setEnabled:function (enabled) {
        if (this._isEnabled = enabled) {
            this._super(enabled);

            if (this._subItems && this._subItems.length > 0) {
                for (var it = 0; it < this._subItems.length; it++) {
                    this._subItems[it].setEnabled(enabled);
                }
            }
        }
    },

    /**
     * returns the selected item
     * @return {cc.MenuItem}
     */
    selectedItem:function () {
        return this._subItems[this._selectedIndex];
    },

    setOpacityModifyRGB:function (value) {
    },

    isOpacityModifyRGB:function () {
        return false;
    },
    onEnter:function () {
        this._super();
        this.setSelectedIndex(this._selectedIndex);
    }
});

/**
 * create a simple container class that "toggles" it's inner items<br/>
 * The inner items can be any MenuItem
 * @return {cc.MenuItemToggle}
 * @example
 * // Example
 *
 * //create a toggle item with 2 menu items (which you can then toggle between them later)
 * var toggler = cc.MenuItemToggle.create(this, this.callback, cc.MenuItemFont.create("On"), cc.MenuItemFont.create("Off"))
 * //Note: the first param is the target, the second is the callback function, afterwards, you can pass in any number of menuitems
 *
 * //if you pass only 1 variable, then it must be a cc.MenuItem
 * var notYetToggler = cc.MenuItemToggle.create(cc.MenuItemFont.create("On"));//it is useless right now, until you add more stuff to it
 * notYetToggler.addSubItem(cc.MenuItemFont.create("Off"));
 * //this is useful for constructing a toggler without a callback function (you wish to control the behavior from somewhere else)
 */
cc.MenuItemToggle.create = function (/*Multiple arguments follow*/) {
    var ret = new cc.MenuItemToggle();
    //ret.initWithItems(arguments);
    if (arguments.length == 1) {
        ret.initWithItem(arguments);
    } else {
        ret.initWithCallback(arguments);
    }
    return ret;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * @constant
 * @type Number
 */
cc.MENU_STATE_WAITING = 0;
/**
 * @constant
 * @type Number
 */
cc.MENU_STATE_TRACKING_TOUCH = 1;
/**
 * @constant
 * @type Number
 */
cc.MENU_HANDLER_PRIORITY = -128;
/**
 * @constant
 * @type Number
 */
cc.DEFAULT_PADDING = 5;

/**
 * <p> Features and Limitation:<br/>
 *  - You can add MenuItem objects in runtime using addChild:<br/>
 *  - But the only accecpted children are MenuItem objects</p>
 * @class
 * @extends cc.Layer
 */
cc.Menu = cc.Layer.extend(/** @lends cc.Menu# */{
    RGBAProtocol:true,
    _color:new cc.Color3B(),

    /**
     * @return {cc.Color3B}
     */
    getColor:function () {
        return this._color;
    },

    /**
     * @param {cc.Color3B} color
     */
    setColor:function (color) {
        this._color = color;

        if (this._children && this._children.length > 0) {
            for (var i = 0; i < this._children.length; i++) {
                this._children[i].setColor(this._color);
            }
        }
    },

    _opacity:0,

    /**
     * @return {Number}
     */
    getOpacity:function () {
        return this._opacity;
    },

    /**
     * @param {Number} opa
     */
    setOpacity:function (opa) {
        this._opacity = opa;
        if (this._children && this._children.length > 0) {
            for (var i = 0; i < this._children.length; i++) {
                this._children[i].setOpacity(this._opacity);
            }
        }
    },

    _enabled:false,

    /**
     * return whether or not the menu will receive events
     * @return {Boolean}
     */
    isEnabled:function () {
        return this._enabled;
    },

    /**
     * set whether or not the menu will receive events
     * @param {Boolean} enabled
     */
    setEnabled:function (enabled) {
        this._enabled = enabled;
    },

    _selectedItem:null,

    /**
     * initializes a cc.Menu with it's items
     * @param {Array} args
     * @return {Boolean}
     */
    initWithItems:function (args) {
        var pArray = [];
        if (args) {
            for (var i = 0; i < args.length; i++) {
                if (args[i]) {
                    pArray.push(args[i]);
                }
            }
        }

        return this.initWithArray(pArray);
    },

    /**
     * initializes a cc.Menu with a Array of cc.MenuItem objects
     */
    initWithArray:function (arrayOfItems) {
        if(this.init()){
            this.setTouchEnabled(true);
            this._enabled = true;

            // menu in the center of the screen
            var winSize = cc.Director.getInstance().getWinSize();
            this.ignoreAnchorPointForPosition(true);
            this.setAnchorPoint(cc.p(0.5, 0.5));
            this.setContentSize(winSize);

            this.setPosition(cc.p(winSize.width / 2, winSize.height / 2));

            if(arrayOfItems){
                for(var i = 0; i< arrayOfItems.length; i++){
                    this.addChild(arrayOfItems[i],i);
                }
            }

            this._selectedItem = null;
            this._state = cc.MENU_STATE_WAITING;
            return true;
        }
        return false;
    },

    /**
     * @param {cc.Node} child
     * @param {Number|Null} zOrder
     * @param {Number|Null} tag
     */
    addChild:function (child, zOrder, tag) {
        cc.Assert((child instanceof cc.MenuItem), "Menu only supports MenuItem objects as children");
        this._super(child, zOrder, tag);
    },

    /**
     * align items vertically with default padding
     */
    alignItemsVertically:function () {
        this.alignItemsVerticallyWithPadding(cc.DEFAULT_PADDING);
    },

    /**
     * align items vertically with specified padding
     * @param {Number} padding
     */
    alignItemsVerticallyWithPadding:function (padding) {
        var height = -padding;
        if (this._children && this._children.length > 0) {
            for (var i = 0; i < this._children.length; i++) {
                height += this._children[i].getContentSize().height * this._children[i].getScaleY() + padding;
            }
        }

        var y = height / 2.0;
        if (this._children && this._children.length > 0) {
            for (i = 0; i < this._children.length; i++) {
                this._children[i].setPosition(cc.p(0, y - this._children[i].getContentSize().height * this._children[i].getScaleY() / 2));
                y -= this._children[i].getContentSize().height * this._children[i].getScaleY() + padding;
            }
        }
    },

    /**
     * align items horizontally with default padding
     */
    alignItemsHorizontally:function () {
        this.alignItemsHorizontallyWithPadding(cc.DEFAULT_PADDING);
    },

    /**
     * align items horizontally with specified padding
     * @param {Number} padding
     */
    alignItemsHorizontallyWithPadding:function (padding) {
        var width = -padding;
        if (this._children && this._children.length > 0) {
            for (var i = 0; i < this._children.length; i++) {
                width += this._children[i].getContentSize().width * this._children[i].getScaleX() + padding;
            }
        }

        var x = -width / 2.0;
        if (this._children && this._children.length > 0) {
            for (i = 0; i < this._children.length; i++) {
                this._children[i].setPosition(cc.p(x + this._children[i].getContentSize().width * this._children[i].getScaleX() / 2, 0));
                x += this._children[i].getContentSize().width * this._children[i].getScaleX() + padding;
            }
        }
    },

    /**
     * align items in columns
     * @example
     * // Example
     * menu.alignItemsInColumns(3,2,3)// this will create 3 columns, with 3 items for first column, 2 items for second and 3 for third
     *
     * menu.alignItemsInColumns(3,3)//this creates 2 columns, each have 3 items
     */
    alignItemsInColumns:function (/*Multiple Arguments*/) {
        var rows = [];
        for (var i = 0; i < arguments.length; i++) {
            rows.push(arguments[i]);
        }
        var height = -5;
        var row = 0;
        var rowHeight = 0;
        var columnsOccupied = 0;
        var rowColumns;
        if (this._children && this._children.length > 0) {
            for (i = 0; i < this._children.length; i++) {
                cc.Assert(row < rows.length, "");

                rowColumns = rows[row];
                // can not have zero columns on a row
                cc.Assert(rowColumns, "");

                var tmp = this._children[i].getContentSize().height;
                rowHeight = ((rowHeight >= tmp || isNaN(tmp)) ? rowHeight : tmp);

                ++columnsOccupied;
                if (columnsOccupied >= rowColumns) {
                    height += rowHeight + 5;

                    columnsOccupied = 0;
                    rowHeight = 0;
                    ++row;
                }
            }
        }
        // check if too many rows/columns for available menu items
        cc.Assert(!columnsOccupied, "");
        var winSize = cc.Director.getInstance().getWinSize();

        row = 0;
        rowHeight = 0;
        rowColumns = 0;
        var w = 0.0;
        var x = 0.0;
        var y = (height / 2);

        if (this._children && this._children.length > 0) {
            for (i = 0; i < this._children.length; i++) {
                var child = this._children[i];
                if (rowColumns == 0) {
                    rowColumns = rows[row];
                    w = winSize.width / (1 + rowColumns);
                    x = w;
                }

                var tmp = child.getContentSize().height;
                rowHeight = ((rowHeight >= tmp || isNaN(tmp)) ? rowHeight : tmp);

                child.setPosition(cc.p(x - winSize.width / 2,
                    y - child.getContentSize().height / 2));

                x += w;
                ++columnsOccupied;

                if (columnsOccupied >= rowColumns) {
                    y -= rowHeight + 5;

                    columnsOccupied = 0;
                    rowColumns = 0;
                    rowHeight = 0;
                    ++row;
                }
            }
        }
    },
    /**
     * align menu items in rows
     * @example
     * // Example
     * menu.alignItemsInRows(5,3)//this will align items to 2 rows, first row with 5 items, second row with 3
     *
     * menu.alignItemsInRows(4,4,4,4)//this creates 4 rows each have 4 items
     */
    alignItemsInRows:function (/*Multiple arguments*/) {
        var columns = [];
        for (var i = 0; i < arguments.length; i++) {
            columns.push(arguments[i]);
        }
        var columnWidths = [];
        var columnHeights = [];

        var width = -10;
        var columnHeight = -5;
        var column = 0;
        var columnWidth = 0;
        var rowsOccupied = 0;
        var columnRows;

        if (this._children && this._children.length > 0) {
            for (var i = 0; i < this._children.length; i++) {
                var child = this._children[i];
                // check if too many menu items for the amount of rows/columns
                cc.Assert(column < columns.size(), "");

                columnRows = columns[column];
                // can't have zero rows on a column
                cc.Assert(columnRows, "");

                // columnWidth = fmaxf(columnWidth, [item contentSize].width);
                var tmp = child.getContentSize().width;
                columnWidth = ((columnWidth >= tmp || isNaN(tmp)) ? columnWidth : tmp);

                columnHeight += (child.getContentSize().height + 5);
                ++rowsOccupied;

                if (rowsOccupied >= columnRows) {
                    columnWidths.push(columnWidth);
                    columnHeights.push(columnHeight);
                    width += columnWidth + 10;

                    rowsOccupied = 0;
                    columnWidth = 0;
                    columnHeight = -5;
                    ++column;
                }
            }
        }
        // check if too many rows/columns for available menu items.
        cc.Assert(!rowsOccupied, "");

        var winSize = cc.Director.getInstance().getWinSize();

        column = 0;
        columnWidth = 0;
        columnRows = 0;
        var x = -width / 2;
        var y = 0.0;

        if (this._children && this._children.length > 0) {
            for (var i = 0; i < this._children.length; i++) {
                var child = this._children[i];
                if (columnRows == 0) {
                    columnRows = columns[column];
                    y = columnHeights[column];
                }

                // columnWidth = fmaxf(columnWidth, [item contentSize].width);
                var tmp = child.getContentSize().width;
                columnWidth = ((columnWidth >= tmp || isNaN(tmp)) ? columnWidth : tmp);

                child.setPosition(cc.p(x + columnWidths[column] / 2,
                    y - winSize.height / 2));

                y -= child.getContentSize().height + 10;
                ++rowsOccupied;

                if (rowsOccupied >= columnRows) {
                    x += columnWidth + 5;
                    rowsOccupied = 0;
                    columnRows = 0;
                    columnWidth = 0;
                    ++column;
                }
            }
        }
    },

    /**
     * make the menu clickable
     */
    registerWithTouchDispatcher:function () {
        cc.Director.getInstance().getTouchDispatcher().addTargetedDelegate(this, cc.MENU_HANDLER_PRIORITY, true);
    },

    /**
     * @param {cc.Touch} touch
     * @return {Boolean}
     */
    onTouchBegan:function (touch, e) {
        if (this._state != cc.MENU_STATE_WAITING || !this._isVisible || !this._enabled) {
            return false;
        }

        for (var c = this._parent; c != null; c = c.getParent()) {
            if (!c.isVisible()) {
                return false;
            }
        }

        this._selectedItem = this._itemForTouch(touch);
        if (this._selectedItem) {
            this._state = cc.MENU_STATE_TRACKING_TOUCH;
            this._selectedItem.selected();
            return true;
        }
        return false;
    },

    /**
     * when a touch ended
     */
    onTouchEnded:function (touch, e) {
        cc.Assert(this._state == cc.MENU_STATE_TRACKING_TOUCH, "[Menu onTouchEnded] -- invalid state");
        if (this._selectedItem) {
            this._selectedItem.unselected();
            this._selectedItem.activate();
        }
        this._state = cc.MENU_STATE_WAITING;
    },

    /**
     * touch cancelled
     */
    onTouchCancelled:function (touch, e) {
        cc.Assert(this._state == cc.MENU_STATE_TRACKING_TOUCH, "[Menu onTouchCancelled] -- invalid state");
        if (this._selectedItem) {
            this._selectedItem.unselected();
        }
        this._state = cc.MENU_STATE_WAITING;
    },

    /**
     * touch moved
     * @param {cc.Touch} touch
     */
    onTouchMoved:function (touch, e) {
        cc.Assert(this._state == cc.MENU_STATE_TRACKING_TOUCH, "[Menu onTouchMoved] -- invalid state");
        var currentItem = this._itemForTouch(touch);
        if (currentItem != this._selectedItem) {
            if (this._selectedItem) {
                this._selectedItem.unselected();
            }
            this._selectedItem = currentItem;
            if (this._selectedItem) {
                this._selectedItem.selected();
            }
        }
    },

    /**
     * custom on exit
     */
    onExit:function () {
        if (this._state == cc.MENU_STATE_TRACKING_TOUCH) {
            this._selectedItem.unselected();
            this._state = cc.MENU_STATE_WAITING;
            this._selectedItem = null;
        }

        this._super();
    },

    setOpacityModifyRGB:function (value) {
    },

    isOpacityModifyRGB:function () {
        return false;
    },

    _itemForTouch:function (touch) {
        var touchLocation = touch.getLocation();

        if (this._children && this._children.length > 0) {
            for (var i = 0; i < this._children.length; i++) {
                if (this._children[i].isVisible() && this._children[i].isEnabled()) {
                    var local = this._children[i].convertToNodeSpace(touchLocation);
                    var r = this._children[i].rect();
                    r.origin = cc.p(0,0);
                    if (cc.Rect.CCRectContainsPoint(r, local)) {
                        return this._children[i];
                    }
                }
            }
        }

        return null;
    },
    _state:-1,

    /**
     * set event handler priority. By default it is: kCCMenuTouchPriority
     * @param {Number} newPriority
     */
    setHandlerPriority:function (newPriority) {
        cc.Director.getInstance().getTouchDispatcher().setPriority(newPriority, this);
    }
});

/**
 * create a new menu
 * @return {cc.Menu}
 * @example
 * // Example
 * //there is no limit on how many menu item you can pass in
 * var myMenu = cc.Menu.create(menuitem1, menuitem2, menuitem3);
 */
cc.Menu.create = function (/*Multiple Arguments*/) {
    var ret = new cc.Menu();

    if (arguments.length == 0) {
        ret.initWithItems(null, null);
    } else if (arguments.length == 1) {
        if (arguments[0] instanceof Array) {
            ret.initWithArray(arguments[0]);
            return ret;
        }
    }
    ret.initWithItems(arguments);
    return ret;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 Orthogonal orientation
 * @constant
 * @type Number
 */
cc.TMXOrientationOrtho = 0;

/**
 * Hexagonal orientation
 * @constant
 * @type Number
 */

cc.TMXOrientationHex = 1;

/**
 * Isometric orientation
 * @constant
 * @type Number
 */
cc.TMXOrientationIso = 2;

/**
 * <p>cc.TMXTiledMap knows how to parse and render a TMX map.</p>
 *
 * <p>It adds support for the TMX tiled map format used by http://www.mapeditor.org <br />
 * It supports isometric, hexagonal and orthogonal tiles.<br />
 * It also supports object groups, objects, and properties.</p>
 *
 * <p>Features: <br />
 * - Each tile will be treated as an cc.Sprite<br />
 * - The sprites are created on demand. They will be created only when you call "layer.tileAt(position)" <br />
 * - Each tile can be rotated / moved / scaled / tinted / "opacitied", since each tile is a cc.Sprite<br />
 * - Tiles can be added/removed in runtime<br />
 * - The z-order of the tiles can be modified in runtime<br />
 * - Each tile has an anchorPoint of (0,0) <br />
 * - The anchorPoint of the TMXTileMap is (0,0) <br />
 * - The TMX layers will be added as a child <br />
 * - The TMX layers will be aliased by default <br />
 * - The tileset image will be loaded using the cc.TextureCache <br />
 * - Each tile will have a unique tag<br />
 * - Each tile will have a unique z value. top-left: z=1, bottom-right: z=max z<br />
 * - Each object group will be treated as an cc.MutableArray <br />
 * - Object class which will contain all the properties in a dictionary<br />
 * - Properties can be assigned to the Map, Layer, Object Group, and Object</p>
 *
 * <p>Limitations: <br />
 * - It only supports one tileset per layer. <br />
 * - Embeded images are not supported <br />
 * - It only supports the XML format (the JSON format is not supported)</p>
 *
 * <p>Technical description: <br />
 * Each layer is created using an cc.TMXLayer (subclass of cc.SpriteBatchNode). If you have 5 layers, then 5 cc.TMXLayer will be created, <br />
 * unless the layer visibility is off. In that case, the layer won't be created at all. <br />
 * You can obtain the layers (cc.TMXLayer objects) at runtime by: <br />
 * - map.getChildByTag(tag_number);  // 0=1st layer, 1=2nd layer, 2=3rd layer, etc...<br />
 * - map.layerNamed(name_of_the_layer); </p>
 *
 * <p>Each object group is created using a cc.TMXObjectGroup which is a subclass of cc.MutableArray.<br />
 * You can obtain the object groups at runtime by: <br />
 * - map.objectGroupNamed(name_of_the_object_group); </p>
 *
 * <p>Each object is a cc.TMXObject.</p>
 *
 * <p>Each property is stored as a key-value pair in an cc.MutableDictionary.<br />
 * You can obtain the properties at runtime by: </p>
 *
 * <p>map.propertyNamed(name_of_the_property); <br />
 * layer.propertyNamed(name_of_the_property); <br />
 * objectGroup.propertyNamed(name_of_the_property); <br />
 * object.propertyNamed(name_of_the_property);</p>
 * @class
 * @extends cc.Node
 */
cc.TMXTiledMap = cc.Node.extend(/** @lends cc.TMXTiledMap# */{
    //the map's size property measured in tiles
    _mapSize:cc.SizeZero(),
    _tileSize:cc.SizeZero(),
    _properties:null,
    _objectGroups:null,
    _mapOrientation:null,
    //tile properties
    //todo delete
    _TMXLayers:null,
    _tileProperties:[],

    /**
     * @return {cc.Size}
     */
    getMapSize:function () {
        return this._mapSize;
    },

    /**
     * @param {cc.Size} Var
     */
    setMapSize:function (Var) {
        this._mapSize = Var;
    },

    /**
     * @return {cc.Size}
     */
    getTileSize:function () {
        return this._tileSize;
    },

    /**
     * @param {cc.Size} Var
     */
    setTileSize:function (Var) {
        this._tileSize = Var;
    },

    /**
     * map orientation
     * @return {Number}
     */
    getMapOrientation:function () {
        return this._mapOrientation;
    },

    /**
     * @param {Number} Var
     */
    setMapOrientation:function (Var) {
        this._mapOrientation = Var;
    },

    /**
     * object groups
     * @return {Array}
     */
    getObjectGroups:function () {
        return this._objectGroups;
    },

    /**
     * @param {Array} Var
     */
    setObjectGroups:function (Var) {
        this._objectGroups = Var;
    },

    /**
     * properties
     * @return {object}
     */
    getProperties:function () {
        return this._properties;
    },

    /**
     * @param {object} Var
     */
    setProperties:function (Var) {
        this._properties = Var;
    },

    /**
     * @param {String} tmxFile
     * @return {Boolean}
     * @example
     * //example
     * var map = new cc.TMXTiledMap()
     * map.initWithTMXFile("hello.tmx");
     */
    initWithTMXFile:function (tmxFile,resourcePath) {
        cc.Assert(tmxFile != null && tmxFile.length > 0, "TMXTiledMap: tmx file should not be nil");
        this.setContentSize(cc.SizeZero());
        var mapInfo = cc.TMXMapInfo.create(tmxFile,resourcePath);
        if (!mapInfo) {
            return false;
        }
        cc.Assert(mapInfo.getTilesets().length != 0, "TMXTiledMap: Map not found. Please check the filename.");
        this._buildWithMapInfo(mapInfo);
        return true;
    },

    _buildWithMapInfo:function (mapInfo) {
        this._mapSize = mapInfo.getMapSize();
        this._tileSize = mapInfo.getTileSize();
        this._mapOrientation = mapInfo.getOrientation();
        this._objectGroups = mapInfo.getObjectGroups();
        this._properties = mapInfo.getProperties();
        this._tileProperties = mapInfo.getTileProperties();

        var idx = 0;

        var layers = mapInfo.getLayers();
        if (layers) {
            var layerInfo = null;
            for (var i = 0, len = layers.length; i < len; i++) {
                layerInfo = layers[i];
                if (layerInfo && layerInfo.visible) {
                    var child = this._parseLayer(layerInfo, mapInfo);
                    this.addChild(child, idx, idx);

                    // update content size with the max size
                    var childSize = child.getContentSize();
                    var currentSize = this.getContentSize();
                    currentSize.width = Math.max(currentSize.width, childSize.width);
                    currentSize.height = Math.max(currentSize.height, childSize.height);
                    this.setContentSize(currentSize);

                    idx++;
                }
            }
        }
    },
    /** return the TMXLayer for the specific layer
     * @param {String} layerName
     * @return {cc.TMXLayer}
     */
    layerNamed:function (layerName) {
        cc.Assert(layerName != null && layerName.length > 0, "Invalid layer name!");

        for (var i = 0; i < this._children.length; i++) {
            var layer = this._children[i];
            if (layer) {
                if (layer.getLayerName() == layerName) {
                    return layer;
                }
            }
        }

        // layer not found
        return null;
    },

    /**
     * Return the TMXObjectGroup for the secific group
     * @param {String} groupName
     * @return {cc.TMXObjectGroup}
     */
    objectGroupNamed:function (groupName) {
        cc.Assert(groupName != null && groupName.length > 0, "Invalid group name!");
        if (this._objectGroups) {
            for (var i = 0; i < this._objectGroups.length; i++) {
                var objectGroup = this._objectGroups[i];
                if (objectGroup && objectGroup.getGroupName() == groupName) {
                    return objectGroup;
                }
            }
        }
        // objectGroup not found
        return null;
    },

    /**
     * Return the value for the specific property name
     * @param {String} propertyName
     * @return {String}
     */
    propertyNamed:function (propertyName) {
        return this._properties[propertyName.toString()];
    },

    /**
     * Return properties dictionary for tile GID
     * @param {Number} GID
     * @return {object}
     */
    propertiesForGID:function (GID) {
        return this._tileProperties[GID];
    },

    _parseLayer:function (layerInfo, mapInfo) {
        var tileset = this._tilesetForLayer(layerInfo, mapInfo);
        var layer = cc.TMXLayer.create(tileset, layerInfo, mapInfo);
        // tell the layerinfo to release the ownership of the tiles map.
        layerInfo.ownTiles = false;
        layer.setupTiles();
        return layer;
    },

    _tilesetForLayer:function (layerInfo, mapInfo) {
        var size = layerInfo._layerSize;
        var tilesets = mapInfo.getTilesets();
        if (tilesets) {
            for (var i = tilesets.length - 1; i >= 0; i--) {
                var tileset = tilesets[i];
                if (tileset) {
                    for (var y = 0; y < size.height; y++) {
                        for (var x = 0; x < size.width; x++) {
                            var pos = x + size.width * y;
                            var gid = layerInfo._tiles[pos];
                            if (gid != 0) {
                                // Optimization: quick return
                                // if the layer is invalid (more than 1 tileset per layer) an cc.Assert will be thrown later
                                if (((gid & cc.FlippedMask)>>>0) >= tileset.firstGid) {
                                    return tileset;
                                }
                            }

                        }
                    }
                }
            }
        }

        // If all the tiles are 0, return empty tileset
        cc.log("cocos2d: Warning: TMX Layer " + layerInfo.name + " has no tiles");
        return null;
    }
});

/**
 * Creates a TMX Tiled Map with a TMX file.
 * Implementation cc.TMXTiledMap
 * @param {String} tmxString
 * @param {String} resourcePath
 * @return {cc.TMXTiledMap|null}
 * @example
 * //example
 * var map = cc.TMXTiledMap.create("hello.tmx");
 */
cc.TMXTiledMap.create = function (tmxFile, resourcePath) {
    var ret = new cc.TMXTiledMap();
    if (ret.initWithTMXFile(tmxFile,resourcePath)) {
        return ret;
    }
    return null;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * @constant
 * @type Number
 */
cc.TMXLayerAttribNone = 1 << 0;
/**
 * @constant
 * @type Number
 */
cc.TMXLayerAttribBase64 = 1 << 1;
/**
 * @constant
 * @type Number
 */
cc.TMXLayerAttribGzip = 1 << 2;
/**
 * @constant
 * @type Number
 */
cc.TMXLayerAttribZlib = 1 << 3;

/**
 * @constant
 * @type Number
 */
cc.TMXPropertyNone = 0;

/**
 * @constant
 * @type Number
 */
cc.TMXPropertyMap = 1;

/**
 * @constant
 * @type Number
 */
cc.TMXPropertyLayer = 2;

/**
 * @constant
 * @type Number
 */
cc.TMXPropertyObjectGroup = 3;

/**
 * @constant
 * @type Number
 */
cc.TMXPropertyObject = 4;

/**
 * @constant
 * @type Number
 */
cc.TMXPropertyTile = 5;

/**
 * @constant
 * @type Number
 */
cc.TMXTileHorizontalFlag = 0x80000000;

/**
 * @constant
 * @type Number
 */
cc.TMXTileVerticalFlag = 0x40000000;

/**
 * @constant
 * @type Number
 */
cc.TMXTileDiagonalFlag = 0x20000000;

/**
 * @constant
 * @type Number
 */
cc.FlipedAll = (cc.TMXTileHorizontalFlag | cc.TMXTileVerticalFlag | cc.TMXTileDiagonalFlag) >>> 0;

/**
 * @constant
 * @type Number
 */
cc.FlippedMask = (~(cc.FlipedAll)) >>> 0;

// Bits on the far end of the 32-bit global tile ID (GID's) are used for tile flags

/**
 * <p>cc.TMXLayerInfo contains the information about the layers like: <br />
 * - Layer name<br />
 * - Layer size <br />
 * - Layer opacity at creation time (it can be modified at runtime)  <br />
 * - Whether the layer is visible (if it's not visible, then the CocosNode won't be created) <br />
 *  <br />
 * This information is obtained from the TMX file.</p>
 * @class
 * @extends cc.Class
 */
cc.TMXLayerInfo = cc.Class.extend(/** @lends cc.TMXLayerInfo# */{
    _properties:null,
    name:"",
    _layerSize:null,
    _tiles:[],
    visible:null,
    _opacity:null,
    ownTiles:true,
    _minGID:100000,
    _maxGID:0,
    offset:cc.PointZero(),
    ctor:function () {
        this._properties = [];
    },
    /**
     * @return {Array}
     */
    getProperties:function () {
        return this._properties;
    },

    /**
     * @param {object} Var
     */
    setProperties:function (Var) {
        this._properties.push(Var);
    }
});

/**
 * <p>cc.TMXTilesetInfo contains the information about the tilesets like: <br />
 * - Tileset name<br />
 * - Tileset spacing<br />
 * - Tileset margin<br />
 * - size of the tiles<br />
 * - Image used for the tiles<br />
 * - Image size<br />
 *
 * This information is obtained from the TMX file. </p>
 * @class
 * @extends cc.Class
 */
cc.TMXTilesetInfo = cc.Class.extend(/** @lends cc.TMXTilesetInfo# */{

    /**
     * Tileset name
     */
    name:"",

    /**
     * First grid
     */
    firstGid:0,
    _tileSize:cc.SizeZero(),

    /**
     * Spacing
     */
    spacing:0,

    /**
     *  Margin
     */
    margin:0,

    /**
     * Filename containing the tiles (should be sprite sheet / texture atlas)
     */
    sourceImage:"",

    /**
     * Size in pixels of the image
     */
    imageSize:cc.SizeZero(),

    /**
     * @param {Number} gid
     * @return {cc.Rect}
     */
    rectForGID:function (gid) {
        var rect = cc.RectZero();
        rect.size = this._tileSize;
        gid &= cc.FlippedMask;
        gid = gid - parseInt(this.firstGid);
        var max_x = parseInt((this.imageSize.width - this.margin * 2 + this.spacing) / (this._tileSize.width + this.spacing));
        rect.origin.x = parseInt((gid % max_x) * (this._tileSize.width + this.spacing) + this.margin);
        rect.origin.y = parseInt(parseInt(gid / max_x) * (this._tileSize.height + this.spacing) + this.margin);
        return rect;
    }
});

/**
 * <p>cc.TMXMapInfo contains the information about the map like: <br/>
 *- Map orientation (hexagonal, isometric or orthogonal)<br/>
 *- Tile size<br/>
 *- Map size</p>
 *
 * <p>And it also contains: <br/>
 * - Layers (an array of TMXLayerInfo objects)<br/>
 * - Tilesets (an array of TMXTilesetInfo objects) <br/>
 * - ObjectGroups (an array of TMXObjectGroupInfo objects) </p>
 *
 * <p>This information is obtained from the TMX file. </p>
 * @class
 * @extends cc.SAXParser
 */
cc.TMXMapInfo = cc.SAXParser.extend(/** @lends cc.TMXMapInfo# */{
    // map orientation
    _orientation:null,
    _mapSize:cc.SizeZero(),
    _tileSize:cc.SizeZero(),
    _layers:null,
    _tileSets:null,
    _objectGroups:null,
    _parentElement:null,
    _parentGID:null,
    _layerAttribs:0,
    _storingCharacters:false,
    _properties:[],
    // tmx filename
    _TMXFileName:null,
    //current string
    _currentString:null,
    // tile properties
    _tileProperties:null,
    _resources:null,
    ctor:function () {
        this._tileSets = [];
        this._tileProperties = [];
        this._properties = [];
    },
    /**
     * @return {Number}
     */
    getOrientation:function () {
        return this._orientation;
    },

    /**
     * @param {Number} Var
     */
    setOrientation:function (Var) {
        this._orientation = Var;
    },

    /**
     * Map width & height
     * @return {cc.Size}
     */
    getMapSize:function () {
        return this._mapSize;
    },

    /**
     * @param {cc.Size} Var
     */
    setMapSize:function (Var) {
        this._mapSize = Var;
    },

    /**
     * Tiles width & height
     * @return {cc.Size}
     */
    getTileSize:function () {
        return this._tileSize;
    },

    /**
     * @param {cc.Size} Var
     */
    setTileSize:function (Var) {
        this._tileSize = Var;
    },

    /**
     * Layers
     * @return {Array}
     */
    getLayers:function () {
        return this._layers;
    },

    /**
     * @param {cc.TMXLayerInfo} Var
     */
    setLayers:function (Var) {
        this._layers.push(Var);
    },

    /**
     * tilesets
     * @return {Array}
     */
    getTilesets:function () {
        return this._tileSets;
    },

    /**
     * @param {cc.TMXTilesetInfo} Var
     */
    setTilesets:function (Var) {
        this._tileSets.push(Var);
    },

    /**
     * ObjectGroups
     * @return {Array}
     */
    getObjectGroups:function () {
        return this._objectGroups;
    },

    /**
     * @param {cc.TMXObjectGroup} Var
     */
    setObjectGroups:function (Var) {
        this._objectGroups.push(Var);
    },

    /**
     * parent element
     * @return {Number}
     */
    getParentElement:function () {
        return this._parentElement;
    },

    /**
     * @param {Number} Var
     */
    setParentElement:function (Var) {
        this._parentElement = Var;
    },

    /**
     * parent GID
     * @return {Number}
     */
    getParentGID:function () {
        return this._parentGID;
    },

    /**
     * @param {Number} Var
     */
    setParentGID:function (Var) {
        this._parentGID = Var;
    },

    /**
     *  layer attribute
     * @return {Number}
     */
    getLayerAttribs:function () {
        return this._layerAttribs;
    },

    /**
     * @param {Number} Var
     */
    setLayerAttribs:function (Var) {
        this._layerAttribs = Var;
    },

    /**
     * is string characters?
     * @return {Boolean}
     */
    getStoringCharacters:function () {
        return this._storingCharacters;
    },

    /**
     * @param {Boolean} Var
     */
    setStoringCharacters:function (Var) {
        this._storingCharacters = Var;
    },

    /**
     * Properties
     * @return {Array}
     */
    getProperties:function () {
        return this._properties;
    },

    /**
     * @param {object} Var
     */
    setProperties:function (Var) {
        this._properties.push(Var);
    },

    /**
     * Initializes a TMX format with a  tmx file
     * @param {String} tmxFile
     * @return {String}
     */
    initWithTMXFile:function (tmxFile, resourcePath) {
        this._internalInit(tmxFile, resourcePath);
        return this.parseXMLFile(this._TMXFileName);
    },

    /** Initalises parsing of an XML file, either a tmx (Map) file or tsx (Tileset) file
     * @param {String} tmxFile
     * @return {Element}
     */
    parseXMLFile:function (tmxFile) {
        var mapXML = cc.SAXParser.shareParser().tmxParse(tmxFile);

        // PARSE <map>
        var map = mapXML.documentElement;

        var version = map.getAttribute('version');
        var orientationStr = map.getAttribute('orientation');

        if (map.nodeName == "map") {
            if (version != "1.0" && version !== null) {
                cc.log("cocos2d: TMXFormat: Unsupported TMX version:" + version);
            }

            if (orientationStr == "orthogonal")
                this.setOrientation(cc.TMXOrientationOrtho);
            else if (orientationStr == "isometric")
                this.setOrientation(cc.TMXOrientationIso);
            else if (orientationStr == "hexagonal")
                this.setOrientation(cc.TMXOrientationHex);
            else if (orientationStr !== null)
                cc.log("cocos2d: TMXFomat: Unsupported orientation:" + this.getOrientation());

            var s = cc.size(0, 0);
            s.width = parseFloat(map.getAttribute('width'));
            s.height = parseFloat(map.getAttribute('height'));
            this.setMapSize(s);

            s = cc.size(0, 0);
            s.width = parseFloat(map.getAttribute('tilewidth'));
            s.height = parseFloat(map.getAttribute('tileheight'));
            this.setTileSize(s)

            // The parent element is the map
            var mp = map.querySelectorAll("map > properties >  property");
            if (mp) {
                for (var k = 0; k < mp.length; k++) {
                    var dict = {};
                    var name = mp[k].getAttribute('name');
                    var value = mp[k].getAttribute('value');
                    dict[name] = value;
                    this.setProperties(dict);
                }
            }
        }

        //todo fixed
        // PARSE <tileset>
        var tilesets = map.getElementsByTagName('tileset');
        if (map.nodeName !== "map") {
            tilesets = []
            tilesets.push(map);
        }

        for (var i = 0, len = tilesets.length; i < len; i++) {
            var t = tilesets[i];
            // If this is an external tileset then start parsing that
            var externalTilesetFilename = t.getAttribute('source');
            if (externalTilesetFilename) {
                this.parseXMLFile(cc.FileUtils.getInstance().fullPathFromRelativeFile(externalTilesetFilename, tmxFile));
            }
            else {
                var tileset = new cc.TMXTilesetInfo();
                tileset.name = t.getAttribute('name') || "";
                tileset.firstGid = parseInt(t.getAttribute('firstgid')) || 1;
                tileset.spacing = parseInt(t.getAttribute('spacing')) || 0;
                tileset.margin = parseInt(t.getAttribute('margin')) || 0;

                var s = cc.size(0, 0);
                s.width = parseFloat(t.getAttribute('tilewidth'));
                s.height = parseFloat(t.getAttribute('tileheight'));
                tileset._tileSize = s;

                var image = t.getElementsByTagName('image')[0];
                var imgSource = image.getAttribute('source');
                if (imgSource) {
                    if (this._resources) {
                        imgSource = this._resources + "/" + imgSource;
                    }
                    else {
                        imgSource = cc.FileUtils.getInstance().fullPathFromRelativeFile(imgSource, tmxFile);
                    }
                }
                tileset.sourceImage = imgSource;
                this.setTilesets(tileset);
            }
        }

        // PARSE  <tile>
        var tiles = map.querySelectorAll('tile');
        if (tiles) {
            for (var i = 0, len = tiles.length; i < len; i++) {
                var info = this._tileSets[0];
                var t = tiles[i];
                this.setParentGID(parseInt(info.firstGid) + parseInt(t.getAttribute('id') || 0));
                var tp = t.querySelectorAll("properties > property")[0];

                if (tp) {
                    var dict = {};
                    var name = tp.getAttribute('name');
                    var value = tp.getAttribute('value');
                    dict[name] = value;
                    this._tileProperties[this.getParentGID()] = dict;
                }
            }
        }

        // PARSE  <layer>
        var layers = map.getElementsByTagName('layer');
        if (layers) {
            for (var i = 0, len = layers.length; i < len; i++) {
                var l = layers[i];
                var data = l.getElementsByTagName('data')[0];

                var layer = new cc.TMXLayerInfo();
                layer.name = l.getAttribute('name');

                var s = cc.size(0, 0);
                s.width = parseFloat(l.getAttribute('width'));
                s.height = parseFloat(l.getAttribute('height'));
                layer._layerSize = s;

                var visible = l.getAttribute('visible')
                layer.visible = !(visible == "0");

                var opacity = l.getAttribute('opacity') || 1;

                if (opacity) {
                    layer._opacity = parseInt(255 * parseFloat(opacity));
                }
                else {
                    layer._opacity = 255;
                }

                var x = parseFloat(l.getAttribute('x')) || 0;
                var y = parseFloat(l.getAttribute('y')) || 0;
                layer.offset = cc.p(x, y);

                var nodeValue = ''
                for (var j = 0; j < data.childNodes.length; j++) {
                    nodeValue += data.childNodes[j].nodeValue
                }

                // Unpack the tilemap data
                var compression = data.getAttribute('compression');
                var encoding = data.getAttribute('encoding');
                cc.Assert(compression == null || compression == "gzip" || compression == "zlib", "TMX: unsupported compression method");
                switch (compression) {
                    case 'gzip':
                        layer._tiles = cc.unzipBase64AsArray(nodeValue, 4);
                        break;
                    case 'zlib':
                        //Not Implemented
                        break;
                    // Uncompressed
                    case null:
                    case '':
                        if (encoding == "base64") {
                            layer._tiles = cc.Codec.Base64.decodeAsArray(nodeValue, 4);
                        }
                        else {
                            layer._tiles = cc.StringToArray(nodeValue);
                        }
                        break;
                    default:
                        cc.Assert(this.getLayerAttribs() != cc.TMXLayerAttribNone, "TMX tile map: Only base64 and/or gzip/zlib maps are supported");
                }

                // The parent element is the last layer
                var lp = l.querySelectorAll("properties > property");
                if (lp) {
                    for (var k = 0; k < lp.length; k++) {
                        var dict = {};
                        var name = lp[k].getAttribute('name');
                        var value = lp[k].getAttribute('value');
                        dict[name] = value;

                        layer.setProperties(dict);
                    }
                }

                this.setLayers(layer);
            }
        }

        // PARSE <objectgroup>
        var objectgroups = map.getElementsByTagName('objectgroup');
        if (objectgroups) {

            for (var i = 0; i < objectgroups.length; i++) {
                var g = objectgroups[i];
                var objectGroup = new cc.TMXObjectGroup();
                objectGroup.setGroupName(g.getAttribute('name'));
                var positionOffset = cc.p(0, 0);
                positionOffset.x = parseFloat(g.getAttribute('x')) * this.getTileSize().width || 0;
                positionOffset.y = parseFloat(g.getAttribute('y')) * this.getTileSize().height || 0;
                objectGroup.setPositionOffset(positionOffset);

                var gp = g.querySelectorAll("objectgroup > properties > property");
                if (gp) {
                    for (var k = 0; k < gp.length; k++) {
                        var dict = {};
                        var name = gp[k].getAttribute('name');
                        var value = gp[k].getAttribute('value');
                        dict[name] = value;

                        // Add the property to the layer
                        objectGroup.setProperties(dict);
                    }
                }

                var objects = g.querySelectorAll('object')
                if (objects) {
                    for (var j = 0; j < objects.length; j++) {
                        var o = objects[j]
                        // The value for "type" was blank or not a valid class name
                        // Create an instance of TMXObjectInfo to store the object and its properties
                        var dict = {};

                        // Set the name of the object to the value for "name"
                        dict["name"] = o.getAttribute('name') || "";

                        // Assign all the attributes as key/name pairs in the properties dictionary
                        dict["type"] = o.getAttribute('type') || "";

                        dict["x"] = parseInt(o.getAttribute('x') || 0) + objectGroup.getPositionOffset().x;

                        var y = parseInt(o.getAttribute('y') || 0) + objectGroup.getPositionOffset().y;

                        dict["width"] = parseInt(o.getAttribute('width')) || 0;

                        dict["height"] = parseInt(o.getAttribute('height')) || 0;

                        // Correct y position. (Tiled uses Flipped, cocos2d uses Standard)
                        y = parseInt(this.getMapSize().height * this.getTileSize().height) - y - dict["height"];
                        dict["y"] = y;

                        var op = o.querySelectorAll("properties > property");
                        if (op) {
                            for (var k = 0; k < op.length; k++) {
                                var name = op[k].getAttribute('name');
                                var value = op[k].getAttribute('value');
                                dict[name] = value;
                            }
                        }

                        // Add the object to the objectGroup
                        objectGroup.setObjects(dict);
                    }
                }

                this.setObjectGroups(objectGroup);
            }
        }
        return map;
    },

    /**
     * @return {object}
     */
    getTileProperties:function () {
        return this._tileProperties;
    },

    /**
     * @param {object} tileProperties
     */
    setTileProperties:function (tileProperties) {
        this._tileProperties.push(tileProperties);
    },

    /**
     * @return {String}
     */
    getCurrentString:function () {
        return this._currentString;
    },

    /**
     * @param {String} currentString
     */
    setCurrentString:function (currentString) {
        this._currentString = currentString;
    },

    /**
     * @return {String}
     */
    getTMXFileName:function () {
        return this._TMXFileName;
    },

    /**
     * @param {String} fileName
     */
    setTMXFileName:function (fileName) {
        this._TMXFileName = fileName;
    },

    _internalInit:function (tmxFileName, resourcePath) {
        this._tileSets = [];
        this._layers = [];

        this._TMXFileName = cc.FileUtils.getInstance().fullPathFromRelativePath(tmxFileName);

        if (resourcePath) {
            this._resources = resourcePath;
        }

        this._objectGroups = [];

        this._properties = [];
        this._tileProperties = [];

        // tmp vars
        this._currentString = "";
        this._storingCharacters = false;
        this._layerAttribs = cc.TMXLayerAttribNone;
        this._parentElement = cc.TMXPropertyNone;
    }
});

/**
 * Creates a TMX Format with a tmx file
 * @param {String} tmxFile
 * @param {String} resourcePath
 * @return {cc.TMXMapInfo}
 */
cc.TMXMapInfo.create = function (tmxFile, resourcePath) {
    var ret = new cc.TMXMapInfo();
    if (ret.initWithTMXFile(tmxFile, resourcePath)) {
        return ret;
    }
    return null;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * cc.TMXObjectGroup represents the TMX object group.
 * @class
 * @extends cc.Class
 */
cc.TMXObjectGroup = cc.Class.extend(/** @lends cc.TMXObjectGroup# */{
    //name of the group
    _groupName:"",
    _positionOffset:cc.PointZero(),
    _properties:null,
    _objects:null,

    /**
     *  Constructor
     */
    ctor:function () {
        this._properties = [];
        this._objects = [];
    },

    /**
     * Offset position of child objects
     * @return {cc.Point}
     */
    getPositionOffset:function () {
        return this._positionOffset;
    },

    /**
     * @param {cc.Point} Var
     */
    setPositionOffset:function (Var) {
        this._positionOffset = Var;
    },

    /**
     * List of properties stored in a dictionary
     * @return {Array}
     */
    getProperties:function () {
        return this._properties;
    },

    /**
     * @param {object} Var
     */
    setProperties:function (Var) {
        this._properties.push(Var);
    },

    /**
     * @return {String}
     */
    getGroupName:function () {
        return this._groupName.toString();
    },

    /**
     * @param {String} groupName
     */
    setGroupName:function (groupName) {
        this._groupName = groupName;
    },

    /**
     * Return the value for the specific property name
     * @param {String} propertyName
     * @return {object}
     */
    propertyNamed:function (propertyName) {
        return this._properties[propertyName];
    },

    /**
     * <p>Return the dictionary for the specific object name. <br />
     * It will return the 1st object found on the array for the given name.</p>
     * @param {String} objectName
     * @return {object|Null}
     */
    objectNamed:function (objectName) {
        if (this._objects && this._objects.length > 0) {
            for (var i = 0, len = this._objects.length; i < len; i++) {
                var name = this._objects[i]["name"];
                if (name && name == objectName) {
                    return this._objects[i];
                }
            }
        }
        // object not found
        return null;
    },

    /**
     * @return {Array}
     */
    getObjects:function () {
        return this._objects;
    },

    /**
     * @param {object} objects
     */
    setObjects:function (objects) {
        this._objects.push(objects);
    }
});
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * <p>cc.TMXLayer represents the TMX layer. </p>
 *
 * <p>It is a subclass of cc.SpriteBatchNode. By default the tiles are rendered using a cc.TextureAtlas. <br />
 * If you modify a tile on runtime, then, that tile will become a cc.Sprite, otherwise no cc.Sprite objects are created. <br />
 * The benefits of using cc.Sprite objects as tiles are: <br />
 * - tiles (cc.Sprite) can be rotated/scaled/moved with a nice API </p>
 *
 * <p>If the layer contains a property named "cc.vertexz" with an integer (in can be positive or negative), <br />
 * then all the tiles belonging to the layer will use that value as their OpenGL vertex Z for depth. </p>
 *
 * <p>On the other hand, if the "cc.vertexz" property has the "automatic" value, then the tiles will use an automatic vertex Z value. <br />
 * Also before drawing the tiles, GL_ALPHA_TEST will be enabled, and disabled after drawing them. The used alpha func will be:  </p>
 *
 * glAlphaFunc( GL_GREATER, value ) <br />
 *
 * <p>"value" by default is 0, but you can change it from Tiled by adding the "cc_alpha_func" property to the layer. <br />
 * The value 0 should work for most cases, but if you have tiles that are semi-transparent, then you might want to use a different value, like 0.5.</p>
 * @class
 * @extends cc.SpriteBatchNode
 */
cc.TMXLayer = cc.SpriteBatchNode.extend(/** @lends cc.TMXLayer# */{
    //size of the layer in tiles
    _layerSize:cc.SizeZero(),
    _mapTileSize:cc.SizeZero(),
    _tiles:null,
    _tileSet:null,
    _layerOrientation:null,
    _properties:null,
    //name of the layer
    _layerName:"",
    //TMX Layer supports opacity
    _opacity:255,
    _minGID:null,
    _maxGID:null,
    //Only used when vertexZ is used
    _vertexZvalue:null,
    _useAutomaticVertexZ:null,
    _alphaFuncValue:null,
    //used for optimization
    _reusedTile:null,
    _atlasIndexArray:null,
    //used for retina display
    _contentScaleFactor:null,

    /**
     *  Constructor
     */
    ctor:function () {
        this._super();
        this._children = [];
        this._descendants = [];
        this._isUseCache = true;
    },

    /**
     * @return {cc.Size}
     */
    getLayerSize:function () {
        return this._layerSize;
    },

    /**
     * @param {cc.Size} Var
     */
    setLayerSize:function (Var) {
        this._layerSize = Var;
    },

    /**
     * Size of the map's tile (could be different from the tile's size)
     * @return {cc.Size}
     */
    getMapTileSize:function () {
        return this._mapTileSize;
    },

    /**
     * @param {cc.Size} Var
     */
    setMapTileSize:function (Var) {
        this._mapTileSize = Var;
    },

    /**
     * Pointer to the map of tiles
     * @return {Array}
     */
    getTiles:function () {
        return this._tiles;
    },

    /**
     * @param {Array} Var
     */
    setTiles:function (Var) {
        this._tiles = Var;
    },

    /**
     * Tile set information for the layer
     * @return {cc.TMXTilesetInfo}
     */
    getTileSet:function () {
        return this._tileSet;
    },

    /**
     * @param {cc.TMXTilesetInfo} Var
     */
    setTileSet:function (Var) {
        this._tileSet = Var;
    },

    /**
     * Layer orientation, which is the same as the map orientation
     * @return {Number}
     */
    getLayerOrientation:function () {
        return this._layerOrientation;
    },

    /**
     * @param {Number} Var
     */
    setLayerOrientation:function (Var) {
        this._layerOrientation = Var;
    },

    /**
     * properties from the layer. They can be added using Tiled
     * @return {Array}
     */
    getProperties:function () {
        return this._properties;
    },

    /**
     * @param {Array} Var
     */
    setProperties:function (Var) {
        this._properties = Var;
    },

    /**
     * Initializes a cc.TMXLayer with a tileset info, a layer info and a map info
     * @param {cc.TMXTilesetInfo} tilesetInfo
     * @param {cc.TMXLayerInfo} layerInfo
     * @param {cc.TMXMapInfo} mapInfo
     * @return {Boolean}
     */
    initWithTilesetInfo:function (tilesetInfo, layerInfo, mapInfo) {
        // XXX: is 35% a good estimate ?
        var size = layerInfo._layerSize;
        var totalNumberOfTiles = parseInt(size.width * size.height);
        var capacity = totalNumberOfTiles * 0.35 + 1; // 35 percent is occupied ?

        if (tilesetInfo) {
            var texture = cc.TextureCache.getInstance().addImage(tilesetInfo.sourceImage.toString());
        }
        if (this.initWithTexture(texture, capacity)) {
            // layerInfo
            this._layerName = layerInfo.name;
            this._layerSize = size;
            this._tiles = layerInfo._tiles;
            this._minGID = layerInfo._minGID;
            this._maxGID = layerInfo._maxGID;
            this._opacity = layerInfo._opacity;
            this.setProperties(layerInfo.getProperties());
            this._contentScaleFactor = cc.Director.getInstance().getContentScaleFactor();

            // tilesetInfo
            this._tileSet = tilesetInfo;

            // mapInfo
            this._mapTileSize = mapInfo.getTileSize();
            this._layerOrientation = mapInfo.getOrientation();

            // offset (after layer orientation is set);
            var offset = this._calculateLayerOffset(layerInfo.offset);
            this.setPosition(cc.POINT_PIXELS_TO_POINTS(offset));

            this._atlasIndexArray = [];
            this.setContentSize(cc.SIZE_PIXELS_TO_POINTS(cc.size(this._layerSize.width * this._mapTileSize.width,
                this._layerSize.height * this._mapTileSize.height)));

            this._useAutomaticVertexZ = false;
            this._vertexZvalue = 0;
            return true;
        }
        return false;
    },

    /**
     * <p>Dealloc the map that contains the tile position from memory. <br />
     * Unless you want to know at runtime the tiles positions, you can safely call this method. <br />
     * If you are going to call layer.tileGIDAt() then, don't release the map</p>
     */
    releaseMap:function () {
        if (this._tiles) {
            this._tiles = null;
        }

        if (this._atlasIndexArray) {
            this._atlasIndexArray = null;
        }
    },

    /**
     * <p>Returns the tile (cc.Sprite) at a given a tile coordinate. <br/>
     * The returned cc.Sprite will be already added to the cc.TMXLayer. Don't add it again.<br/>
     * The cc.Sprite can be treated like any other cc.Sprite: rotated, scaled, translated, opacity, color, etc. <br/>
     * You can remove either by calling: <br/>
     * - layer.removeChild(sprite, cleanup); <br/>
     * - or layer.removeTileAt(ccp(x,y)); </p>
     * @param {cc.Point} pos
     * @return {cc.Sprite}
     */
    tileAt:function (pos) {
        cc.Assert(pos.x < this._layerSize.width && pos.y < this._layerSize.height && pos.x >= 0 && pos.y >= 0, "TMXLayer: invalid position");
        cc.Assert(this._tiles && this._atlasIndexArray, "TMXLayer: the tiles map has been released");

        var tile = null;
        var gid = this.tileGIDAt(pos);

        // if GID == 0, then no tile is present
        if (gid) {
            var z = pos.x + pos.y * this._layerSize.width;

            tile = this.getChildByTag(z);

            // tile not created yet. create it
            if (!tile) {
                var rect = this._tileSet.rectForGID(gid);
                rect = cc.RECT_PIXELS_TO_POINTS(rect);

                tile = new cc.Sprite();
                tile.initWithTexture(this.getTexture(), rect);
                tile.setBatchNode(this);
                tile.setPosition(this.positionAt(pos));
                tile.setVertexZ(this._vertexZForPos(pos));
                tile.setAnchorPoint(cc.PointZero());
                tile.setOpacity(this._opacity);

                var indexForZ = this._atlasIndexForExistantZ(z);
                this.addSpriteWithoutQuad(tile, indexForZ, z);
            }
        }
        return tile;
    },

    /**
     * Returns the tile gid at a given tile coordinate. <br />
     * if it returns 0, it means that the tile is empty. <br />
     * This method requires the the tile map has not been previously released (eg. don't call layer.releaseMap())<br />
     * @param {cc.Point} pos
     * @return {Number}
     */
    tileGIDAt:function (pos) {
        cc.Assert(pos.x < this._layerSize.width && pos.y < this._layerSize.height && pos.x >= 0 && pos.y >= 0, "TMXLayer: invalid position");
        cc.Assert(this._tiles && this._atlasIndexArray, "TMXLayer: the tiles map has been released");

        var idx = pos.x + pos.y * this._layerSize.width;
        // Bits on the far end of the 32-bit global tile ID are used for tile flags
        var tile = this._tiles[idx];

        return (tile & cc.FlippedMask) >>> 0;
    },

    /**
     *  lipped tiles can be changed dynamically
     * @param {cc.Point} pos
     * @return {Number}
     */
    tileFlagAt:function (pos) {
        cc.Assert(pos.x < this._layerSize.width && pos.y < this._layerSize.height && pos.x >= 0 && pos.y >= 0, "TMXLayer: invalid position");
        cc.Assert(this._tiles && this._atlasIndexArray, "TMXLayer: the tiles map has been released");

        var idx = pos.x + pos.y * this._layerSize.width;
        // Bits on the far end of the 32-bit global tile ID are used for tile flags
        var tile = this._tiles[idx];

        return (tile & cc.FlipedAll) >>> 0;
    },

    /**
     * <p>Sets the tile gid (gid = tile global id) at a given tile coordinate.<br />
     * The Tile GID can be obtained by using the method "tileGIDAt" or by using the TMX editor . Tileset Mgr +1.<br />
     * If a tile is already placed at that position, then it will be removed.</p>
     * @param {Number} gid
     * @param {cc.Point} pos
     * @param {Number} flags
     */
    setTileGID:function (gid, pos, flags) {
        cc.Assert(pos.x < this._layerSize.width && pos.y < this._layerSize.height && pos.x >= 0 && pos.y >= 0, "TMXLayer: invalid position");
        cc.Assert(this._tiles && this._atlasIndexArray, "TMXLayer: the tiles map has been released");
        cc.Assert(gid !== 0 || !(gid >= this._tileSet.firstGid), "TMXLayer: invalid gid:" + gid);

        this._setNodeDirtyForCache();

        var currentFlags = this.tileFlagAt(pos);
        var currentGID = this.tileGIDAt(pos);

        if (currentGID != gid || currentFlags != flags) {
            var gidAndFlags = (gid | flags) >>> 0;
            // setting gid=0 is equal to remove the tile
            if (gid == 0) {
                this.removeTileAt(pos);
            }

            // empty tile. create a new one
            else if (currentGID == 0) {
                this._insertTileForGID(gidAndFlags, pos);
            }

            // modifying an existing tile with a non-empty tile
            else {
                var z = pos.x + pos.y * this._layerSize.width;
                var sprite = this.getChildByTag(z);

                if (sprite) {
                    var rect = this._tileSet.rectForGID(gid);
                    rect = cc.RECT_PIXELS_TO_POINTS(rect);

                    sprite.setTextureRect(rect, false, rect.size);
                    if (flags) {
                        this._setupTileSprite(sprite, pos, gidAndFlags);
                    }
                    this._tiles[z] = gidAndFlags;
                }
                else {
                    this._updateTileForGID(gidAndFlags, pos);
                }
            }
        }
    },

    /**
     * Removes a tile at given tile coordinate
     * @param {cc.Point} pos
     */
    removeTileAt:function (pos) {
        cc.Assert(pos.x < this._layerSize.width && pos.y < this._layerSize.height && pos.x >= 0 && pos.y >= 0, "TMXLayer: invalid position");
        cc.Assert(this._tiles && this._atlasIndexArray, "TMXLayer: the tiles map has been released");

        this._setNodeDirtyForCache();
        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());

        var gid = this.tileGIDAt(pos);

        if (gid) {
            var z = pos.x + pos.y * this._layerSize.width;
            var atlasIndex = this._atlasIndexForExistantZ(z);
            // remove tile from GID map
            this._tiles[z] = 0;

            // remove tile from atlas position array
            cc.ArrayRemoveObjectAtIndex(this._atlasIndexArray, atlasIndex);

            // remove it from sprites and/or texture atlas
            var sprite = this.getChildByTag(z);

            if (sprite) {
                this.removeChild(sprite, true);
            }
            else {
                this._textureAtlas.removeQuadAtIndex(atlasIndex);

                // update possible children
                if (this._children) {
                    for (var i = 0, len = this._children.length; i < len; i++) {
                        var child = this._children[i];
                        if (child) {
                            var ai = child.getAtlasIndex();
                            if (ai >= atlasIndex) {
                                child.setAtlasIndex(ai - 1);
                            }
                        }
                    }
                }
            }
        }
    },

    /**
     * Returns the position in pixels of a given tile coordinate
     * @param {cc.Point} pos
     * @return {cc.Point}
     */
    positionAt:function (pos) {
        var ret = cc.PointZero();
        switch (this._layerOrientation) {
            case cc.TMXOrientationOrtho:
                ret = this._positionForOrthoAt(pos);
                break;
            case cc.TMXOrientationIso:
                ret = this._positionForIsoAt(pos);
                break;
            case cc.TMXOrientationHex:
                ret = this._positionForHexAt(pos);
                break;
        }
        ret = cc.POINT_PIXELS_TO_POINTS(ret);
        return ret;
    },

    /**
     * Return the value for the specific property name
     * @param {String} propertyName
     * @return {Number}
     * //todo
     */
    propertyNamed:function (propertyName) {
        return this._properties[propertyName];
    },

    /**
     * Creates the tiles
     */
    setupTiles:function () {
        // Optimization: quick hack that sets the image size on the tileset
        var textureCache = this._textureAtlas.getTexture();
        this._tileSet.imageSize = cc.size(textureCache.width, textureCache.height);

        // By default all the tiles are aliased
        // pros:
        //  - easier to render
        // cons:
        //  - difficult to scale / rotate / etc.
        //this._textureAtlas.getTexture().setAliasTexParameters();

        // Parse cocos2d properties
        this._parseInternalProperties();
        this._setNodeDirtyForCache();
        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());

        for (var y = 0; y < this._layerSize.height; y++) {
            for (var x = 0; x < this._layerSize.width; x++) {
                var pos = x + this._layerSize.width * y;
                var gid = this._tiles[pos];

                // XXX: gid == 0 -. empty tile
                if (gid != 0) {
                    this._appendTileForGID(gid, cc.p(x, y));
                    // Optimization: update min and max GID rendered by the layer
                    this._minGID = Math.min(gid, this._minGID);
                    this._maxGID = Math.max(gid, this._maxGID);
                }
            }
        }
        // console.log(this._maxGID , this._tileSet.firstGid , this._minGID , this._tileSet.firstGid)
        cc.Assert((this._maxGID >= this._tileSet.firstGid && this._minGID >= this._tileSet.firstGid), "TMX: Only 1 tileset per layer is supported");
    },

    /**
     * cc.TMXLayer doesn't support adding a cc.Sprite manually.
     * @warning addChild(child); is not supported on cc.TMXLayer. Instead of setTileGID.
     * @param {cc.Node} child
     */
    addChild:function (child) {
        cc.Assert(0, "addChild: is not supported on cc.TMXLayer. Instead use setTileGID:at:/tileAt:");
    },

    /**
     * Remove child
     * @param  {cc.Node} child
     * @param  {Boolean} cleanup
     */
    removeChild:function (child, cleanup) {
        var sprite = child;

        // allows removing nil objects
        if (!sprite)
            return;

        cc.Assert(cc.ArrayContainsObject(this._children, sprite), "Tile does not belong to TMXLayer");

        this._setNodeDirtyForCache();
        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());
        var atlasIndex = cc.ArrayGetIndexOfObject(this._children, sprite);
        var zz = this._atlasIndexArray[atlasIndex];
        this._tiles[zz] = 0;
        cc.ArrayRemoveObjectAtIndex(this._atlasIndexArray, atlasIndex);
        this._super(sprite, cleanup);
    },

    /**
     * @return {String}
     */
    getLayerName:function () {
        return this._layerName.toString();
    },

    /**
     * @param {String} layerName
     */
    setLayerName:function (layerName) {
        this._layerName = layerName;
    },

    _positionForIsoAt:function (pos) {
        var xy = cc.p(this._mapTileSize.width / 2 * ( this._layerSize.width + pos.x - pos.y - 1),
            this._mapTileSize.height / 2 * (( this._layerSize.height * 2 - pos.x - pos.y) - 2));
        return xy;
    },

    _positionForOrthoAt:function (pos) {
        if (pos.x == 101) {
            console.log("before:", pos.x, this._mapTileSize.width,
                this._layerSize.height, pos.y, 1, this._mapTileSize.height);
        }
        var xy = cc.p(pos.x * this._mapTileSize.width,
            (this._layerSize.height - pos.y - 1) * this._mapTileSize.height);
        if (pos.x == 101) {
            console.log("after:", xy);
        }
        return xy;
    },

    _positionForHexAt:function (pos) {
        var diffY = 0;
        if (pos.x % 2 == 1) {
            diffY = -this._mapTileSize.height / 2;
        }

        var xy = cc.p(pos.x * this._mapTileSize.width * 3 / 4,
            (this._layerSize.height - pos.y - 1) * this._mapTileSize.height + diffY);
        return xy;
    },

    _calculateLayerOffset:function (pos) {
        var ret = cc.PointZero();
        switch (this._layerOrientation) {
            case cc.TMXOrientationOrtho:
                ret = cc.p(pos.x * this._mapTileSize.width, -pos.y * this._mapTileSize.height);
                break;
            case cc.TMXOrientationIso:
                ret = cc.p((this._mapTileSize.width / 2) * (pos.x - pos.y),
                    (this._mapTileSize.height / 2 ) * (-pos.x - pos.y));
                break;
            case cc.TMXOrientationHex:
                ret = cc.p(0, 0);
                cc.log("cocos2d:offset for hexagonal map not implemented yet");
                break;
        }
        return ret;
    },

    _appendTileForGID:function (gid, pos) {
        var rect = this._tileSet.rectForGID(gid);
        rect = cc.RECT_PIXELS_TO_POINTS(rect);

        var z = pos.x + pos.y * this._layerSize.width;
        var tile = this._reusedTileWithRect(rect);

        this._setupTileSprite(tile, pos, gid);

        // optimization:
        // The difference between _appendTileForGID and _insertTileForGID is that append is faster, since
        // it appends the tile at the end of the texture atlas
        //todo fix
        var indexForZ = this._atlasIndexArray.length;

        // don't add it using the "standard" way.
        this.addQuadFromSprite(tile, indexForZ);

        // append should be after addQuadFromSprite since it modifies the quantity values
        this._atlasIndexArray = cc.ArrayAppendObjectToIndex(this._atlasIndexArray, z, indexForZ);
        return tile;
    },

    _insertTileForGID:function (gid, pos) {
        var rect = this._tileSet.rectForGID(gid);
        rect = cc.RECT_PIXELS_TO_POINTS(rect);

        var z = parseInt(pos.x + pos.y * this._layerSize.width);
        var tile = this._reusedTileWithRect(rect);
        this._setupTileSprite(tile, pos, gid);

        // get atlas index
        var indexForZ = this._atlasIndexForNewZ(z);

        // Optimization: add the quad without adding a child
        this.addQuadFromSprite(tile, indexForZ);

        // insert it into the local atlasindex array
        this._atlasIndexArray = cc.ArrayAppendObjectToIndex(this._atlasIndexArray, z, indexForZ);
        // update possible children
        if (this._children) {
            for (var i = 0, len = this._children.length; i < len; i++) {
                var child = this._children[i];
                if (child) {
                    var ai = child.getAtlasIndex();
                    if (ai >= indexForZ) {
                        child.setAtlasIndex(ai + 1);
                    }
                }
            }
        }
        this._tiles[z] = gid;
        return tile;
    },

    _updateTileForGID:function (gid, pos) {
        var rect = this._tileSet.rectForGID(gid);
        rect = cc.rect(rect.origin.x / this._contentScaleFactor, rect.origin.y / this._contentScaleFactor,
            rect.size.width / this._contentScaleFactor, rect.size.height / this._contentScaleFactor);
        var z = pos.x + pos.y * this._layerSize.width;

        var tile = this._reusedTileWithRect(rect);

        this._setupTileSprite(tile, pos, gid);

        // get atlas index
        var indexForZ = this._atlasIndexForExistantZ(z);
        tile.setAtlasIndex(indexForZ);
        tile.setDirty(true);
        tile.updateTransform();
        this._tiles[z] = gid;

        return tile;
    },

    //The layer recognizes some special properties, like cc_vertez
    _parseInternalProperties:function () {
        // if cc_vertex=automatic, then tiles will be rendered using vertexz

        var vertexz = this.propertyNamed("cc_vertexz");
        if (vertexz) {
            if (vertexz == "automatic") {
                this._useAutomaticVertexZ = true;
                var alphaFuncVal = this.propertyNamed("cc_alpha_func");
                var alphaFuncValue = 0;

                //todo webgl
                //this.setShaderProgram(cc.ShaderCache.getInstance().programForKey(kcc.Shader_PositionTextureColorAlphaTest));
                //var alphaValueLocation = glGetUniformLocation(getShaderProgram().getProgram(), kcc.UniformAlphaTestValue);
                // NOTE: alpha test shader is hard-coded to use the equivalent of a glAlphaFunc(GL_GREATER) comparison
                //this.getShaderProgram().setUniformLocationWith1f(alphaValueLocation, alphaFuncValue);
            }
            else {
                this._vertexZvalue = parseInt(vertexz);
            }
        }

        var alphaFuncVal = this.propertyNamed("cc_alpha_func");
        if (alphaFuncVal) {
            this._alphaFuncValue = parseInt(alphaFuncVal);
        }
    },

    _setupTileSprite:function (sprite, pos, gid) {
        var z = pos.x + pos.y * this._layerSize.width;
        sprite.setPosition(this.positionAt(pos));
        //sprite.setVertexZ(this._vertexZForPos(pos));
        sprite.setAnchorPoint(cc.PointZero());
        sprite.setOpacity(this._opacity);
        sprite.setTag(z);
        sprite.setFlipX(false);
        sprite.setFlipY(false);

        // Rotation in tiled is achieved using 3 flipped states, flipping across the horizontal, vertical, and diagonal axes of the tiles.

        if ((gid & cc.TMXTileDiagonalFlag) >>> 0) {
            // put the anchor in the middle for ease of rotation.
            sprite.setAnchorPoint(cc.p(0.5, 0.5));
            sprite.setPosition(cc.p(this.positionAt(pos).x + sprite.getContentSize().height / 2,
                this.positionAt(pos).y + sprite.getContentSize().width / 2));

            var flag = (gid & (cc.TMXTileHorizontalFlag | cc.TMXTileVerticalFlag) >>> 0) >>> 0;
            // handle the 4 diagonally flipped states.
            if (flag == cc.TMXTileHorizontalFlag) {
                sprite.setRotation(90);
            }
            else if (flag == cc.TMXTileVerticalFlag) {
                sprite.setRotation(270);
            }
            else if (flag == (cc.TMXTileVerticalFlag | cc.TMXTileHorizontalFlag) >>> 0) {
                sprite.setRotation(90);
                sprite.setFlipX(true);
            }
            else {
                sprite.setRotation(270);
                sprite.setFlipX(true);
            }
        }
        else {
            if ((gid & cc.TMXTileHorizontalFlag) >>> 0) {
                sprite.setFlipX(true);
            }

            if ((gid & cc.TMXTileVerticalFlag) >>> 0) {
                sprite.setFlipY(true);
            }
        }
    },

    _reusedTileWithRect:function (rect) {
        this._reusedTile = new cc.Sprite();
        this._reusedTile.initWithTexture(this._textureAtlas.getTexture(), rect, false);
        this._reusedTile.setBatchNode(this);
        this._reusedTile.setParent(this);

        return this._reusedTile;
    },

    _vertexZForPos:function (pos) {
        var ret = 0;
        var maxVal = 0;
        if (this._useAutomaticVertexZ) {
            switch (this._layerOrientation) {
                case cc.TMXOrientationIso:
                    maxVal = this._layerSize.width + this._layerSize.height;
                    ret = -(maxVal - (pos.x + pos.y));
                    break;
                case cc.TMXOrientationOrtho:
                    ret = -(this._layerSize.height - pos.y);
                    break;
                case cc.TMXOrientationHex:
                    cc.Assert(0, "TMX Hexa zOrder not supported");
                    break;
                default:
                    cc.Assert(0, "TMX invalid value");
                    break;
            }
        }
        else {
            ret = this._vertexZvalue;
        }
        return ret;
    },

    _atlasIndexForExistantZ:function (z) {
        var item;
        if (this._atlasIndexArray) {
            for (var i = 0; i < this._atlasIndexArray.length; i++) {
                item = this._atlasIndexArray[i];
                if (item == z) {
                    break;
                }
            }
        }
        cc.Assert(item != null, "TMX atlas index not found. Shall not happen");
        return i;
    },

    _atlasIndexForNewZ:function (z) {
        for (var i = 0; i < this._atlasIndexArray.length; i++) {
            var val = this._atlasIndexArray[i];
            if (z < val)
                break;
        }
        return i;
    }
});

/**
 * Creates a cc.TMXLayer with an tile set info, a layer info and a map info
 * @param {cc.TMXTilesetInfo} tilesetInfo
 * @param {cc.TMXLayerInfo} layerInfo
 * @param {cc.TMXMapInfo} mapInfo
 * @return {cc.TMXLayer|Null}
 */
cc.TMXLayer.create = function (tilesetInfo, layerInfo, mapInfo) {
    var ret = new cc.TMXLayer();
    if (ret.initWithTilesetInfo(tilesetInfo, layerInfo, mapInfo)) {
        return ret;
    }
    return null;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * @class
 * @extends cc.Class
 */
cc.PointObject = cc.Class.extend(/** @lends cc.PointObject# */{
    _ratio:null,
    _offset:null,
    _child:null,

    /**
     * @return  {cc.Point}
     */
    getRatio:function () {
        return this._ratio;
    },

    /**
     * @param  {cc.Point} value
     */
    setRatio:function (value) {
        this._ratio = value;
    },

    /**
     * @return  {cc.Point}
     */
    getOffset:function () {
        return this._offset;
    },

    /**
     * @param {cc.Point} value
     */
    setOffset:function (value) {
        this._offset = value;
    },

    /**
     * @return {cc.Node}
     */
    getChild:function () {
        return this._child;
    },

    /**
     * @param  {cc.Node} value
     */
    setChild:function (value) {
        this._child = value;
    },

    /**
     * @param  {cc.Point} ratio
     * @param  {cc.Point} offset
     * @return {Boolean}
     */
    initWithCCPoint:function (ratio, offset) {
        this._ratio = ratio;
        this._offset = offset;
        this._child = null;
        return true;
    }
});

/**
 * @param {cc.Point} ratio
 * @param {cc.Point} offset
 * @return {cc.PointObject}
 */
cc.PointObject.create = function (ratio, offset) {
    var ret = new cc.PointObject();
    ret.initWithCCPoint(ratio, offset);
    return ret;
};

/**
 * <p>cc.ParallaxNode: A node that simulates a parallax scroller<br />
 * The children will be moved faster / slower than the parent according the the parallax ratio. </p>
 * @class
 * @extends cc.Node
 */
cc.ParallaxNode = cc.Node.extend(/** @lends cc.ParallaxNode# */{
    _lastPosition:null,
    _parallaxArray:[],

    /**
     * @return {Array}
     */

    getParallaxArray:function () {
        return this._parallaxArray;
    },

    /**
     * @param {Array} value
     */
    setParallaxArray:function (value) {
        this._parallaxArray = value;
    },

    /**
     * Constructor
     */
    ctor:function () {
        this._parallaxArray = [];
        this._lastPosition = cc.p(-100, -100);
    },

    /**
     * Adds a child to the container with a z-order, a parallax ratio and a position offset
     * It returns self, so you can chain several addChilds.
     * @param {cc.Node} child
     * @param {Number} z
     * @param {cc.Point} ratio
     * @param {cc.Point} offset
     * @example
     * //example
     * voidNode.addChild(background, -1, cc.p(0.4, 0.5), cc.PointZero());
     */
    addChild:function (child, z, ratio, offset) {
        if (arguments.length == 3) {
            cc.Assert(0, "ParallaxNode: use addChild:z:parallaxRatio:positionOffset instead");
            return;
        }
        cc.Assert(child != null, "Argument must be non-nil");
        var obj = cc.PointObject.create(ratio, offset);
        obj.setChild(child);
        this._parallaxArray.push(obj);

        var pos = this._position;
        pos.x = pos.x * ratio.x + offset.x;
        pos.y = pos.y * ratio.y + offset.y;
        child.setPosition(pos);

        this._super(child, z, child.getTag());
    },

    /**
     *  Remove Child
     * @param {cc.Node} child
     * @param {Boolean} cleanup
     * @example
     * //example
     * voidNode.removeChild(background,true);
     */
    removeChild:function (child, cleanup) {
        for (var i = 0; i < this._parallaxArray.length; i++) {
            var point = this._parallaxArray[i];
            if (point.getChild() == child) {
                this._parallaxArray.splice(i, 1);
                break;
            }
        }
        this._super(child, cleanup);
    },

    /**
     *  Remove all children with cleanup
     * @param {Boolean} cleanup
     */
    removeAllChildrenWithCleanup:function (cleanup) {
        this._parallaxArray = [];
        this._super(cleanup);
    },

    /**
     * Visit
     */
    visit:function () {
        var pos = this._absolutePosition();
        if (!cc.Point.CCPointEqualToPoint(pos, this._lastPosition)) {
            for (var i = 0; i < this._parallaxArray.length; i++) {
                var point = this._parallaxArray[i];
                var x = -pos.x + pos.x * point.getRatio().x + point.getOffset().x;
                var y = -pos.y + pos.y * point.getRatio().y + point.getOffset().y;
                point.getChild().setPosition(cc.p(x, y));
            }
            this._lastPosition = pos;
        }
        this._super();
    },

    _absolutePosition:function () {
        var ret = this._position;
        var cn = this;
        while (cn.getParent() != null) {
            cn = cn.getParent();
            ret = cc.pAdd(ret, cn.getPosition());
        }
        return ret;
    }
});

/**
 * @return {cc.ParallaxNode}
 * @example
 * //example
 * var voidNode = cc.ParallaxNode.create();
 */
cc.ParallaxNode.create = function () {
    var ret = new cc.ParallaxNode();
    return ret;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/


/**
 * default size for font size
 * @constant
 * @type Number
 */
cc.ITEM_SIZE = 32;

cc._fontSize = cc.ITEM_SIZE;
cc._fontName = "Arial";
cc._fontNameRelease = false;

/**
 * default tag for current item
 * @constant
 * @type Number
 */
cc.CURRENT_ITEM = 0xc0c05001;
/**
 * default tag for zoom action tag
 * @constant
 * @type Number
 */
cc.ZOOM_ACTION_TAG = 0xc0c05002;
/**
 * default tag for normal
 * @constant
 * @type Number
 */
cc.NORMAL_TAG = 8801;

/**
 * default selected tag
 * @constant
 * @type Number
 */
cc.SELECTED_TAG = 8802;

/**
 * default disabled tag
 * @constant
 * @type Number
 */
cc.DISABLE_TAG = 8803;

/**
 * Subclass cc.MenuItem (or any subclass) to create your custom cc.MenuItem objects.
 * @class
 * @extends cc.Node
 */
cc.MenuItem = cc.Node.extend(/** @lends cc.MenuItem# */{
    _listener:null,
    _selector:null,
    _isSelected:false,

    /**
     * MenuItem is selected
     * @return {Boolean}
     */
    isSelected:function () {
        return this._isSelected;
    },
    _isEnabled:false,

    /**
     * MenuItem is Enabled
     * @return {Boolean}
     */
    isEnabled:function () {
        return this._isEnabled;
    },

    /**
     * set enable value of MenuItem
     * @param {Boolean} enable
     */
    setEnabled:function (enable) {
        this._isEnabled = enable;
    },

    /**
     * @param {cc.Node} rec
     * @param {function|String} selector
     * @return {Boolean}
     */
    initWithCallback:function (rec, selector) {
        this.setAnchorPoint(cc.p(0.5, 0.5));
        this._listener = rec;
        this._selector = selector;
        this._isEnabled = true;
        this._isSelected = false;
        return true;
    },

    /**
     * return rect value of cc.MenuItem
     * @return {cc.Rect}
     */
    rect:function () {
        return cc.rect(this._position.x - this._contentSize.width * this._anchorPoint.x,
            this._position.y - this._contentSize.height * this._anchorPoint.y,
            this._contentSize.width, this._contentSize.height);
    },

    /**
     * same as setIsSelected(true)
     */
    selected:function () {
        this._isSelected = true;
    },

    /**
     * same as setIsSelected(false)
     */
    unselected:function () {
        this._isSelected = false;
    },

    /**
     * @param {cc.Node} rec
     * @param {function|String} selector
     */
    setCallback:function (rec, selector) {
        this._listener = rec;
        this._selector = selector;
    },

    /**
     * call the selector with target
     */
    activate:function () {
        if (this._isEnabled) {
            if (this._listener && (typeof(this._selector) == "string")) {
                this._listener[this._selector](this);
            } else if (this._listener && (typeof(this._selector) == "function")) {
                this._selector.call(this._listener, this);
            }
        }
    }
});

/**
 * creates an empty menu item with target and callback<br/>
 * Not recommended to use the base class, should use more defined menu item classes
 * @param {cc.Node} rec target
 * @param {function|String} selector callback
 * @return {cc.MenuItem}
 */
cc.MenuItem.create = function (rec, selector) {
    var ret = new cc.MenuItem();
    ret.initWithCallback(rec, selector);
    return ret;
};


/**
 *  Any cc.Node that supports the cc.LabelProtocol protocol can be added.<br/>
 * Supported nodes:<br/>
 * - cc.BitmapFontAtlas<br/>
 * - cc.LabelAtlas<br/>
 * - cc.LabelTTF<br/>
 * @class
 * @extends cc.MenuItem
 */
cc.MenuItemLabel = cc.MenuItem.extend(/** @lends cc.MenuItemLabel# */{

    /**
     * this identifies that this object have implemented RGBAProtocol
     * @type Boolean
     */
    RGBAProtocol:true,

    _disabledColor:new cc.Color3B(),

    /**
     * @return {cc.Color3B}
     */
    getDisabledColor:function () {
        return this._disabledColor;
    },

    /**
     * @param {cc.Color3B} color
     */
    setDisabledColor:function (color) {
        this._disabledColor = color;
    },
    _label:null,

    /**
     * return label of MenuItemLabel
     * @return {cc.Node}
     */
    getLabel:function () {
        return this._label;
    },

    /**
     * @param {cc.Node} label
     */
    setLabel:function (label) {
        if (label) {
            this.addChild(label);
            label.setAnchorPoint(cc.p(0, 0));
            this.setContentSize(label.getContentSize());
        }

        if (this._label) {
            this.removeChild(this._label, true);
        }

        this._label = label;
    },
    _orginalScale:0,

    /**
     * @param {Boolean} enabled
     */
    setEnabled:function (enabled) {
        if (this._isEnabled != enabled) {
            if (!enabled) {
                this._colorBackup = this._label.getColor();
                this._label.setColor(this._disabledColor);
            }
            else {
                this._label.setColor(this._colorBackup);
            }
        }
        this._super(enabled);
    },

    /**
     * @param {Number} opacity from 0-255
     */
    setOpacity:function (opacity) {
        this._label.setOpacity(opacity);
    },

    /**
     * @return {Number}
     */
    getOpacity:function () {
        return this._label.getOpacity();
    },

    /**
     * @param {cc.Color3B} color
     */
    setColor:function (color) {
        this._label.setColor(color);
    },

    /**
     * @return {cc.Color3B}
     */
    getColor:function () {
        return this._label.getColor
    },

    setOpacityModifyRGB:function (value) {
    },

    isOpacityModifyRGB:function () {
    },

    /**
     * @param {cc.Node} label
     * @param {cc.Node} target
     * @param {function|String} selector
     * @return {Boolean}
     */
    initWithLabel:function (label, target, selector) {
        this.initWithCallback(target, selector);
        this._originalScale = 1.0;
        this._colorBackup = cc.white();
        this._disabledColor = cc.c3b(126, 126, 126);
        this.setLabel(label);
        return true;
    },

    /**
     * @param {String} label
     */
    setString:function (label) {
        this._label.setString(label);
        this.setContentSize(this._label.getContentSize());
    },

    /**
     * activate the menu item
     */
    activate:function () {
        if (this._isEnabled) {
            this.stopAllActions();
            this.setScale(this._originalScale);
            this._super();
        }
    },

    /**
     * menu item is selected (runs callback)
     */
    selected:function () {
        if (this._isEnabled) {
            this._super();

            var action = this.getActionByTag(cc.ZOOM_ACTION_TAG);
            if (action) {
                this.stopAction(action);
            } else {
                this._originalScale = this.getScale();
            }

            var zoomAction = cc.ScaleTo.create(0.1, this._originalScale * 1.2);
            zoomAction.setTag(cc.ZOOM_ACTION_TAG);
            this.runAction(zoomAction);
        }
    },

    /**
     * menu item goes back to unselected state
     */
    unselected:function () {
        if (this._isEnabled) {
            this._super();
            this.stopActionByTag(cc.ZOOM_ACTION_TAG);
            var zoomAction = cc.ScaleTo.create(0.1, this._originalScale);
            zoomAction.setTag(cc.ZOOM_ACTION_TAG);
            this.runAction(zoomAction);
        }
    }
});

/**
 * @param {cc.Node} label
 * @param {cc.Node|Null} target
 * @param {function|String|Null} selector
 * @return {cc.MenuItemLabel}
 */
cc.MenuItemLabel.create = function (label, target, selector) {
    var ret = new cc.MenuItemLabel();
    ret.initWithLabel(label, target, selector);
    return ret;
};

/**
 * Helper class that creates a MenuItemLabel class with a LabelAtlas
 * @class
 * @extends cc.MenuItemLabel
 */
cc.MenuItemAtlasFont = cc.MenuItemLabel.extend(/** @lends cc.MenuItemAtlasFont# */{

    /**
     * @param {String} value
     * @param {String} charMapFile
     * @param {Number} itemWidth
     * @param {Number} itemHeight
     * @param {String} startCharMap a single character
     * @param {cc.Node|Null} target
     * @param {function|String|Null} selector
     * @return {Boolean}
     */
    initWithString:function (value, charMapFile, itemWidth, itemHeight, startCharMap, target, selector) {
        cc.Assert(value != null && value.length != 0, "value length must be greater than 0");
        var label = new cc.LabelAtlas();
        label.initWithString(value, charMapFile, itemWidth, itemHeight, startCharMap);
        if (this.initWithLabel(label, target, selector)) {
            // do something ?
        }
        return true;
    }
});

/**
 * create menu item from string with font
 * @param {String} value the text to display
 * @param {String} charMapFile the character map file
 * @param {Number} itemWidth
 * @param {Number} itemHeight
 * @param {String} startCharMap a single character
 * @param {cc.Node|Null} target
 * @param {function|String|Null} selector
 * @return {cc.MenuItemAtlasFont}
 * @example
 * // Example
 * var item = cc.MenuItemAtlasFont.create('text to display', 'font.fnt', 12, 32, ' ')
 *
 * //OR
 * var item = cc.MenuItemAtlasFont.create('text to display', 'font.fnt', 12, 32, ' ', game, game.run)
 */
cc.MenuItemAtlasFont.create = function (value, charMapFile, itemWidth, itemHeight, startCharMap, target, selector) {
    var ret = new cc.MenuItemAtlasFont();
    ret.initWithString(value, charMapFile, itemWidth, itemHeight, startCharMap, target, selector);
    return ret;
};


/**
 * Helper class that creates a CCMenuItemLabel class with a Label
 * @class
 * @extends cc.MenuItemLabel
 */
cc.MenuItemFont = cc.MenuItemLabel.extend(/** @lends cc.MenuItemFont# */{

    /**
     * @param {String} value text for the menu item
     * @param {cc.Node} target
     * @param {function|String} selector
     * @return {Boolean}
     */
    initWithString:function (value, target, selector) {
        cc.Assert(value != null && value.length != 0, "Value length must be greater than 0");

        this._fontName = cc._fontName;
        this._fontSize = cc._fontSize;

        var label = cc.LabelTTF.create(value, this._fontName, this._fontSize);
        if (this.initWithLabel(label, target, selector)) {
            // do something ?
        }
        return true;
    },

    /**
     * @param {Number} s
     */
    setFontSizeObj:function (s) {
        this._fontSize = s;
        this._recreateLabel();
    },

    /**
     *
     * @return {Number}
     */
    fontSizeObj:function () {
        return this._fontSize;
    },

    /**
     * @param {String} name
     */
    setFontNameObj:function (name) {
        this._fontName = name;
        this._recreateLabel();
    },

    /**
     * @return {String}
     */
    fontNameObj:function () {
        return this._fontName;
    },
    _recreateLabel:function () {
        var label = cc.LabelTTF.create(this._label.getString(),
            this._fontName, this._fontSize);
        this.setLabel(label);
    },
    _fontSize:0,
    _fontName:''
});

/**
 * a shared function to set the fontSize for menuitem font
 * @param {Number} fontSize
 */
cc.MenuItemFont.setFontSize = function (fontSize) {
    cc._fontSize = fontSize;
};

/**
 * a shared function to get the font size for menuitem font
 * @return {Number}
 */
cc.MenuItemFont.fontSize = function () {
    return cc._fontSize;
};

/**
 * a shared function to set the fontsize for menuitem font
 * @param name
 */
cc.MenuItemFont.setFontName = function (name) {
    if (cc._fontNameRelease) {
        cc._fontName = '';
    }
    cc._fontName = name;
    cc._fontNameRelease = true;
};

/**
 * a shared function to get the font name for menuitem font
 * @return {String}
 */
cc.MenuItemFont.fontName = function () {
    return cc._fontName
};

/**
 * create a menu item from string
 * @param {String} value the text to display
 * @param {cc.Node|Null} target the target to run callback
 * @param {String|function|Null} selector the callback to run, either in function name or pass in the actual function
 * @return {cc.MenuItemFont}
 * @example
 * // Example
 * var item = cc.MenuItemFont.create("Game start", Game, 'start')
 * //creates a menu item from string "Game start", and when clicked, it will run Game.start()
 *
 * var item = cc.MenuItemFont.create("Game start", Game, game.start)//same as above
 *
 * var item = cc.MenuItemFont.create("i do nothing")//create a text menu item that does nothing
 *
 * //you can set font size and name before or after
 * cc.MenuItemFont.setFontName('my Fancy Font');
 * cc.MenuItemFont.setFontSize(62);
 */
cc.MenuItemFont.create = function (value, target, selector) {
    var ret = new cc.MenuItemFont();
    ret.initWithString(value, target, selector);
    return ret;
};


/**
 * CCMenuItemSprite accepts CCNode<CCRGBAProtocol> objects as items.<br/>
 The images has 3 different states:<br/>
 - unselected image<br/>
 - selected image<br/>
 - disabled image<br/>
 * @class
 * @extends cc.MenuItem
 */
cc.MenuItemSprite = cc.MenuItem.extend(/** @lends cc.MenuItemSprite# */{
    /**
     * identifies that this class implements RGBAProtocol methods
     */
    RGBAProtocol:true,
    _normalImage:null,

    /**
     * @return {cc.Node}
     */
    getNormalImage:function () {
        return this._normalImage;
    },

    /**
     * @param {cc.Node} normalImage
     */
    setNormalImage:function (normalImage) {
        if (this._normalImage == normalImage) {
            return;
        }
        if (normalImage) {
            this.addChild(normalImage, 0, cc.NORMAL_TAG);
            normalImage.setAnchorPoint(cc.p(0, 0));
        }
        if (this._normalImage) {
            this.removeChild(this._normalImage, true);
        }

        this._normalImage = normalImage;
        this.setContentSize(this._normalImage.getContentSize());
        this._updateImagesVisibility();
    },
    _selectedImage:null,

    /**
     * @return {cc.Node}
     */
    getSelectedImage:function () {
        return this._selectedImage;
    },

    /**
     * @param {cc.Node} selectedImage
     */
    setSelectedImage:function (selectedImage) {
        if (this._selectedImage == selectedImage)
            return;

        if (selectedImage) {
            this.addChild(selectedImage, 0, cc.SELECTED_TAG);
            selectedImage.setAnchorPoint(cc.p(0, 0));
        }

        if (this._selectedImage) {
            this.removeChild(this._selectedImage, true);
        }

        this._selectedImage = selectedImage;
        this._updateImagesVisibility();
    },
    _disabledImage:null,

    /**
     * @return {cc.Sprite}
     */
    getDisabledImage:function () {
        return this._disabledImage;
    },

    /**
     * @param {cc.Sprite} disabledImage
     */
    setDisabledImage:function (disabledImage) {
        if (this._disabledImage == disabledImage)
            return;

        if (disabledImage) {
            this.addChild(disabledImage, 0, cc.DISABLE_TAG);
            disabledImage.setAnchorPoint(cc.p(0, 0));
        }

        if (this._disabledImage) {
            this.removeChild(this._disabledImage, true);
        }

        this._disabledImage = disabledImage;
        this._updateImagesVisibility();
    },

    /**
     * @param {cc.Sprite} normalSprite
     * @param {cc.Sprite} selectedSprite
     * @param {cc.Sprite} disabledSprite
     * @param {cc.Node} target
     * @param {function|String} selector
     * @return {Boolean}
     */
    initWithNormalSprite:function (normalSprite, selectedSprite, disabledSprite, target, selector) {
        this.initWithCallback(target, selector);
        this.setNormalImage(normalSprite);
        this.setSelectedImage(selectedSprite);
        this.setDisabledImage(disabledSprite);
        if (this._normalImage) {
            this.setContentSize(this._normalImage.getContentSize());
        }
        return true;
    },

    /**
     * @param {cc.Color3B} color
     */
    setColor:function (color) {
        this._normalImage.setColor(color);

        if (this._selectedImage) {
            this._selectedImage.setColor(color);
        }

        if (this._disabledImage) {
            this._disabledImage.setColor(color);
        }
    },

    /**
     * @return {cc.Color3B}
     */
    getColor:function () {
        return this._normalImage.getColor();
    },

    /**
     * @param {Number} opacity 0 - 255
     */
    setOpacity:function (opacity) {
        this._normalImage.setOpacity(opacity);

        if (this._selectedImage) {
            this._selectedImage.setOpacity(opacity);
        }

        if (this._disabledImage) {
            this._disabledImage.setOpacity(opacity);
        }
    },

    /**
     * @return {Number} opacity from 0 - 255
     */
    getOpacity:function () {
        return this._normalImage.getOpacity();
    },

    /**
     * menu item is selected (runs callback)
     */
    selected:function () {
        this._super();
        if (this._normalImage) {
            if (this._disabledImage) {
                this._disabledImage.setVisible(false);
            }

            if (this._selectedImage) {
                this._normalImage.setVisible(false);
                this._selectedImage.setVisible(true);
            }
            else {
                this._normalImage.setVisible(true);
            }
        }
    },

    /**
     * menu item goes back to unselected state
     */
    unselected:function () {
        this._super();

        if (this._normalImage) {
            this._normalImage.setVisible(true);

            if (this._selectedImage) {
                this._selectedImage.setVisible(false);
            }

            if (this._disabledImage) {
                this._disabledImage.setVisible(false);
            }
        }
    },

    /**
     * @param {Boolean} bEnabled
     */
    setEnabled:function (bEnabled) {
        if (this._isEnabled != bEnabled) {
            this._super(bEnabled);
            this._updateImagesVisibility();
        }
    },

    setOpacityModifyRGB:function (value) {
    },

    isOpacityModifyRGB:function () {
        return false;
    },

    _updateImagesVisibility:function () {
        if (this._isEnabled) {
            if (this._normalImage)
                this._normalImage.setVisible(true);
            if (this._selectedImage)
                this._selectedImage.setVisible(false);
            if (this._disabledImage)
                this._disabledImage.setVisible(false);
        } else {
            if (this._disabledImage) {
                if (this._normalImage)
                    this._normalImage.setVisible(false);
                if (this._selectedImage)
                    this._selectedImage.setVisible(false);
                if (this._disabledImage)
                    this._disabledImage.setVisible(true);
            } else {
                if (this._normalImage)
                    this._normalImage.setVisible(true);
                if (this._selectedImage)
                    this._selectedImage.setVisible(false);
                if (this._disabledImage)
                    this._disabledImage.setVisible(false);
            }
        }
    }
});

/**
 * create a menu item from sprite
 * @param {Image} normal normal state image
 * @param {Image|Null} selected selected state image
 * @param {Image|cc.Node|Null} three disabled state image OR target node
 * @param {String|function|cc.Node|Null} four callback function name in string or actual function, OR target Node
 * @param {String|function|Null} five callback function name in string or actual function
 * @return {cc.MenuItemSprite}
 * @example
 * // Example
 * var item = cc.MenuItemSprite.create(normalImage)//create a menu item from a sprite with no functionality
 *
 * var item = cc.MenuItemSprite.create(normalImage, selectedImage)//create a menu Item, nothing will happen when clicked
 *
 * var item = cc.MenuItemSprite.create(normalImage, SelectedImage, disabledImage)//same above, but with disabled state image
 *
 * var item = cc.MenuItemSprite.create(normalImage, SelectedImage, targetNode, 'callback')//create a menu item, when clicked runs targetNode.callback()
 *
 * var item = cc.MenuItemSprite.create(normalImage, SelectedImage, disabledImage, targetNode, targetNode.callback)
 * //same as above, but with disabled image, and passing in callback function
 */
cc.MenuItemSprite.create = function (normalSprite, selectedSprite, three, four, five) {
    var len = arguments.length;
    var normalSprite = arguments[0], selectedSprite = arguments[1], disabledImage, target, callback;
    var ret = new cc.MenuItemSprite();
    //when you send 4 arguments, five is undefined
    if (len == 5) {
        disabledImage = arguments[2], target = arguments[3], callback = arguments[4]
    }
    else if (len == 4) {
        target = arguments[2], callback = arguments[3];
    }
    else if (len <= 3) {
        disabledImage = arguments[2];
    }
    ret.initWithNormalSprite(normalSprite, selectedSprite, disabledImage, target, callback);
    return ret;
};


/**
 * cc.MenuItemImage accepts images as items.<br/>
 * The images has 3 different states:<br/>
 * - unselected image<br/>
 * - selected image<br/>
 * - disabled image<br/>
 * <br/>
 * For best results try that all images are of the same size<br/>
 * @class
 * @extends cc.MenuItemSprite
 */
cc.MenuItemImage = cc.MenuItemSprite.extend(/** @lends cc.MenuItemImage# */{
    /**
     * sets the sprite frame for the normal image
     * @param {cc.SpriteFrame} frame
     */
    setNormalSpriteFrame:function (frame) {
        this.setNormalImage(cc.Sprite.createWithSpriteFrameName(frame));
    },

    /**
     * sets the sprite frame for the selected image
     * @param {cc.SpriteFrame} frame
     */
    setSelectedSpriteFrame:function (frame) {
        this.setSelectedImage(cc.Sprite.createWithSpriteFrameName(frame));
    },

    /**
     * sets the sprite frame for the disabled image
     * @param {cc.SpriteFrame} frame
     */
    setDisabledSpriteFrame:function (frame) {
        this.setDisabledImage(cc.Sprite.createWithSpriteFrameName(frame));
    },

    /**
     * @return {Boolean}
     */
    initWithNormalImage:function (normalImage, selectedImage, disabledImage, target, selector) {
        var normalSprite = null;
        var selectedSprite = null;
        var disabledSprite = null;

        if (normalImage) {
            normalSprite = cc.Sprite.create(normalImage);
        }
        if (selectedImage) {
            selectedSprite = cc.Sprite.create(selectedImage);
        }
        if (disabledImage) {
            disabledSprite = cc.Sprite.create(disabledImage);
        }
        return this.initWithNormalSprite(normalSprite, selectedSprite, disabledSprite, target, selector);
    }
});

/**
 * creates a new menu item image
 * @param {String} normalImage file name for normal state
 * @param {String} selectedImage image for selected state
 * @param {String|cc.Node} three Disabled image OR target
 * @param {cc.Node|String|function|Null} four cc.Node target to run callback when clicked OR the callback
 * @param {String|function|Null} five callback function, either name in string, or pass the whole function
 * @return {cc.MenuItemImage}
 * @example
 * // Example
 * var item = cc.MenuItemImage.create('normal.png', 'selected.png', gameScene, 'run')
 * //create a dom menu item with normal and selected state, when clicked it will run the run function from gameScene object
 *
 * var item = cc.MenuItemImage.create('normal.png', 'selected.png', 'disabled.png',  gameScene, gameScene.run)
 * //same as above, but pass in the actual function and disabled image
 */
cc.MenuItemImage.create = function (normalImage, selectedImage, three, four, five) {
    if (arguments.length == 0) {
        return cc.MenuItemImage.create(null, null, null, null, null);
    }
    if (arguments.length == 4) {
        return cc.MenuItemImage.create(normalImage, selectedImage, null, three, four);
    }
    var ret = new cc.MenuItemImage();
    if (ret.initWithNormalImage(normalImage, selectedImage, three, four, five)) {
        return ret;
    }
    return null;
};


/**
 * A simple container class that "toggles" it's inner items<br/>
 * The inner items can be any MenuItem
 * @class
 * @extends cc.MenuItem
 */
cc.MenuItemToggle = cc.MenuItem.extend(/** @lends cc.MenuItemToggle# */{

    /**
     * this identifies this class implements RGBAProtocol methods
     */
    RGBAProtocol:true,
    _opacity:0,

    /**
     * @return {Number}
     */
    getOpacity:function () {
        return this._opacity;
    },

    /**
     * @param {Number} Opacity
     */
    setOpacity:function (Opacity) {
        this._opacity = Opacity;
        if (this._subItems && this._subItems.length > 0) {
            for (var it = 0; it < this._subItems.length; it++) {
                this._subItems[it].setOpacity(Opacity);
            }
        }
    },
    _color:new cc.Color3B(),

    /**
     * @return {cc.Color3B}
     */
    getColor:function () {
        return this._color;
    },

    /**
     * @param {cc.Color3B} Color
     */
    setColor:function (Color) {
        this._color = Color;
        if (this._subItems && this._subItems.length > 0) {
            for (var it = 0; it < this._subItems.length; it++) {
                this._subItems[it].setColor(Color);
            }
        }
    },
    _selectedIndex:0,

    /**
     * @return {Number}
     */
    getSelectedIndex:function () {
        return this._selectedIndex;
    },

    /**
     * @param {Number} SelectedIndex
     */
    setSelectedIndex:function (SelectedIndex) {
        if (SelectedIndex != this._selectedIndex) {
            this._selectedIndex = SelectedIndex;
            var currItem = this.getChildByTag(cc.CURRENT_ITEM);
            if (currItem) {
                currItem.removeFromParentAndCleanup(false);
            }

            var item = this._subItems[this._selectedIndex];
            this.addChild(item, 0, cc.CURRENT_ITEM);
            var s = item.getContentSize();
            this.setContentSize(s);
            item.setPosition(cc.p(s.width / 2, s.height / 2));
        }
    },
    _subItems:[],

    /**
     * similar to get children
     * @return {cc.MenuItem}
     */
    getSubItems:function () {
        return this._subItems;
    },

    /**
     * @param {cc.MenuItem} SubItems
     */
    setSubItems:function (SubItems) {
        this._subItems = SubItems;
    },

    /**
     * @param {cc.Node} args[0] the first item in the args array is a target
     * @param {function|String} args[1] the second item in the args array is the callback
     * @param {cc.MenuItem} args[2+] the rest in the array are cc.MenuItems
     * @return {Boolean}
     */
    initWithCallback:function (args) {
        if (args.length < 2) {
            return false;
        }
        var target = args[0], selector = args[1];
        this._super(target, selector);
        if (args.length == 2) {
            return false;
        }
        this._subItems = [];
        for (var i = 2; i < args.length; i++) {
            if (args[i]) {
                this._subItems.push(args[i]);
            }
        }
        this._selectedIndex = cc.UINT_MAX;
        this.setSelectedIndex(0);
        return true;
    },

    /**
     * @param {cc.MenuItem} item
     * @return {Boolean}
     */
    initWithItem:function (item) {
        this.initWithCallback(null, null);
        this._subItems = [];
        this._subItems.push(item);
        this._selectedIndex = cc.UINT_MAX;
        this.setSelectedIndex(0);
        return true;
    },

    /**
     * @param {cc.MenuItem} args[1+] items
     * @return {Boolean}
     */
    initWithItems:function (args) {
        this.initWithCallback(null, null);
        this._subItems = [];
        for (var i = 0; i < args.length; i++) {
            if (args[i]) {
                this._subItems.push(args[i]);
            }
        }
        this._selectedIndex = cc.UINT_MAX;
        this.setSelectedIndex(0);
        return true;
    },

    /**
     * @param {cc.MenuItem} item
     */
    addSubItem:function (item) {
        this._subItems.push(item);
    },

    /**
     * activate the menu item
     */
    activate:function () {
        // update index
        if (this._isEnabled) {
            var newIndex = (this._selectedIndex + 1) % this._subItems.length;
            this.setSelectedIndex(newIndex);
        }
        this._super();
    },

    /**
     * menu item is selected (runs callback)
     */
    selected:function () {
        this._super();
        this._subItems[this._selectedIndex].selected();
    },

    /**
     * menu item goes back to unselected state
     */
    unselected:function () {
        this._super();
        this._subItems[this._selectedIndex].unselected();
    },

    /**
     * @param {Boolean} enabled
     */
    setEnabled:function (enabled) {
        if (this._isEnabled = enabled) {
            this._super(enabled);

            if (this._subItems && this._subItems.length > 0) {
                for (var it = 0; it < this._subItems.length; it++) {
                    this._subItems[it].setEnabled(enabled);
                }
            }
        }
    },

    /**
     * returns the selected item
     * @return {cc.MenuItem}
     */
    selectedItem:function () {
        return this._subItems[this._selectedIndex];
    },

    setOpacityModifyRGB:function (value) {
    },

    isOpacityModifyRGB:function () {
        return false;
    },
    onEnter:function () {
        this._super();
        this.setSelectedIndex(this._selectedIndex);
    }
});

/**
 * create a simple container class that "toggles" it's inner items<br/>
 * The inner items can be any MenuItem
 * @return {cc.MenuItemToggle}
 * @example
 * // Example
 *
 * //create a toggle item with 2 menu items (which you can then toggle between them later)
 * var toggler = cc.MenuItemToggle.create(this, this.callback, cc.MenuItemFont.create("On"), cc.MenuItemFont.create("Off"))
 * //Note: the first param is the target, the second is the callback function, afterwards, you can pass in any number of menuitems
 *
 * //if you pass only 1 variable, then it must be a cc.MenuItem
 * var notYetToggler = cc.MenuItemToggle.create(cc.MenuItemFont.create("On"));//it is useless right now, until you add more stuff to it
 * notYetToggler.addSubItem(cc.MenuItemFont.create("Off"));
 * //this is useful for constructing a toggler without a callback function (you wish to control the behavior from somewhere else)
 */
cc.MenuItemToggle.create = function (/*Multiple arguments follow*/) {
    var ret = new cc.MenuItemToggle();
    //ret.initWithItems(arguments);
    if (arguments.length == 1) {
        ret.initWithItem(arguments);
    } else {
        ret.initWithCallback(arguments);
    }
    return ret;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

/**
 * @constant
 * @type Number
 */
cc.MENU_STATE_WAITING = 0;
/**
 * @constant
 * @type Number
 */
cc.MENU_STATE_TRACKING_TOUCH = 1;
/**
 * @constant
 * @type Number
 */
cc.MENU_HANDLER_PRIORITY = -128;
/**
 * @constant
 * @type Number
 */
cc.DEFAULT_PADDING = 5;

/**
 * <p> Features and Limitation:<br/>
 *  - You can add MenuItem objects in runtime using addChild:<br/>
 *  - But the only accecpted children are MenuItem objects</p>
 * @class
 * @extends cc.Layer
 */
cc.Menu = cc.Layer.extend(/** @lends cc.Menu# */{
    RGBAProtocol:true,
    _color:new cc.Color3B(),

    /**
     * @return {cc.Color3B}
     */
    getColor:function () {
        return this._color;
    },

    /**
     * @param {cc.Color3B} color
     */
    setColor:function (color) {
        this._color = color;

        if (this._children && this._children.length > 0) {
            for (var i = 0; i < this._children.length; i++) {
                this._children[i].setColor(this._color);
            }
        }
    },

    _opacity:0,

    /**
     * @return {Number}
     */
    getOpacity:function () {
        return this._opacity;
    },

    /**
     * @param {Number} opa
     */
    setOpacity:function (opa) {
        this._opacity = opa;
        if (this._children && this._children.length > 0) {
            for (var i = 0; i < this._children.length; i++) {
                this._children[i].setOpacity(this._opacity);
            }
        }
    },

    _enabled:false,

    /**
     * return whether or not the menu will receive events
     * @return {Boolean}
     */
    isEnabled:function () {
        return this._enabled;
    },

    /**
     * set whether or not the menu will receive events
     * @param {Boolean} enabled
     */
    setEnabled:function (enabled) {
        this._enabled = enabled;
    },

    _selectedItem:null,

    /**
     * initializes a cc.Menu with it's items
     * @param {Array} args
     * @return {Boolean}
     */
    initWithItems:function (args) {
        var pArray = [];
        if (args) {
            for (var i = 0; i < args.length; i++) {
                if (args[i]) {
                    pArray.push(args[i]);
                }
            }
        }

        return this.initWithArray(pArray);
    },

    /**
     * initializes a cc.Menu with a Array of cc.MenuItem objects
     */
    initWithArray:function (arrayOfItems) {
        if(this.init()){
            this.setTouchEnabled(true);
            this._enabled = true;

            // menu in the center of the screen
            var winSize = cc.Director.getInstance().getWinSize();
            this.ignoreAnchorPointForPosition(true);
            this.setAnchorPoint(cc.p(0.5, 0.5));
            this.setContentSize(winSize);

            this.setPosition(cc.p(winSize.width / 2, winSize.height / 2));

            if(arrayOfItems){
                for(var i = 0; i< arrayOfItems.length; i++){
                    this.addChild(arrayOfItems[i],i);
                }
            }

            this._selectedItem = null;
            this._state = cc.MENU_STATE_WAITING;
            return true;
        }
        return false;
    },

    /**
     * @param {cc.Node} child
     * @param {Number|Null} zOrder
     * @param {Number|Null} tag
     */
    addChild:function (child, zOrder, tag) {
        cc.Assert((child instanceof cc.MenuItem), "Menu only supports MenuItem objects as children");
        this._super(child, zOrder, tag);
    },

    /**
     * align items vertically with default padding
     */
    alignItemsVertically:function () {
        this.alignItemsVerticallyWithPadding(cc.DEFAULT_PADDING);
    },

    /**
     * align items vertically with specified padding
     * @param {Number} padding
     */
    alignItemsVerticallyWithPadding:function (padding) {
        var height = -padding;
        if (this._children && this._children.length > 0) {
            for (var i = 0; i < this._children.length; i++) {
                height += this._children[i].getContentSize().height * this._children[i].getScaleY() + padding;
            }
        }

        var y = height / 2.0;
        if (this._children && this._children.length > 0) {
            for (i = 0; i < this._children.length; i++) {
                this._children[i].setPosition(cc.p(0, y - this._children[i].getContentSize().height * this._children[i].getScaleY() / 2));
                y -= this._children[i].getContentSize().height * this._children[i].getScaleY() + padding;
            }
        }
    },

    /**
     * align items horizontally with default padding
     */
    alignItemsHorizontally:function () {
        this.alignItemsHorizontallyWithPadding(cc.DEFAULT_PADDING);
    },

    /**
     * align items horizontally with specified padding
     * @param {Number} padding
     */
    alignItemsHorizontallyWithPadding:function (padding) {
        var width = -padding;
        if (this._children && this._children.length > 0) {
            for (var i = 0; i < this._children.length; i++) {
                width += this._children[i].getContentSize().width * this._children[i].getScaleX() + padding;
            }
        }

        var x = -width / 2.0;
        if (this._children && this._children.length > 0) {
            for (i = 0; i < this._children.length; i++) {
                this._children[i].setPosition(cc.p(x + this._children[i].getContentSize().width * this._children[i].getScaleX() / 2, 0));
                x += this._children[i].getContentSize().width * this._children[i].getScaleX() + padding;
            }
        }
    },

    /**
     * align items in columns
     * @example
     * // Example
     * menu.alignItemsInColumns(3,2,3)// this will create 3 columns, with 3 items for first column, 2 items for second and 3 for third
     *
     * menu.alignItemsInColumns(3,3)//this creates 2 columns, each have 3 items
     */
    alignItemsInColumns:function (/*Multiple Arguments*/) {
        var rows = [];
        for (var i = 0; i < arguments.length; i++) {
            rows.push(arguments[i]);
        }
        var height = -5;
        var row = 0;
        var rowHeight = 0;
        var columnsOccupied = 0;
        var rowColumns;
        if (this._children && this._children.length > 0) {
            for (i = 0; i < this._children.length; i++) {
                cc.Assert(row < rows.length, "");

                rowColumns = rows[row];
                // can not have zero columns on a row
                cc.Assert(rowColumns, "");

                var tmp = this._children[i].getContentSize().height;
                rowHeight = ((rowHeight >= tmp || isNaN(tmp)) ? rowHeight : tmp);

                ++columnsOccupied;
                if (columnsOccupied >= rowColumns) {
                    height += rowHeight + 5;

                    columnsOccupied = 0;
                    rowHeight = 0;
                    ++row;
                }
            }
        }
        // check if too many rows/columns for available menu items
        cc.Assert(!columnsOccupied, "");
        var winSize = cc.Director.getInstance().getWinSize();

        row = 0;
        rowHeight = 0;
        rowColumns = 0;
        var w = 0.0;
        var x = 0.0;
        var y = (height / 2);

        if (this._children && this._children.length > 0) {
            for (i = 0; i < this._children.length; i++) {
                var child = this._children[i];
                if (rowColumns == 0) {
                    rowColumns = rows[row];
                    w = winSize.width / (1 + rowColumns);
                    x = w;
                }

                var tmp = child.getContentSize().height;
                rowHeight = ((rowHeight >= tmp || isNaN(tmp)) ? rowHeight : tmp);

                child.setPosition(cc.p(x - winSize.width / 2,
                    y - child.getContentSize().height / 2));

                x += w;
                ++columnsOccupied;

                if (columnsOccupied >= rowColumns) {
                    y -= rowHeight + 5;

                    columnsOccupied = 0;
                    rowColumns = 0;
                    rowHeight = 0;
                    ++row;
                }
            }
        }
    },
    /**
     * align menu items in rows
     * @example
     * // Example
     * menu.alignItemsInRows(5,3)//this will align items to 2 rows, first row with 5 items, second row with 3
     *
     * menu.alignItemsInRows(4,4,4,4)//this creates 4 rows each have 4 items
     */
    alignItemsInRows:function (/*Multiple arguments*/) {
        var columns = [];
        for (var i = 0; i < arguments.length; i++) {
            columns.push(arguments[i]);
        }
        var columnWidths = [];
        var columnHeights = [];

        var width = -10;
        var columnHeight = -5;
        var column = 0;
        var columnWidth = 0;
        var rowsOccupied = 0;
        var columnRows;

        if (this._children && this._children.length > 0) {
            for (var i = 0; i < this._children.length; i++) {
                var child = this._children[i];
                // check if too many menu items for the amount of rows/columns
                cc.Assert(column < columns.size(), "");

                columnRows = columns[column];
                // can't have zero rows on a column
                cc.Assert(columnRows, "");

                // columnWidth = fmaxf(columnWidth, [item contentSize].width);
                var tmp = child.getContentSize().width;
                columnWidth = ((columnWidth >= tmp || isNaN(tmp)) ? columnWidth : tmp);

                columnHeight += (child.getContentSize().height + 5);
                ++rowsOccupied;

                if (rowsOccupied >= columnRows) {
                    columnWidths.push(columnWidth);
                    columnHeights.push(columnHeight);
                    width += columnWidth + 10;

                    rowsOccupied = 0;
                    columnWidth = 0;
                    columnHeight = -5;
                    ++column;
                }
            }
        }
        // check if too many rows/columns for available menu items.
        cc.Assert(!rowsOccupied, "");

        var winSize = cc.Director.getInstance().getWinSize();

        column = 0;
        columnWidth = 0;
        columnRows = 0;
        var x = -width / 2;
        var y = 0.0;

        if (this._children && this._children.length > 0) {
            for (var i = 0; i < this._children.length; i++) {
                var child = this._children[i];
                if (columnRows == 0) {
                    columnRows = columns[column];
                    y = columnHeights[column];
                }

                // columnWidth = fmaxf(columnWidth, [item contentSize].width);
                var tmp = child.getContentSize().width;
                columnWidth = ((columnWidth >= tmp || isNaN(tmp)) ? columnWidth : tmp);

                child.setPosition(cc.p(x + columnWidths[column] / 2,
                    y - winSize.height / 2));

                y -= child.getContentSize().height + 10;
                ++rowsOccupied;

                if (rowsOccupied >= columnRows) {
                    x += columnWidth + 5;
                    rowsOccupied = 0;
                    columnRows = 0;
                    columnWidth = 0;
                    ++column;
                }
            }
        }
    },

    /**
     * make the menu clickable
     */
    registerWithTouchDispatcher:function () {
        cc.Director.getInstance().getTouchDispatcher().addTargetedDelegate(this, cc.MENU_HANDLER_PRIORITY, true);
    },

    /**
     * @param {cc.Touch} touch
     * @return {Boolean}
     */
    onTouchBegan:function (touch, e) {
        if (this._state != cc.MENU_STATE_WAITING || !this._isVisible || !this._enabled) {
            return false;
        }

        for (var c = this._parent; c != null; c = c.getParent()) {
            if (!c.isVisible()) {
                return false;
            }
        }

        this._selectedItem = this._itemForTouch(touch);
        if (this._selectedItem) {
            this._state = cc.MENU_STATE_TRACKING_TOUCH;
            this._selectedItem.selected();
            return true;
        }
        return false;
    },

    /**
     * when a touch ended
     */
    onTouchEnded:function (touch, e) {
        cc.Assert(this._state == cc.MENU_STATE_TRACKING_TOUCH, "[Menu onTouchEnded] -- invalid state");
        if (this._selectedItem) {
            this._selectedItem.unselected();
            this._selectedItem.activate();
        }
        this._state = cc.MENU_STATE_WAITING;
    },

    /**
     * touch cancelled
     */
    onTouchCancelled:function (touch, e) {
        cc.Assert(this._state == cc.MENU_STATE_TRACKING_TOUCH, "[Menu onTouchCancelled] -- invalid state");
        if (this._selectedItem) {
            this._selectedItem.unselected();
        }
        this._state = cc.MENU_STATE_WAITING;
    },

    /**
     * touch moved
     * @param {cc.Touch} touch
     */
    onTouchMoved:function (touch, e) {
        cc.Assert(this._state == cc.MENU_STATE_TRACKING_TOUCH, "[Menu onTouchMoved] -- invalid state");
        var currentItem = this._itemForTouch(touch);
        if (currentItem != this._selectedItem) {
            if (this._selectedItem) {
                this._selectedItem.unselected();
            }
            this._selectedItem = currentItem;
            if (this._selectedItem) {
                this._selectedItem.selected();
            }
        }
    },

    /**
     * custom on exit
     */
    onExit:function () {
        if (this._state == cc.MENU_STATE_TRACKING_TOUCH) {
            this._selectedItem.unselected();
            this._state = cc.MENU_STATE_WAITING;
            this._selectedItem = null;
        }

        this._super();
    },

    setOpacityModifyRGB:function (value) {
    },

    isOpacityModifyRGB:function () {
        return false;
    },

    _itemForTouch:function (touch) {
        var touchLocation = touch.getLocation();

        if (this._children && this._children.length > 0) {
            for (var i = 0; i < this._children.length; i++) {
                if (this._children[i].isVisible() && this._children[i].isEnabled()) {
                    var local = this._children[i].convertToNodeSpace(touchLocation);
                    var r = this._children[i].rect();
                    r.origin = cc.p(0,0);
                    if (cc.Rect.CCRectContainsPoint(r, local)) {
                        return this._children[i];
                    }
                }
            }
        }

        return null;
    },
    _state:-1,

    /**
     * set event handler priority. By default it is: kCCMenuTouchPriority
     * @param {Number} newPriority
     */
    setHandlerPriority:function (newPriority) {
        cc.Director.getInstance().getTouchDispatcher().setPriority(newPriority, this);
    }
});

/**
 * create a new menu
 * @return {cc.Menu}
 * @example
 * // Example
 * //there is no limit on how many menu item you can pass in
 * var myMenu = cc.Menu.create(menuitem1, menuitem2, menuitem3);
 */
cc.Menu.create = function (/*Multiple Arguments*/) {
    var ret = new cc.Menu();

    if (arguments.length == 0) {
        ret.initWithItems(null, null);
    } else if (arguments.length == 1) {
        if (arguments[0] instanceof Array) {
            ret.initWithArray(arguments[0]);
            return ret;
        }
    }
    ret.initWithItems(arguments);
    return ret;
};
/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/
/**
 * the DOM object
 * @class
 * @type {Object}
 */
cc.DOM = {};
/**
 * Set to true to enalbe DOM debugging/editing, which allows you to move, rotate, scale, skew an element.
 * Set to false to turn off debugging/editing
 * @type Boolean
 */
cc.DOMEditMode = true;
/**
 * @function
 * @private
 * @param x
 */
cc.DOM.addMethods = function (x) {
    for (funcs in cc.DOM.methods) {
        x[funcs] = cc.DOM.methods[funcs];
    }
};
cc.DOM.methods = /** @lends cc.DOM# */{
    /**
     * Replace the set position of ccNode
     * @param {object|Number} x
     * @param {Number} y
     */
    setPosition:function (x, y) {
        if (y != null) {
            this._position.x = x;
            this._position.y = y;
            //this._position = cc.p(newPosOrxValue,yValue);
        } else {
            this._position = x;
        }
        this.dom.translates(this._position.x, -this._position.y);
    },
    /**
     * replace set Position Y of ccNode
     * @param {Number} y
     */
    setPositionY:function (y) {
        this._position.y = y;
        this.dom.translates(this._position.x, -this._position.y);
    },

    /**
     * replace set Position X of ccNode
     * @param {Number} x
     */
    setPositionX:function (x) {
        this._position.x = x;
        this.dom.translates(this._position.x, -this._position.y);
    },

    /**
     * replace set Scale of ccNode
     * @param {object|Number} scale
     * @param {Number} scaleY
     */
    setScale:function (scale, scaleY) {
        //save dirty region when before change
        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());

        this._scaleX = scale;
        this._scaleY = scaleY || scale;

        //save dirty region when after changed
        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());
        this.dom.resize(this._scaleX, this._scaleY);
    },

    /**
     * replace set Scale X of ccNode
     * @param {Number} x
     */
    setScaleX:function (x) {
        this._scaleX = x;
        this.dom.resize(this._scaleX, this._scaleY);
    },

    /**
     * replace set Scale Y of ccNode
     * @param {Number} y
     */
    setScaleY:function (y) {
        this._scaleY = y;
        this.dom.resize(this._scaleX, this._scaleY);
    },

    /**
     * replace set anchorpoint of ccNode
     * @param {object} point
     */
    setAnchorpoint:function (point) {
        this._anchorPoint = point;
        this._anchorPointInPoints = cc.p(this._contentSize.width * this._anchorPoint.x,
            this._contentSize.height * this._anchorPoint.y);
        this.dom.style[cc.$.pfx + 'TransformOrigin'] = '' + this._anchorPointInPoints.x + 'px ' + this._anchorPointInPoints.y + 'px';
        if (this.isIgnoreAnchorPointForPosition()) {
            this.dom.style.marginLeft = 0;
            this.dom.style.marginBottom = 0;
        }
        else {
            this.dom.style.marginLeft = (this.isToggler) ? 0 : -this._anchorPointInPoints.x + 'px';
            this.dom.style.marginBottom = -this._anchorPointInPoints.y + 'px';
        }
    },

    /**
     * replace set ContentSize of ccNode
     * @param {cc.Size} size
     */
    setContentSize:function (size) {
        if (!cc.Size.CCSizeEqualToSize(size, this._contentSize)) {
            this._contentSize = size;
            this._anchorPointInPoints = cc.p(this._contentSize.width * this._anchorPoint.x,
                this._contentSize.height * this._anchorPoint.y);
            this.dom.width = size.width;
            this.dom.height = size.height;
            this.setAnchorpoint(this.getAnchorPoint());
        }
        if (this.canvas) {
            this.canvas.width = this._contentSize.width;
            this.canvas.height = this._contentSize.height;
        }
        if (cc.DOMEditMode && !this.placeholder) {
            this.dom.style.width = this._contentSize.width + 'px';
            this.dom.style.height = this._contentSize.height + 'px';
            this.dom.addClass('CCDOMEdit');
        }
        this.redraw();
    },

    /**
     * replace set Rotation of ccNode
     * @param {Number} newRotation
     */
    setRotation:function (newRotation) {
        if (this._rotation == newRotation)
            return;
        //save dirty region when before change
        //this._addDirtyRegionToDirector(this.getBoundingBoxToWorld());

        this._rotation = newRotation;
        this._rotationRadians = this._rotation * (Math.PI / 180);
        this.dom.rotate(newRotation);
    },

    /**
     * replace set SkewX of ccNode
     * @param {Number} x
     */
    setSkewX:function (x) {
        this._skewX = x;
        this.dom.setSkew(this._skewX, this._skewY);
    },

    /**
     * replace set SkewY of ccNode
     * @param {Number} y
     */
    setSkewY:function (y) {
        this._skewY = y;
        this.dom.setSkew(this._skewX, this._skewY);
    },

    /**
     * replace set Visible of ccNode
     * @param {Boolean} x
     */
    setVisible:function (x) {
        this._isVisible = x;
        if (this.dom)
            this.dom.style.visibility = (x) ? 'visible' : 'hidden';
    },
    _setZOrder:function (z) {
        this._zOrder = z;
        if (this.dom)
            this.dom.zIndex = z;
    },

    /**
     * replace set Parent of ccNode
     * @param {cc.Node} p
     */
    setParent:function (p) {
        this._parent = p;
        cc.DOM.parentDOM(this);
    },

    /**
     * replace resume Schedule and actions of ccNode
     */
    resumeSchedulerAndActions:function () {
        this.getScheduler().resumeTarget(this);
        this.getActionManager().resumeTarget(this);
        //if dom does not have parent, but node has no parent and its running
        if (this.dom && !this.dom.parentNode) {
            if (!this.getParent()) {
                this.dom.appendTo(cc.container);
            }
            else {
                cc.DOM.parentDOM(this);
            }
        }
        if (this.dom)
            this.dom.style.visibility = "visible";
    },

    /**
     * replace pause Schedule and Actions of ccNode
     */
    pauseSchedulerAndActions:function () {
        this.getScheduler().pauseTarget(this);
        this.getActionManager().pauseTarget(this);
        if (this.dom) {
            this.dom.style.visibility = 'hidden';
        }
    },

    /**
     * replace clean up of ccNode
     */
    cleanup:function () {
        // actions
        this.stopAllActions();
        this.unscheduleAllSelectors();

        // timers
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node.StateCallbackType.cleanup);
        if (this.dom) {
            this.dom.remove();
            //this.dom=null;
        }
    },
    /**
     * replace remove from parent and clean up of ccNode
     */
    removeFromParentAndCleanup:function () {
        this.dom.remove();
        //this.dom=null;
    },
    setOpacity:function (o) {
        this._opacity = o;
        this.dom.style.opacity = o / 255;
    },
    /**
     * refresh/updates the DOM element
     */
    redraw:function () {
        if (this.isSprite) {
            var tmp = this._children;
            this._children = null;
            cc.Sprite.prototype.visit.call(this, this.ctx);
            this._children = tmp;
        }
        else {
            cc.Sprite.prototype.visit.call(this, this.ctx);
        }
    }
};
/**
 * @function
 * @private
 * @param x
 * @return {Boolean}
 */
cc.DOM.parentDOM = function (x) {
    var p = x.getParent();
    //if has parent, parent need to have dom too
    if (!p || !x.dom)
        return false;
    if (!p.dom) {
        cc.DOM.placeHolder(p);
        p.setParent = cc.DOM.methods.setParent;
    }
    //if parent have dom, attach self to parent
    x.dom.appendTo(p.dom);
    var pp;
    if (pp = p.getParent()) {
        cc.DOM.parentDOM(p);
    }
    else {
        //parent has no more parent, if its running, then add it to the container
        if (p.isRunning()) {
            p.dom.appendTo(cc.container);
        }
    }
    //x.dom.appendTo(cc.container);
    /*    var pp;
     if(pp = p.getParent())
     {
     p.parentDiv = p.parentDiv || this.parentDiv;
     }*/
};

/**
 * @function
 * @private
 * @param x
 */
cc.DOM.setTransform = function (x) {
    if (x.ctx) {
        /*        x.ctx.save();
         x.ctx.setTransform(1,0,0,1,0,0);
         x.ctx.clearRect(0,0,x.canvas.width, x.canvas.height);
         x.ctx.restore();*/
        x.ctx.translate(x.getAnchorPointInPoints().x, x.getAnchorPointInPoints().y);
        if (x.isSprite) {
            var tmp = x._children;
            x._children = null;
            cc.Sprite.prototype.visit.call(x, x.ctx);
            x._children = tmp;
        }
        else {
            cc.Sprite.prototype.visit.call(x, x.ctx);
        }
    }
    if (x.dom) {
        x.dom.position.x = x.getPosition().x;
        x.dom.position.y = -x.getPosition().y;
        x.dom.rotation = x.getRotation();
        x.dom.scale = {x:x.getScaleX(), y:x.getScaleY()};
        x.dom.skew = {x:x.getSkewX(), y:x.getSkewY()};
        if (x.setAnchorpoint)
            x.setAnchorpoint(x.getAnchorPoint());
        x.dom.transforms();
        x.dom.position.y = -x.getPosition().y;
        x.dom.rotation = x.getRotation();
        x.dom.scale = {x:x.getScaleX(), y:x.getScaleY()};
        x.dom.skew = {x:x.getSkewX(), y:x.getSkewY()};
        if (x.setAnchorpoint)
            x.setAnchorpoint(x.getAnchorPoint());
        x.dom.transforms();
    }

};

/**
 * @function
 * @private
 * @param x
 */
cc.DOM.forSprite = function (x) {
    x.dom = cc.$new('div');
    x.canvas = cc.$new('canvas');
    x.canvas.width = x.getContentSize().width;
    x.canvas.height = x.getContentSize().height;
    if (cc.DOMEditMode) {
        x.dom.style.width = x.getContentSize().width + 'px';
        x.dom.style.height = x.getContentSize().height + 'px';
        x.dom.addClass('CCDOMEdit');
    }
    x.dom.style.position = 'absolute';
    x.dom.style.bottom = 0;
    x.ctx = x.canvas.getContext('2d');
    x.dom.appendChild(x.canvas);
    if (x.getParent()) {
        cc.DOM.parentDOM(x);
    }
    x.isSprite = true;
};

/**
 * @function
 * @private
 * @param x
 */
cc.DOM.forMenuToggler = function (x) {
    x.dom = cc.$new('div');
    x.dom2 = cc.$new('div');
    x.dom.appendChild(x.dom2);
    for (var i = 0; i < x._subItems.length; i++) {
        cc.DOM.convert(x._subItems[i]);
        x.dom2.appendChild(x._subItems[i].dom);
        x._subItems[i].setPosition(cc.p(0, 0));
    }
    x.dom.style.marginLeft = 0;
    x.setSelectedIndex = function (SelectedIndex) {
        this._selectedIndex = SelectedIndex;
        for (var i = 0; i < this._subItems.length; i++) {
            this._subItems[i].setVisible(false);
        }
        this._subItems[SelectedIndex].setVisible(true);
    };


    x.setSelectedIndex(x.getSelectedIndex());
    x.dom2.addEventListener('click', function () {
        x.activate();
    });
    x.dom2.addEventListener('mousedown', function () {
        for (var i = 0; i < x._subItems.length; i++) {
            x._subItems[i]._isEnabled = true;
            x._subItems[i]._isRunning = true;
            x._subItems[i].selected();
            x._subItems[i]._isEnabled = false;
            x._subItems[i]._isRunning = false;
        }
        x._subItems[x.getSelectedIndex()]._isEnabled = true;
        x._subItems[x.getSelectedIndex()]._isRunning = true;

    });
    x.dom2.addEventListener('mouseup', function () {
        for (var i = 0; i < x._subItems.length; i++) {
            x._subItems[i]._isEnabled = true;
            x._subItems[i].unselected();
            x._subItems[i]._isEnabled = false;
        }
        x._subItems[x.getSelectedIndex()]._isEnabled = true;
    });
    x.dom2.addEventListener('mouseout', function () {
        if (x.mouseDown) {
            for (var i = 0; i < x._subItems.length; i++) {
                x._subItems[i]._isEnabled = true;
                x._subItems[i].unselected();
                x._subItems[i]._isEnabled = false;
            }
            x._subItems[x.getSelectedIndex()]._isEnabled = true;
            x.mouseDown = false;
        }
    });
    x.dom.style.position = "absolute";
    x.isToggler = true;
};

/**
 * @function
 * @private
 * @param x
 */
cc.DOM.forMenuItem = function (x) {
    x.dom = cc.$new('div');
    x.canvas = cc.$new('canvas');
    x.canvas.width = x.getContentSize().width;
    x.canvas.height = x.getContentSize().height;
    if (cc.DOMEditMode) {
        x.dom.style.width = x.getContentSize().width + 'px';
        x.dom.style.height = x.getContentSize().height + 'px';
        x.dom.addClass('CCDOMEdit');
    }
    x.dom.style.position = 'absolute';
    x.dom.style.bottom = 0;
    x.ctx = x.canvas.getContext('2d');
    x.dom.appendChild(x.canvas);
    if (x.getParent()) {
        cc.DOM.parentDOM(x);
    }
    if (x._selector) {
        //if menu item have callback
        x.canvas.addEventListener('click', function () {
            x.activate();
        });
        x.canvas.addEventListener('mousedown', function () {
            x.selected();
            x.ctx.save();
            x.ctx.setTransform(1, 0, 0, 1, 0, 0);
            x.ctx.clearRect(0, 0, x.canvas.width, x.canvas.height);
            x.ctx.restore();
            x.mouseDown = true;
            cc.Sprite.prototype.visit.call(x, x.ctx);
        });
        x.canvas.addEventListener('mouseup', function () {
            x.unselected();
            x.ctx.save();
            x.ctx.setTransform(1, 0, 0, 1, 0, 0);
            x.ctx.clearRect(0, 0, x.canvas.width, x.canvas.height);
            x.ctx.restore();
            cc.Sprite.prototype.visit.call(x, x.ctx);
        });
        x.canvas.addEventListener('mouseout', function () {
            if (x.mouseDown) {
                x.unselected();
                x.ctx.save();
                x.ctx.setTransform(1, 0, 0, 1, 0, 0);
                x.ctx.clearRect(0, 0, x.canvas.width, x.canvas.height);
                x.ctx.restore();
                cc.Sprite.prototype.visit.call(x, x.ctx);
                x.mouseDown = false;
            }
        })
    }
};

/**
 * This creates divs for parent Nodes that are related to the current node
 * @function
 * @private
 * @param x
 */
cc.DOM.placeHolder = function (x) {
    //creating a placeholder dom to simulate other ccNode in the hierachy
    x.dom = cc.$new('div');
    x.placeholder = true;
    x.dom.style.position = 'absolute';
    x.dom.style.bottom = 0;
    //x.dom.style.display='block';
    x.dom.style.width = (x.getContentSize().width || cc.Director.getInstance().getWinSize().width) + "px";
    x.dom.style.maxHeight = (x.getContentSize().height || cc.Director.getInstance().getWinSize().height) + "px";
    x.dom.style.margin = 0;
    cc.DOM.setTransform(x);
    x.dom.transforms();
    cc.DOM.addMethods(x);
    //x.dom.style.border = 'red 1px dotted';
};

/**
 * Converts cc.Sprite or cc.MenuItem to DOM elements <br/>
 * It currently only supports cc.Sprite and cc.MenuItem
 * @function
 * @param {cc.Sprite|cc.MenuItem|Array}
    * * @example
 * // example
 * cc.DOM.convert(Sprite1, Sprite2, Menuitem);
 *
 * var myDOMElements = [Sprite1, Sprite2, MenuItem];
 * cc.DOM.convert(myDOMElements);
 */
cc.DOM.convert = function () {
    //if passing by list, make it an array
    if (arguments.length > 1) {
        return cc.DOM.convert(arguments);
    }
    else if (arguments.length == 1 && !arguments[0].length) {
        return cc.DOM.convert([arguments[0]]);
    }
    var args = arguments[0];
    for (var i = 0; i < args.length; i++) {
        //first check if its sprite or menuitem
        if (args[i] instanceof cc.Sprite) {
            // create a canvas
            if (!args[i].dom)
                cc.DOM.forSprite(args[i]);
        }
        else if (args[i] instanceof cc.MenuItemToggle) {
            if (!args[i].dom)
                cc.DOM.forMenuToggler(args[i]);
        }

        else if (args[i] instanceof cc.MenuItem) {
            if (!args[i].dom)
                cc.DOM.forMenuItem(args[i]);
        }
        else {
            cc.log('DOM converter only supports sprite and menuitems yet');
        }
        cc.DOM.addMethods(args[i]);
        args[i].visit = function () {
        };
        args[i].transform = function () {
        };
        cc.DOM.setTransform(args[i]);
        args[i].setVisible(args[i].isVisible());
        if (cc.DOMEditMode) {
            //add hover event to popup inspector
            if (!cc.DOM.tooltip) {
                var style = cc.$new('style');
                style.textContent = ".CCDOMEdit:hover{border: rgba(255,0,0,0.5) 2px dashed;left: -2px;} .CCDOMEdit #CCCloseButton{width:80px;height:15px;background: rgba(0,0,0,0.4);border:1px solid #aaaaaa;font-size: 9px;line-height:9px;color:#bbbbbb;} .CCTipWindow .CCTipMove{cursor:move;} .CCTipWindow .CCTipRotate{cursor:w-resize;} .CCTipWindow .CCTipScale{cursor:ne-resize;} .CCTipWindow .CCTipSkew{cursor:se-resize;} .CCTipWindow input{width:40px;background: rgba(0,0,0,0.5);color:white;border:none;border-bottom: 1px solid #fff;} div.CCTipWindow:hover{color:rgb(50,50,255);}";
                document.body.appendChild(style);
                cc.container.style.overflow = "visible";
                var tip = cc.DOM.tooltip = cc.$new('div');
                tip.mouseDown = false;
                document.body.appendChild(tip);
                tip.addClass('CCTipWindow');
                tip.style.width = '140px';
                tip.style.height = '134px';
                tip.style.background = 'rgba(50,50,50,0.5)';
                tip.style.border = '1px rgba(255,255,255,0.5) solid';
                tip.style.borderRadius = '5px';
                tip.style.color = 'rgb(255,255,255)';
                tip.style.boxShadow = '0 0 10px 1px rgba(0,0,0,0.5)';
                tip.style.position = 'absolute';
                tip.style.display = 'none';
                tip.style.top = 0;
                tip.style.left = '-150px';
                tip.style[cc.$.pfx + "Transform"] = 'translate3d(0,0,100px)';
                tip.style[cc.$.pfx + 'UserSelect'] = 'none';
                tip.innerHTML = '<table><tr>' +
                    '<td><label class="CCTipMove">Move</label></td><td><input type="text" value="12" id="posx"/></td><td><input type="text" value="12" id="posy"/></td></tr>' +
                    '<tr><td><label class="CCTipRotate">Rotate</label></td><td><input type="text" value="12" id="rot"/></td></tr>' +
                    '<tr><td><label class="CCTipScale">Scale</label></td><td><input type="text" value="12" id="scalex"/></td><td><input type="text" value="12" id="scaley"/></td></tr>' +
                    '<tr><td><label class="CCTipSkew">Skew</label></td><td><input type="text" value="12" id="skewx"/></td><td><input type="text" value="12" id="skewy"/></td></tr>' +
                    '</table><button id="CCCloseButton">Close</button>';
                tip.updateNumbers = function () {
                    var t = cc.DOM.tooltip;
                    if (t.target) {
                        t.find("#posx").value = t.target._position.x;
                        t.find("#posy").value = t.target._position.y;
                        t.find("#rot").value = t.target._rotation;
                        t.find("#scalex").value = t.target._scaleX;
                        t.find("#scaley").value = t.target._scaleY;
                        t.find("#skewx").value = t.target._skewX;
                        t.find("#skewy").value = t.target._skewY;
                    }
                };
                tip.find('.CCTipMove').addEventListener('mousedown', function (e) {
                    tip.mode = 'move';
                    tip.initialpos = {x:e.clientX, y:e.clientY};
                    tip.mouseDown = true;
                });
                tip.find('.CCTipRotate').addEventListener('mousedown', function (e) {
                    //find out the position of cc.canvas
                    var canvaspos = cc.$.findpos(cc.canvas);
                    //find out the bottom left position of cc.canvas, adding canvas height to canvaspos
                    var canvaspos = {x:canvaspos.x, y:canvaspos.y + cc.canvas.height};
                    //add the position of the element from canvas bottom left
                    tip.nodepos = tip.target.getPosition();
                    tip.nodepos = {x:canvaspos.x + tip.nodepos.x, y:canvaspos.y - tip.nodepos.y};
                    tip.startPos = {x:e.x, y:e.y};
                    tip.mode = 'rot';
                    tip.initialpos = {x:e.clientX, y:e.clientY};
                    tip.mouseDown = true;
                    //also need to find out the starting angle
                    var C = {x:tip.startPos.x, y:tip.nodepos.y};
                    var A = tip.startPos;
                    var B = tip.nodepos;
                    var a = Math.sqrt(Math.pow((B.x - C.x), 2) + Math.pow((B.y - C.y), 2));
                    var b = Math.sqrt(Math.pow((A.x - C.x), 2) + Math.pow((A.y - C.y), 2));
                    var c = Math.sqrt(Math.pow((A.x - B.x), 2) + Math.pow((A.y - B.y), 2));
                    var theta = ((a * a) + (c * c) - (b * b)) / (2 * a * c);
                    var theta = Math.acos(theta) * (180 / cc.PI);
                    tip.startAngle = theta;
                    tip.startRot = tip.target.getRotation();
                });
                tip.find('.CCTipScale').addEventListener('mousedown', function (e) {
                    tip.mode = 'scale';
                    tip.initialpos = {x:e.clientX, y:e.clientY};
                    tip.mouseDown = true;
                });
                tip.find('.CCTipSkew').addEventListener('mousedown', function (e) {
                    tip.mode = 'skew';
                    tip.initialpos = {x:e.clientX, y:e.clientY};
                    tip.mouseDown = true;
                });
                document.body.addEventListener('mousemove', function (e) {
                    if (tip.mode == 'move') {
                        var movex = e.clientX - tip.initialpos.x;
                        var movey = e.clientY - tip.initialpos.y;
                        var nodepos = tip.target.getPosition();
                        tip.target.setPosition(movex + nodepos.x, -movey + nodepos.y);
                        tip.initialpos = {x:e.clientX, y:e.clientY};
                        tip.updateNumbers();
                    }
                    else if (tip.mode == 'rot') {
                        //get the third point position
                        var C = {x:e.x, y:e.y};
                        var A = tip.startPos;
                        var B = tip.nodepos;
                        var a = Math.sqrt(Math.pow((B.x - C.x), 2) + Math.pow((B.y - C.y), 2));
                        var b = Math.sqrt(Math.pow((A.x - C.x), 2) + Math.pow((A.y - C.y), 2));
                        var c = Math.sqrt(Math.pow((A.x - B.x), 2) + Math.pow((A.y - B.y), 2));
                        var theta = ((a * a) + (c * c) - (b * b)) / (2 * a * c);
                        var theta = Math.acos(theta) * (180 / cc.PI);
                        //console.log({a:a,b:b,c:c,A:A,B:B,C:C});


                        //get current mouse
                        var movey = e.clientY - tip.initialpos.y;
                        var movex = e.clientX - tip.initialpos.x;
                        if (e.y > tip.startPos.y) {
                            tip.target.setRotation(-theta + tip.startRot);
                        }
                        else {
                            tip.target.setRotation(theta + tip.startRot);
                        }
                        tip.updateNumbers();
                    }
                    else if (tip.mode == 'scale') {
                        //find out the position of cc.canvas
                        //find out the bottom left position of cc.canvas
                        //add the position of the element from canvas bottom left
                        var movey = e.clientY - tip.initialpos.y;
                        var movex = e.clientX - tip.initialpos.x;
                        var nodescalex = tip.target.getScaleX();
                        var nodescaley = tip.target.getScaleY();
                        tip.target.setScale(nodescalex - (movex / 150), nodescaley + (movey / 150));
                        tip.initialpos = {x:e.clientX, y:e.clientY};
                        tip.updateNumbers();
                    }
                    else if (tip.mode == 'skew') {
                        var movey = e.clientY - tip.initialpos.y;
                        var movex = e.clientX - tip.initialpos.x;
                        var nodeskewx = tip.target.getSkewX();
                        var nodeskewy = tip.target.getSkewY();
                        tip.target.setSkewX(nodeskewx - (movex / 4));
                        tip.target.setSkewY(nodeskewy + (movey / 4));
                        tip.initialpos = {x:e.clientX, y:e.clientY};
                        tip.updateNumbers();
                    }
                });
                tip.find('#CCCloseButton').addEventListener('click', function () {
                    tip.mode = null;
                    tip.style.display = 'none';
                    tip.mouseDown = false;
                });
                document.addEventListener('mouseup', function () {
                    tip.mode = null;
                    tip.mouseDown = false;
                });
            }
            args[i].dom.ccnode = args[i];
            var that = args[i];
            args[i].dom.addEventListener('mouseover', function () {
                if (!cc.DOM.tooltip.mouseDown) {
                    var pos = cc.$.findpos(this);
                    cc.DOM.tooltip.style.display = 'block';
                    cc.DOM.tooltip.prependTo(this);
                    cc.DOM.tooltip.target = that;
                    this.style.zIndex = 999999;
                    cc.DOM.tooltip.updateNumbers();
                }
            });
            args[i].dom.addEventListener('mouseout', function () {
                this.style.zIndex = this.ccnode._zOrder;
            });
        }
    }


};